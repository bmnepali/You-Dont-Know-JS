<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#you-dont-know-js-this-object-prototypes">You Don't Know JS: <em>this</em> &amp; Object Prototypes</a></li>
<li><a href="#chapter-1-this-or-that">Chapter 1: <code>this</code> Or That?</a><ul>
<li><a href="#why-this">Why <code>this</code>?</a></li>
<li><a href="#confusions">Confusions</a></li>
<li><a href="#whats-this">What's <code>this</code>?</a></li>
<li><a href="#review-tldr">Review (TL;DR)</a></li>
</ul></li>
<li><a href="#you-dont-know-js-this-object-prototypes-1">You Don't Know JS: <em>this</em> &amp; Object Prototypes</a></li>
<li><a href="#chapter-2-this-all-makes-sense-now">Chapter 2: <code>this</code> All Makes Sense Now!</a><ul>
<li><a href="#call-site">Call-site</a></li>
<li><a href="#nothing-but-rules">Nothing But Rules</a></li>
<li><a href="#everything-in-order">Everything In Order</a></li>
<li><a href="#binding-exceptions">Binding Exceptions</a></li>
<li><a href="#lexical-this">Lexical <code>this</code></a></li>
<li><a href="#review-tldr-1">Review (TL;DR)</a></li>
</ul></li>
<li><a href="#you-dont-know-js-this-object-prototypes-2">You Don't Know JS: <em>this</em> &amp; Object Prototypes</a></li>
<li><a href="#chapter-3-objects">Chapter 3: Objects</a><ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#type">Type</a></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#iteration">Iteration</a></li>
<li><a href="#review-tldr-2">Review (TL;DR)</a></li>
</ul></li>
<li><a href="#you-dont-know-js-this-object-prototypes-3">You Don't Know JS: <em>this</em> &amp; Object Prototypes</a></li>
<li><a href="#chapter-4-mixing-up-class-objects">Chapter 4: Mixing (Up) &quot;Class&quot; Objects</a><ul>
<li><a href="#class-theory">Class Theory</a></li>
<li><a href="#class-mechanics">Class Mechanics</a></li>
<li><a href="#class-inheritance">Class Inheritance</a></li>
<li><a href="#mixins">Mixins</a></li>
<li><a href="#review-tldr-3">Review (TL;DR)</a></li>
</ul></li>
<li><a href="#you-dont-know-js-this-object-prototypes-4">You Don't Know JS: <em>this</em> &amp; Object Prototypes</a></li>
<li><a href="#chapter-5-prototypes">Chapter 5: Prototypes</a><ul>
<li><a href="#prototype"><code>[[Prototype]]</code></a></li>
<li><a href="#class">&quot;Class&quot;</a></li>
<li><a href="#prototypal-inheritance">&quot;(Prototypal) Inheritance&quot;</a></li>
<li><a href="#object-links">Object Links</a></li>
<li><a href="#review-tldr-4">Review (TL;DR)</a></li>
</ul></li>
<li><a href="#you-dont-know-js-this-object-prototypes-5">You Don't Know JS: <em>this</em> &amp; Object Prototypes</a></li>
<li><a href="#appendix-a-es6-class">Appendix A: ES6 <code>class</code></a><ul>
<li><a href="#class-1"><code>class</code></a></li>
<li><a href="#class-gotchas"><code>class</code> Gotchas</a></li>
</ul></li>
<li><a href="#static-dynamic">Static &gt; Dynamic?</a><ul>
<li><a href="#review-tldr-5">Review (TL;DR)</a></li>
</ul></li>
<li><a href="#you-dont-know-js-this-object-prototypes-6">You Don't Know JS: <em>this</em> &amp; Object Prototypes</a></li>
<li><a href="#appendix-b-acknowledgments">Appendix B: Acknowledgments</a></li>
</ul>
</nav>
<h1 id="you-dont-know-js-this-object-prototypes">You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>
<h1 id="chapter-1-this-or-that">Chapter 1: <code>this</code> Or That?</h1>
<p>One of the most confused mechanisms in JavaScript is the <code>this</code> keyword. It's a special identifier keyword that's automatically defined in the scope of every function, but what exactly it refers to bedevils even seasoned JavaScript developers.</p>
<blockquote>
<p>Any sufficiently <em>advanced</em> technology is indistinguishable from magic. -- Arthur C. Clarke</p>
</blockquote>
<p>JavaScript's <code>this</code> mechanism isn't actually <em>that</em> advanced, but developers often paraphrase that quote in their own mind by inserting &quot;complex&quot; or &quot;confusing&quot;, and there's no question that without lack of clear understanding, <code>this</code> can seem downright magical in <em>your</em> confusion.</p>
<p><strong>Note:</strong> The word &quot;this&quot; is a terribly common pronoun in general discourse. So, it can be very difficult, especially verbally, to determine whether we are using &quot;this&quot; as a pronoun or using it to refer to the actual keyword identifier. For clarity, I will always use <code>this</code> to refer to the special keyword, and &quot;this&quot; or <em>this</em> or this otherwise.</p>
<h2 id="why-this">Why <code>this</code>?</h2>
<p>If the <code>this</code> mechanism is so confusing, even to seasoned JavaScript developers, one may wonder why it's even useful? Is it more trouble than it's worth? Before we jump into the <em>how</em>, we should examine the <em>why</em>.</p>
<p>Let's try to illustrate the motivation and utility of <code>this</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">identify</span>() <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="va">name</span>.<span class="at">toUpperCase</span>()<span class="op">;</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">speak</span>() <span class="op">{</span>
    <span class="kw">var</span> greeting <span class="op">=</span> <span class="st">&quot;Hello, I&#39;m &quot;</span> <span class="op">+</span> <span class="va">identify</span>.<span class="at">call</span>( <span class="kw">this</span> )<span class="op">;</span>
    <span class="va">console</span>.<span class="at">log</span>( greeting )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> me <span class="op">=</span> <span class="op">{</span>
    <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Kyle&quot;</span>
<span class="op">};</span>

<span class="kw">var</span> you <span class="op">=</span> <span class="op">{</span>
    <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Reader&quot;</span>
<span class="op">};</span>

<span class="va">identify</span>.<span class="at">call</span>( me )<span class="op">;</span> <span class="co">// KYLE</span>
<span class="va">identify</span>.<span class="at">call</span>( you )<span class="op">;</span> <span class="co">// READER</span>

<span class="va">speak</span>.<span class="at">call</span>( me )<span class="op">;</span> <span class="co">// Hello, I&#39;m KYLE</span>
<span class="va">speak</span>.<span class="at">call</span>( you )<span class="op">;</span> <span class="co">// Hello, I&#39;m READER</span></code></pre></div>
<p>If the <em>how</em> of this snippet confuses you, don't worry! We'll get to that shortly. Just set those questions aside briefly so we can look into the <em>why</em> more clearly.</p>
<p>This code snippet allows the <code>identify()</code> and <code>speak()</code> functions to be re-used against multiple <em>context</em> (<code>me</code> and <code>you</code>) objects, rather than needing a separate version of the function for each object.</p>
<p>Instead of relying on <code>this</code>, you could have explicitly passed in a context object to both <code>identify()</code> and <code>speak()</code>.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">identify</span>(context) <span class="op">{</span>
    <span class="cf">return</span> <span class="va">context</span>.<span class="va">name</span>.<span class="at">toUpperCase</span>()<span class="op">;</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">speak</span>(context) <span class="op">{</span>
    <span class="kw">var</span> greeting <span class="op">=</span> <span class="st">&quot;Hello, I&#39;m &quot;</span> <span class="op">+</span> <span class="at">identify</span>( context )<span class="op">;</span>
    <span class="va">console</span>.<span class="at">log</span>( greeting )<span class="op">;</span>
<span class="op">}</span>

<span class="at">identify</span>( you )<span class="op">;</span> <span class="co">// READER</span>
<span class="at">speak</span>( me )<span class="op">;</span> <span class="co">// Hello, I&#39;m KYLE</span></code></pre></div>
<p>However, the <code>this</code> mechanism provides a more elegant way of implicitly &quot;passing along&quot; an object reference, leading to cleaner API design and easier re-use.</p>
<p>The more complex your usage pattern is, the more clearly you'll see that passing context around as an explicit parameter is often messier than passing around a <code>this</code> context. When we explore objects and prototypes, you will see the helpfulness of a collection of functions being able to automatically reference the proper context object.</p>
<h2 id="confusions">Confusions</h2>
<p>We'll soon begin to explain how <code>this</code> <em>actually</em> works, but first we must dispel some misconceptions about how it <em>doesn't</em> actually work.</p>
<p>The name &quot;this&quot; creates confusion when developers try to think about it too literally. There are two meanings often assumed, but both are incorrect.</p>
<h3 id="itself">Itself</h3>
<p>The first common temptation is to assume <code>this</code> refers to the function itself. That's a reasonable grammatical inference, at least.</p>
<p>Why would you want to refer to a function from inside itself? The most common reasons would be things like recursion (calling a function from inside itself) or having an event handler that can unbind itself when it's first called.</p>
<p>Developers new to JS's mechanisms often think that referencing the function as an object (all functions in JavaScript are objects!) lets you store <em>state</em> (values in properties) between function calls. While this is certainly possible and has some limited uses, the rest of the book will expound on many other patterns for <em>better</em> places to store state besides the function object.</p>
<p>But for just a moment, we'll explore that pattern, to illustrate how <code>this</code> doesn't let a function get a reference to itself like we might have assumed.</p>
<p>Consider the following code, where we attempt to track how many times a function (<code>foo</code>) was called:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(num) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;foo: &quot;</span> <span class="op">+</span> num )<span class="op">;</span>

    <span class="co">// keep track of how many times `foo` is called</span>
    <span class="kw">this</span>.<span class="at">count</span><span class="op">++;</span>
<span class="op">}</span>

<span class="va">foo</span>.<span class="at">count</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>

<span class="kw">var</span> i<span class="op">;</span>

<span class="cf">for</span> (i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="dv">10</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="cf">if</span> (i <span class="op">&gt;</span> <span class="dv">5</span>) <span class="op">{</span>
        <span class="at">foo</span>( i )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>
<span class="co">// foo: 6</span>
<span class="co">// foo: 7</span>
<span class="co">// foo: 8</span>
<span class="co">// foo: 9</span>

<span class="co">// how many times was `foo` called?</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">foo</span>.<span class="at">count</span> )<span class="op">;</span> <span class="co">// 0 -- WTF?</span></code></pre></div>
<p><code>foo.count</code> is <em>still</em> <code>0</code>, even though the four <code>console.log</code> statements clearly indicate <code>foo(..)</code> was in fact called four times. The frustration stems from a <em>too literal</em> interpretation of what <code>this</code> (in <code>this.count++</code>) means.</p>
<p>When the code executes <code>foo.count = 0</code>, indeed it's adding a property <code>count</code> to the function object <code>foo</code>. But for the <code>this.count</code> reference inside of the function, <code>this</code> is not in fact pointing <em>at all</em> to that function object, and so even though the property names are the same, the root objects are different, and confusion ensues.</p>
<p><strong>Note:</strong> A responsible developer <em>should</em> ask at this point, &quot;If I was incrementing a <code>count</code> property but it wasn't the one I expected, which <code>count</code> <em>was</em> I incrementing?&quot; In fact, were she to dig deeper, she would find that she had accidentally created a global variable <code>count</code> (see Chapter 2 for <em>how</em> that happened!), and it currently has the value <code>NaN</code>. Of course, once she identifies this peculiar outcome, she then has a whole other set of questions: &quot;How was it global, and why did it end up <code>NaN</code> instead of some proper count value?&quot; (see Chapter 2).</p>
<p>Instead of stopping at this point and digging into why the <code>this</code> reference doesn't seem to be behaving as <em>expected</em>, and answering those tough but important questions, many developers simply avoid the issue altogether, and hack toward some other solution, such as creating another object to hold the <code>count</code> property:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(num) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;foo: &quot;</span> <span class="op">+</span> num )<span class="op">;</span>

    <span class="co">// keep track of how many times `foo` is called</span>
    <span class="va">data</span>.<span class="at">count</span><span class="op">++;</span>
<span class="op">}</span>

<span class="kw">var</span> data <span class="op">=</span> <span class="op">{</span>
    <span class="dt">count</span><span class="op">:</span> <span class="dv">0</span>
<span class="op">};</span>

<span class="kw">var</span> i<span class="op">;</span>

<span class="cf">for</span> (i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="dv">10</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="cf">if</span> (i <span class="op">&gt;</span> <span class="dv">5</span>) <span class="op">{</span>
        <span class="at">foo</span>( i )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>
<span class="co">// foo: 6</span>
<span class="co">// foo: 7</span>
<span class="co">// foo: 8</span>
<span class="co">// foo: 9</span>

<span class="co">// how many times was `foo` called?</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">data</span>.<span class="at">count</span> )<span class="op">;</span> <span class="co">// 4</span></code></pre></div>
<p>While it is true that this approach &quot;solves&quot; the problem, unfortunately it simply ignores the real problem -- lack of understanding what <code>this</code> means and how it works -- and instead falls back to the comfort zone of a more familiar mechanism: lexical scope.</p>
<p><strong>Note:</strong> Lexical scope is a perfectly fine and useful mechanism; I am not belittling the use of it, by any means (see <em>&quot;Scope &amp; Closures&quot;</em> title of this book series). But constantly <em>guessing</em> at how to use <code>this</code>, and usually being <em>wrong</em>, is not a good reason to retreat back to lexical scope and never learn <em>why</em> <code>this</code> eludes you.</p>
<p>To reference a function object from inside itself, <code>this</code> by itself will typically be insufficient. You generally need a reference to the function object via a lexical identifier (variable) that points at it.</p>
<p>Consider these two functions:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">foo</span>.<span class="at">count</span> <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> <span class="co">// `foo` refers to itself</span>
<span class="op">}</span>

<span class="at">setTimeout</span>( <span class="kw">function</span>()<span class="op">{</span>
    <span class="co">// anonymous function (no name), cannot</span>
    <span class="co">// refer to itself</span>
<span class="op">},</span> <span class="dv">10</span> )<span class="op">;</span></code></pre></div>
<p>In the first function, called a &quot;named function&quot;, <code>foo</code> is a reference that can be used to refer to the function from inside itself.</p>
<p>But in the second example, the function callback passed to <code>setTimeout(..)</code> has no name identifier (so called an &quot;anonymous function&quot;), so there's no proper way to refer to the function object itself.</p>
<p><strong>Note:</strong> The old-school but now deprecated and frowned-upon <code>arguments.callee</code> reference inside a function <em>also</em> points to the function object of the currently executing function. This reference is typically the only way to access an anonymous function's object from inside itself. The best approach, however, is to avoid the use of anonymous functions altogether, at least for those which require a self-reference, and instead use a named function (expression). <code>arguments.callee</code> is deprecated and should not be used.</p>
<p>So another solution to our running example would have been to use the <code>foo</code> identifier as a function object reference in each place, and not use <code>this</code> at all, which <em>works</em>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(num) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;foo: &quot;</span> <span class="op">+</span> num )<span class="op">;</span>

    <span class="co">// keep track of how many times `foo` is called</span>
    <span class="va">foo</span>.<span class="at">count</span><span class="op">++;</span>
<span class="op">}</span>

<span class="va">foo</span>.<span class="at">count</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>

<span class="kw">var</span> i<span class="op">;</span>

<span class="cf">for</span> (i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="dv">10</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="cf">if</span> (i <span class="op">&gt;</span> <span class="dv">5</span>) <span class="op">{</span>
        <span class="at">foo</span>( i )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>
<span class="co">// foo: 6</span>
<span class="co">// foo: 7</span>
<span class="co">// foo: 8</span>
<span class="co">// foo: 9</span>

<span class="co">// how many times was `foo` called?</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">foo</span>.<span class="at">count</span> )<span class="op">;</span> <span class="co">// 4</span></code></pre></div>
<p>However, that approach similarly side-steps <em>actual</em> understanding of <code>this</code> and relies entirely on the lexical scoping of variable <code>foo</code>.</p>
<p>Yet another way of approaching the issue is to force <code>this</code> to actually point at the <code>foo</code> function object:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(num) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;foo: &quot;</span> <span class="op">+</span> num )<span class="op">;</span>

    <span class="co">// keep track of how many times `foo` is called</span>
    <span class="co">// Note: `this` IS actually `foo` now, based on</span>
    <span class="co">// how `foo` is called (see below)</span>
    <span class="kw">this</span>.<span class="at">count</span><span class="op">++;</span>
<span class="op">}</span>

<span class="va">foo</span>.<span class="at">count</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>

<span class="kw">var</span> i<span class="op">;</span>

<span class="cf">for</span> (i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="dv">10</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="cf">if</span> (i <span class="op">&gt;</span> <span class="dv">5</span>) <span class="op">{</span>
        <span class="co">// using `call(..)`, we ensure the `this`</span>
        <span class="co">// points at the function object (`foo`) itself</span>
        <span class="va">foo</span>.<span class="at">call</span>( foo<span class="op">,</span> i )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>
<span class="co">// foo: 6</span>
<span class="co">// foo: 7</span>
<span class="co">// foo: 8</span>
<span class="co">// foo: 9</span>

<span class="co">// how many times was `foo` called?</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">foo</span>.<span class="at">count</span> )<span class="op">;</span> <span class="co">// 4</span></code></pre></div>
<p><strong>Instead of avoiding <code>this</code>, we embrace it.</strong> We'll explain in a little bit <em>how</em> such techniques work much more completely, so don't worry if you're still a bit confused!</p>
<h3 id="its-scope">Its Scope</h3>
<p>The next most common misconception about the meaning of <code>this</code> is that it somehow refers to the function's scope. It's a tricky question, because in one sense there is some truth, but in the other sense, it's quite misguided.</p>
<p>To be clear, <code>this</code> does not, in any way, refer to a function's <strong>lexical scope</strong>. It is true that internally, scope is kind of like an object with properties for each of the available identifiers. But the scope &quot;object&quot; is not accessible to JavaScript code. It's an inner part of the <em>Engine</em>'s implementation.</p>
<p>Consider code which attempts (and fails!) to cross over the boundary and use <code>this</code> to implicitly refer to a function's lexical scope:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
    <span class="kw">this</span>.<span class="at">bar</span>()<span class="op">;</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">bar</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="at">foo</span>()<span class="op">;</span> <span class="co">//undefined</span></code></pre></div>
<p>There's more than one mistake in this snippet. While it may seem contrived, the code you see is a distillation of actual real-world code that has been exchanged in public community help forums. It's a wonderful (if not sad) illustration of just how misguided <code>this</code> assumptions can be.</p>
<p>Firstly, an attempt is made to reference the <code>bar()</code> function via <code>this.bar()</code>. It is almost certainly an <em>accident</em> that it works, but we'll explain the <em>how</em> of that shortly. The most natural way to have invoked <code>bar()</code> would have been to omit the leading <code>this.</code> and just make a lexical reference to the identifier.</p>
<p>However, the developer who writes such code is attempting to use <code>this</code> to create a bridge between the lexical scopes of <code>foo()</code> and <code>bar()</code>, so that <code>bar()</code> has access to the variable <code>a</code> in the inner scope of <code>foo()</code>. <strong>No such bridge is possible.</strong> You cannot use a <code>this</code> reference to look something up in a lexical scope. It is not possible.</p>
<p>Every time you feel yourself trying to mix lexical scope look-ups with <code>this</code>, remind yourself: <em>there is no bridge</em>.</p>
<h2 id="whats-this">What's <code>this</code>?</h2>
<p>Having set aside various incorrect assumptions, let us now turn our attention to how the <code>this</code> mechanism really works.</p>
<p>We said earlier that <code>this</code> is not an author-time binding but a runtime binding. It is contextual based on the conditions of the function's invocation. <code>this</code> binding has nothing to do with where a function is declared, but has instead everything to do with the manner in which the function is called.</p>
<p>When a function is invoked, an activation record, otherwise known as an execution context, is created. This record contains information about where the function was called from (the call-stack), <em>how</em> the function was invoked, what parameters were passed, etc. One of the properties of this record is the <code>this</code> reference which will be used for the duration of that function's execution.</p>
<p>In the next chapter, we will learn to find a function's <strong>call-site</strong> to determine how its execution will bind <code>this</code>.</p>
<h2 id="review-tldr">Review (TL;DR)</h2>
<p><code>this</code> binding is a constant source of confusion for the JavaScript developer who does not take the time to learn how the mechanism actually works. Guesses, trial-and-error, and blind copy-n-paste from Stack Overflow answers is not an effective or proper way to leverage <em>this</em> important <code>this</code> mechanism.</p>
<p>To learn <code>this</code>, you first have to learn what <code>this</code> is <em>not</em>, despite any assumptions or misconceptions that may lead you down those paths. <code>this</code> is neither a reference to the function itself, nor is it a reference to the function's <em>lexical</em> scope.</p>
<p><code>this</code> is actually a binding that is made when a function is invoked, and <em>what</em> it references is determined entirely by the call-site where the function is called.</p>
<h1 id="you-dont-know-js-this-object-prototypes-1">You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>
<h1 id="chapter-2-this-all-makes-sense-now">Chapter 2: <code>this</code> All Makes Sense Now!</h1>
<p>In Chapter 1, we discarded various misconceptions about <code>this</code> and learned instead that <code>this</code> is a binding made for each function invocation, based entirely on its <strong>call-site</strong> (how the function is called).</p>
<h2 id="call-site">Call-site</h2>
<p>To understand <code>this</code> binding, we have to understand the call-site: the location in code where a function is called (<strong>not where it's declared</strong>). We must inspect the call-site to answer the question: what's <em>this</em> <code>this</code> a reference to?</p>
<p>Finding the call-site is generally: &quot;go locate where a function is called from&quot;, but it's not always that easy, as certain coding patterns can obscure the <em>true</em> call-site.</p>
<p>What's important is to think about the <strong>call-stack</strong> (the stack of functions that have been called to get us to the current moment in execution). The call-site we care about is <em>in</em> the invocation <em>before</em> the currently executing function.</p>
<p>Let's demonstrate call-stack and call-site:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">baz</span>() <span class="op">{</span>
    <span class="co">// call-stack is: `baz`</span>
    <span class="co">// so, our call-site is in the global scope</span>

    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;baz&quot;</span> )<span class="op">;</span>
    <span class="at">bar</span>()<span class="op">;</span> <span class="co">// &lt;-- call-site for `bar`</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">bar</span>() <span class="op">{</span>
    <span class="co">// call-stack is: `baz` -&gt; `bar`</span>
    <span class="co">// so, our call-site is in `baz`</span>

    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;bar&quot;</span> )<span class="op">;</span>
    <span class="at">foo</span>()<span class="op">;</span> <span class="co">// &lt;-- call-site for `foo`</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="co">// call-stack is: `baz` -&gt; `bar` -&gt; `foo`</span>
    <span class="co">// so, our call-site is in `bar`</span>

    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;foo&quot;</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="at">baz</span>()<span class="op">;</span> <span class="co">// &lt;-- call-site for `baz`</span></code></pre></div>
<p>Take care when analyzing code to find the actual call-site (from the call-stack), because it's the only thing that matters for <code>this</code> binding.</p>
<p><strong>Note:</strong> You can visualize a call-stack in your mind by looking at the chain of function calls in order, as we did with the comments in the above snippet. But this is painstaking and error-prone. Another way of seeing the call-stack is using a debugger tool in your browser. Most modern desktop browsers have built-in developer tools, which includes a JS debugger. In the above snippet, you could have set a breakpoint in the tools for the first line of the <code>foo()</code> function, or simply inserted the <code>debugger;</code> statement on that first line. When you run the page, the debugger will pause at this location, and will show you a list of the functions that have been called to get to that line, which will be your call stack. So, if you're trying to diagnose <code>this</code> binding, use the developer tools to get the call-stack, then find the second item from the top, and that will show you the real call-site.</p>
<h2 id="nothing-but-rules">Nothing But Rules</h2>
<p>We turn our attention now to <em>how</em> the call-site determines where <code>this</code> will point during the execution of a function.</p>
<p>You must inspect the call-site and determine which of 4 rules applies. We will first explain each of these 4 rules independently, and then we will illustrate their order of precedence, if multiple rules <em>could</em> apply to the call-site.</p>
<h3 id="default-binding">Default Binding</h3>
<p>The first rule we will examine comes from the most common case of function calls: standalone function invocation. Think of <em>this</em> <code>this</code> rule as the default catch-all rule when none of the other rules apply.</p>
<p>Consider this code:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>

<span class="at">foo</span>()<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>The first thing to note, if you were not already aware, is that variables declared in the global scope, as <code>var a = 2</code> is, are synonymous with global-object properties of the same name. They're not copies of each other, they <em>are</em> each other. Think of it as two sides of the same coin.</p>
<p>Secondly, we see that when <code>foo()</code> is called, <code>this.a</code> resolves to our global variable <code>a</code>. Why? Because in this case, the <em>default binding</em> for <code>this</code> applies to the function call, and so points <code>this</code> at the global object.</p>
<p>How do we know that the <em>default binding</em> rule applies here? We examine the call-site to see how <code>foo()</code> is called. In our snippet, <code>foo()</code> is called with a plain, un-decorated function reference. None of the other rules we will demonstrate will apply here, so the <em>default binding</em> applies instead.</p>
<p>If <code>strict mode</code> is in effect, the global object is not eligible for the <em>default binding</em>, so the <code>this</code> is instead set to <code>undefined</code>.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="st">&quot;use strict&quot;</span><span class="op">;</span>

    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>

<span class="at">foo</span>()<span class="op">;</span> <span class="co">// TypeError: `this` is `undefined`</span></code></pre></div>
<p>A subtle but important detail is: even though the overall <code>this</code> binding rules are entirely based on the call-site, the global object is <strong>only</strong> eligible for the <em>default binding</em> if the <strong>contents</strong> of <code>foo()</code> are <strong>not</strong> running in <code>strict mode</code>; the <code>strict mode</code> state of the call-site of <code>foo()</code> is irrelevant.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>

(<span class="kw">function</span>()<span class="op">{</span>
    <span class="st">&quot;use strict&quot;</span><span class="op">;</span>

    <span class="at">foo</span>()<span class="op">;</span> <span class="co">// 2</span>
<span class="op">}</span>)()<span class="op">;</span></code></pre></div>
<p><strong>Note:</strong> Intentionally mixing <code>strict mode</code> and non-<code>strict mode</code> together in your own code is generally frowned upon. Your entire program should probably either be <strong>Strict</strong> or <strong>non-Strict</strong>. However, sometimes you include a third-party library that has different <strong>Strict</strong>'ness than your own code, so care must be taken over these subtle compatibility details.</p>
<h3 id="implicit-binding">Implicit Binding</h3>
<p>Another rule to consider is: does the call-site have a context object, also referred to as an owning or containing object, though <em>these</em> alternate terms could be slightly misleading.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> foo
<span class="op">};</span>

<span class="va">obj</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>Firstly, notice the manner in which <code>foo()</code> is declared and then later added as a reference property onto <code>obj</code>. Regardless of whether <code>foo()</code> is initially declared <em>on</em> <code>obj</code>, or is added as a reference later (as this snippet shows), in neither case is the <strong>function</strong> really &quot;owned&quot; or &quot;contained&quot; by the <code>obj</code> object.</p>
<p>However, the call-site <em>uses</em> the <code>obj</code> context to <strong>reference</strong> the function, so you <em>could</em> say that the <code>obj</code> object &quot;owns&quot; or &quot;contains&quot; the <strong>function reference</strong> at the time the function is called.</p>
<p>Whatever you choose to call this pattern, at the point that <code>foo()</code> is called, it's preceded by an object reference to <code>obj</code>. When there is a context object for a function reference, the <em>implicit binding</em> rule says that it's <em>that</em> object which should be used for the function call's <code>this</code> binding.</p>
<p>Because <code>obj</code> is the <code>this</code> for the <code>foo()</code> call, <code>this.a</code> is synonymous with <code>obj.a</code>.</p>
<p>Only the top/last level of an object property reference chain matters to the call-site. For instance:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj2 <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> foo
<span class="op">};</span>

<span class="kw">var</span> obj1 <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">obj2</span><span class="op">:</span> obj2
<span class="op">};</span>

<span class="va">obj1</span>.<span class="va">obj2</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// 42</span></code></pre></div>
<h4 id="implicitly-lost">Implicitly Lost</h4>
<p>One of the most common frustrations that <code>this</code> binding creates is when an <em>implicitly bound</em> function loses that binding, which usually means it falls back to the <em>default binding</em>, of either the global object or <code>undefined</code>, depending on <code>strict mode</code>.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> foo
<span class="op">};</span>

<span class="kw">var</span> bar <span class="op">=</span> <span class="va">obj</span>.<span class="at">foo</span><span class="op">;</span> <span class="co">// function reference/alias!</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;oops, global&quot;</span><span class="op">;</span> <span class="co">// `a` also property on global object</span>

<span class="at">bar</span>()<span class="op">;</span> <span class="co">// &quot;oops, global&quot;</span></code></pre></div>
<p>Even though <code>bar</code> appears to be a reference to <code>obj.foo</code>, in fact, it's really just another reference to <code>foo</code> itself. Moreover, the call-site is what matters, and the call-site is <code>bar()</code>, which is a plain, un-decorated call and thus the <em>default binding</em> applies.</p>
<p>The more subtle, more common, and more unexpected way this occurs is when we consider passing a callback function:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">doFoo</span>(fn) <span class="op">{</span>
    <span class="co">// `fn` is just another reference to `foo`</span>

    <span class="at">fn</span>()<span class="op">;</span> <span class="co">// &lt;-- call-site!</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> foo
<span class="op">};</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;oops, global&quot;</span><span class="op">;</span> <span class="co">// `a` also property on global object</span>

<span class="at">doFoo</span>( <span class="va">obj</span>.<span class="at">foo</span> )<span class="op">;</span> <span class="co">// &quot;oops, global&quot;</span></code></pre></div>
<p>Parameter passing is just an implicit assignment, and since we're passing a function, it's an implicit reference assignment, so the end result is the same as the previous snippet.</p>
<p>What if the function you're passing your callback to is not your own, but built-in to the language? No difference, same outcome.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> foo
<span class="op">};</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;oops, global&quot;</span><span class="op">;</span> <span class="co">// `a` also property on global object</span>

<span class="at">setTimeout</span>( <span class="va">obj</span>.<span class="at">foo</span><span class="op">,</span> <span class="dv">100</span> )<span class="op">;</span> <span class="co">// &quot;oops, global&quot;</span></code></pre></div>
<p>Think about this crude theoretical pseudo-implementation of <code>setTimeout()</code> provided as a built-in from the JavaScript environment:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">setTimeout</span>(fn<span class="op">,</span>delay) <span class="op">{</span>
    <span class="co">// wait (somehow) for `delay` milliseconds</span>
    <span class="at">fn</span>()<span class="op">;</span> <span class="co">// &lt;-- call-site!</span>
<span class="op">}</span></code></pre></div>
<p>It's quite common that our function callbacks <em>lose</em> their <code>this</code> binding, as we've just seen. But another way that <code>this</code> can surprise us is when the function we've passed our callback to intentionally changes the <code>this</code> for the call. Event handlers in popular JavaScript libraries are quite fond of forcing your callback to have a <code>this</code> which points to, for instance, the DOM element that triggered the event. While that may sometimes be useful, other times it can be downright infuriating. Unfortunately, these tools rarely let you choose.</p>
<p>Either way the <code>this</code> is changed unexpectedly, you are not really in control of how your callback function reference will be executed, so you have no way (yet) of controlling the call-site to give your intended binding. We'll see shortly a way of &quot;fixing&quot; that problem by <em>fixing</em> the <code>this</code>.</p>
<h3 id="explicit-binding">Explicit Binding</h3>
<p>With <em>implicit binding</em> as we just saw, we had to mutate the object in question to include a reference on itself to the function, and use this property function reference to indirectly (implicitly) bind <code>this</code> to the object.</p>
<p>But, what if you want to force a function call to use a particular object for the <code>this</code> binding, without putting a property function reference on the object?</p>
<p>&quot;All&quot; functions in the language have some utilities available to them (via their <code>[[Prototype]]</code> -- more on that later) which can be useful for this task. Specifically, functions have <code>call(..)</code> and <code>apply(..)</code> methods. Technically, JavaScript host environments sometimes provide functions which are special enough (a kind way of putting it!) that they do not have such functionality. But those are few. The vast majority of functions provided, and certainly all functions you will create, do have access to <code>call(..)</code> and <code>apply(..)</code>.</p>
<p>How do these utilities work? They both take, as their first parameter, an object to use for the <code>this</code>, and then invoke the function with that <code>this</code> specified. Since you are directly stating what you want the <code>this</code> to be, we call it <em>explicit binding</em>.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">foo</span>.<span class="at">call</span>( obj )<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>Invoking <code>foo</code> with <em>explicit binding</em> by <code>foo.call(..)</code> allows us to force its <code>this</code> to be <code>obj</code>.</p>
<p>If you pass a simple primitive value (of type <code>string</code>, <code>boolean</code>, or <code>number</code>) as the <code>this</code> binding, the primitive value is wrapped in its object-form (<code>new String(..)</code>, <code>new Boolean(..)</code>, or <code>new Number(..)</code>, respectively). This is often referred to as &quot;boxing&quot;.</p>
<p><strong>Note:</strong> With respect to <code>this</code> binding, <code>call(..)</code> and <code>apply(..)</code> are identical. They <em>do</em> behave differently with their additional parameters, but that's not something we care about presently.</p>
<p>Unfortunately, <em>explicit binding</em> alone still doesn't offer any solution to the issue mentioned previously, of a function &quot;losing&quot; its intended <code>this</code> binding, or just having it paved over by a framework, etc.</p>
<h4 id="hard-binding">Hard Binding</h4>
<p>But a variation pattern around <em>explicit binding</em> actually does the trick. Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="kw">var</span> bar <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="va">foo</span>.<span class="at">call</span>( obj )<span class="op">;</span>
<span class="op">};</span>

<span class="at">bar</span>()<span class="op">;</span> <span class="co">// 2</span>
<span class="at">setTimeout</span>( bar<span class="op">,</span> <span class="dv">100</span> )<span class="op">;</span> <span class="co">// 2</span>

<span class="co">// `bar` hard binds `foo`&#39;s `this` to `obj`</span>
<span class="co">// so that it cannot be overriden</span>
<span class="va">bar</span>.<span class="at">call</span>( window )<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>Let's examine how this variation works. We create a function <code>bar()</code> which, internally, manually calls <code>foo.call(obj)</code>, thereby forcibly invoking <code>foo</code> with <code>obj</code> binding for <code>this</code>. No matter how you later invoke the function <code>bar</code>, it will always manually invoke <code>foo</code> with <code>obj</code>. This binding is both explicit and strong, so we call it <em>hard binding</em>.</p>
<p>The most typical way to wrap a function with a <em>hard binding</em> creates a pass-thru of any arguments passed and any return value received:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(something) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span><span class="op">,</span> something )<span class="op">;</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">a</span> <span class="op">+</span> something<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="kw">var</span> bar <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="cf">return</span> <span class="va">foo</span>.<span class="at">apply</span>( obj<span class="op">,</span> arguments )<span class="op">;</span>
<span class="op">};</span>

<span class="kw">var</span> b <span class="op">=</span> <span class="at">bar</span>( <span class="dv">3</span> )<span class="op">;</span> <span class="co">// 2 3</span>
<span class="va">console</span>.<span class="at">log</span>( b )<span class="op">;</span> <span class="co">// 5</span></code></pre></div>
<p>Another way to express this pattern is to create a re-usable helper:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(something) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span><span class="op">,</span> something )<span class="op">;</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">a</span> <span class="op">+</span> something<span class="op">;</span>
<span class="op">}</span>

<span class="co">// simple `bind` helper</span>
<span class="kw">function</span> <span class="at">bind</span>(fn<span class="op">,</span> obj) <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="va">fn</span>.<span class="at">apply</span>( obj<span class="op">,</span> arguments )<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="kw">var</span> bar <span class="op">=</span> <span class="at">bind</span>( foo<span class="op">,</span> obj )<span class="op">;</span>

<span class="kw">var</span> b <span class="op">=</span> <span class="at">bar</span>( <span class="dv">3</span> )<span class="op">;</span> <span class="co">// 2 3</span>
<span class="va">console</span>.<span class="at">log</span>( b )<span class="op">;</span> <span class="co">// 5</span></code></pre></div>
<p>Since <em>hard binding</em> is such a common pattern, it's provided with a built-in utility as of ES5: <code>Function.prototype.bind</code>, and it's used like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(something) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span><span class="op">,</span> something )<span class="op">;</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">a</span> <span class="op">+</span> something<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">bind</span>( obj )<span class="op">;</span>

<span class="kw">var</span> b <span class="op">=</span> <span class="at">bar</span>( <span class="dv">3</span> )<span class="op">;</span> <span class="co">// 2 3</span>
<span class="va">console</span>.<span class="at">log</span>( b )<span class="op">;</span> <span class="co">// 5</span></code></pre></div>
<p><code>bind(..)</code> returns a new function that is hard-coded to call the original function with the <code>this</code> context set as you specified.</p>
<p><strong>Note:</strong> As of ES6, the hard-bound function produced by <code>bind(..)</code> has a <code>.name</code> property that derives from the original <em>target function</em>. For example: <code>bar = foo.bind(..)</code> should have a <code>bar.name</code> value of <code>&quot;bound foo&quot;</code>, which is the function call name that should show up in a stack trace.</p>
<h4 id="api-call-contexts">API Call &quot;Contexts&quot;</h4>
<p>Many libraries' functions, and indeed many new built-in functions in the JavaScript language and host environment, provide an optional parameter, usually called &quot;context&quot;, which is designed as a work-around for you not having to use <code>bind(..)</code> to ensure your callback function uses a particular <code>this</code>.</p>
<p>For instance:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(el) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( el<span class="op">,</span> <span class="kw">this</span>.<span class="at">id</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">id</span><span class="op">:</span> <span class="st">&quot;awesome&quot;</span>
<span class="op">};</span>

<span class="co">// use `obj` as `this` for `foo(..)` calls</span>
[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>].<span class="at">forEach</span>( foo<span class="op">,</span> obj )<span class="op">;</span> <span class="co">// 1 awesome  2 awesome  3 awesome</span></code></pre></div>
<p>Internally, these various functions almost certainly use <em>explicit binding</em> via <code>call(..)</code> or <code>apply(..)</code>, saving you the trouble.</p>
<h3 id="new-binding"><code>new</code> Binding</h3>
<p>The fourth and final rule for <code>this</code> binding requires us to re-think a very common misconception about functions and objects in JavaScript.</p>
<p>In traditional class-oriented languages, &quot;constructors&quot; are special methods attached to classes, that when the class is instantiated with a <code>new</code> operator, the constructor of that class is called. This usually looks something like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">something <span class="op">=</span> <span class="kw">new</span> <span class="at">MyClass</span>(..)<span class="op">;</span></code></pre></div>
<p>JavaScript has a <code>new</code> operator, and the code pattern to use it looks basically identical to what we see in those class-oriented languages; most developers assume that JavaScript's mechanism is doing something similar. However, there really is <em>no connection</em> to class-oriented functionality implied by <code>new</code> usage in JS.</p>
<p>First, let's re-define what a &quot;constructor&quot; in JavaScript is. In JS, constructors are <strong>just functions</strong> that happen to be called with the <code>new</code> operator in front of them. They are not attached to classes, nor are they instantiating a class. They are not even special types of functions. They're just regular functions that are, in essence, hijacked by the use of <code>new</code> in their invocation.</p>
<p>For example, the <code>Number(..)</code> function acting as a constructor, quoting from the ES5.1 spec:</p>
<blockquote>
<p>15.7.2 The Number Constructor</p>
<p>When Number is called as part of a new expression it is a constructor: it initialises the newly created object.</p>
</blockquote>
<p>So, pretty much any ol' function, including the built-in object functions like <code>Number(..)</code> (see Chapter 3) can be called with <code>new</code> in front of it, and that makes that function call a <em>constructor call</em>. This is an important but subtle distinction: there's really no such thing as &quot;constructor functions&quot;, but rather construction calls <em>of</em> functions.</p>
<p>When a function is invoked with <code>new</code> in front of it, otherwise known as a constructor call, the following things are done automatically:</p>
<ol type="1">
<li>a brand new object is created (aka, constructed) out of thin air</li>
<li><em>the newly constructed object is <code>[[Prototype]]</code>-linked</em></li>
<li>the newly constructed object is set as the <code>this</code> binding for that function call</li>
<li>unless the function returns its own alternate <strong>object</strong>, the <code>new</code>-invoked function call will <em>automatically</em> return the newly constructed object.</li>
</ol>
<p>Steps 1, 3, and 4 apply to our current discussion. We'll skip over step 2 for now and come back to it in Chapter 5.</p>
<p>Consider this code:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">a</span> <span class="op">=</span> a<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> bar <span class="op">=</span> <span class="kw">new</span> <span class="at">foo</span>( <span class="dv">2</span> )<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">bar</span>.<span class="at">a</span> )<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>By calling <code>foo(..)</code> with <code>new</code> in front of it, we've constructed a new object and set that new object as the <code>this</code> for the call of <code>foo(..)</code>. <strong>So <code>new</code> is the final way that a function call's <code>this</code> can be bound.</strong> We'll call this <em>new binding</em>.</p>
<h2 id="everything-in-order">Everything In Order</h2>
<p>So, now we've uncovered the 4 rules for binding <code>this</code> in function calls. <em>All</em> you need to do is find the call-site and inspect it to see which rule applies. But, what if the call-site has multiple eligible rules? There must be an order of precedence to these rules, and so we will next demonstrate what order to apply the rules.</p>
<p>It should be clear that the <em>default binding</em> is the lowest priority rule of the 4. So we'll just set that one aside.</p>
<p>Which is more precedent, <em>implicit binding</em> or <em>explicit binding</em>? Let's test it:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj1 <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> foo
<span class="op">};</span>

<span class="kw">var</span> obj2 <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">3</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> foo
<span class="op">};</span>

<span class="va">obj1</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// 2</span>
<span class="va">obj2</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// 3</span>

<span class="va">obj1</span>.<span class="va">foo</span>.<span class="at">call</span>( obj2 )<span class="op">;</span> <span class="co">// 3</span>
<span class="va">obj2</span>.<span class="va">foo</span>.<span class="at">call</span>( obj1 )<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>So, <em>explicit binding</em> takes precedence over <em>implicit binding</em>, which means you should ask <strong>first</strong> if <em>explicit binding</em> applies before checking for <em>implicit binding</em>.</p>
<p>Now, we just need to figure out where <em>new binding</em> fits in the precedence.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(something) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">a</span> <span class="op">=</span> something<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj1 <span class="op">=</span> <span class="op">{</span>
    <span class="dt">foo</span><span class="op">:</span> foo
<span class="op">};</span>

<span class="kw">var</span> obj2 <span class="op">=</span> <span class="op">{};</span>

<span class="va">obj1</span>.<span class="at">foo</span>( <span class="dv">2</span> )<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">obj1</span>.<span class="at">a</span> )<span class="op">;</span> <span class="co">// 2</span>

<span class="va">obj1</span>.<span class="va">foo</span>.<span class="at">call</span>( obj2<span class="op">,</span> <span class="dv">3</span> )<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">obj2</span>.<span class="at">a</span> )<span class="op">;</span> <span class="co">// 3</span>

<span class="kw">var</span> bar <span class="op">=</span> <span class="kw">new</span> <span class="va">obj1</span>.<span class="at">foo</span>( <span class="dv">4</span> )<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">obj1</span>.<span class="at">a</span> )<span class="op">;</span> <span class="co">// 2</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">bar</span>.<span class="at">a</span> )<span class="op">;</span> <span class="co">// 4</span></code></pre></div>
<p>OK, <em>new binding</em> is more precedent than <em>implicit binding</em>. But do you think <em>new binding</em> is more or less precedent than <em>explicit binding</em>?</p>
<p><strong>Note:</strong> <code>new</code> and <code>call</code>/<code>apply</code> cannot be used together, so <code>new foo.call(obj1)</code> is not allowed, to test <em>new binding</em> directly against <em>explicit binding</em>. But we can still use a <em>hard binding</em> to test the precedence of the two rules.</p>
<p>Before we explore that in a code listing, think back to how <em>hard binding</em> physically works, which is that <code>Function.prototype.bind(..)</code> creates a new wrapper function that is hard-coded to ignore its own <code>this</code> binding (whatever it may be), and use a manual one we provide.</p>
<p>By that reasoning, it would seem obvious to assume that <em>hard binding</em> (which is a form of <em>explicit binding</em>) is more precedent than <em>new binding</em>, and thus cannot be overridden with <code>new</code>.</p>
<p>Let's check:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(something) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">a</span> <span class="op">=</span> something<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj1 <span class="op">=</span> <span class="op">{};</span>

<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">bind</span>( obj1 )<span class="op">;</span>
<span class="at">bar</span>( <span class="dv">2</span> )<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">obj1</span>.<span class="at">a</span> )<span class="op">;</span> <span class="co">// 2</span>

<span class="kw">var</span> baz <span class="op">=</span> <span class="kw">new</span> <span class="at">bar</span>( <span class="dv">3</span> )<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">obj1</span>.<span class="at">a</span> )<span class="op">;</span> <span class="co">// 2</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">baz</span>.<span class="at">a</span> )<span class="op">;</span> <span class="co">// 3</span></code></pre></div>
<p>Whoa! <code>bar</code> is hard-bound against <code>obj1</code>, but <code>new bar(3)</code> did <strong>not</strong> change <code>obj1.a</code> to be <code>3</code> as we would have expected. Instead, the <em>hard bound</em> (to <code>obj1</code>) call to <code>bar(..)</code> <strong><em>is</em></strong> able to be overridden with <code>new</code>. Since <code>new</code> was applied, we got the newly created object back, which we named <code>baz</code>, and we see in fact that <code>baz.a</code> has the value <code>3</code>.</p>
<p>This should be surprising if you go back to our &quot;fake&quot; bind helper:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">bind</span>(fn<span class="op">,</span> obj) <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="va">fn</span>.<span class="at">apply</span>( obj<span class="op">,</span> arguments )<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p>If you reason about how the helper's code works, it does not have a way for a <code>new</code> operator call to override the hard-binding to <code>obj</code> as we just observed.</p>
<p>But the built-in <code>Function.prototype.bind(..)</code> as of ES5 is more sophisticated, quite a bit so in fact. Here is the (slightly reformatted) polyfill provided by the MDN page for <code>bind(..)</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">bind</span>) <span class="op">{</span>
    <span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">bind</span> <span class="op">=</span> <span class="kw">function</span>(oThis) <span class="op">{</span>
        <span class="cf">if</span> (<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!==</span> <span class="st">&quot;function&quot;</span>) <span class="op">{</span>
            <span class="co">// closest thing possible to the ECMAScript 5</span>
            <span class="co">// internal IsCallable function</span>
            <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>( <span class="st">&quot;Function.prototype.bind - what &quot;</span> <span class="op">+</span>
                <span class="st">&quot;is trying to be bound is not callable&quot;</span>
            )<span class="op">;</span>
        <span class="op">}</span>

        <span class="kw">var</span> aArgs <span class="op">=</span> <span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">slice</span>.<span class="at">call</span>( arguments<span class="op">,</span> <span class="dv">1</span> )<span class="op">,</span>
            fToBind <span class="op">=</span> <span class="kw">this</span><span class="op">,</span>
            fNOP <span class="op">=</span> <span class="kw">function</span>()<span class="op">{},</span>
            fBound <span class="op">=</span> <span class="kw">function</span>()<span class="op">{</span>
                <span class="cf">return</span> <span class="va">fToBind</span>.<span class="at">apply</span>(
                    (
                        <span class="kw">this</span> <span class="kw">instanceof</span> fNOP <span class="op">&amp;&amp;</span>
                        oThis <span class="op">?</span> <span class="kw">this</span> : oThis
                    )<span class="op">,</span>
                    <span class="va">aArgs</span>.<span class="at">concat</span>( <span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">slice</span>.<span class="at">call</span>( arguments ) )
                )<span class="op">;</span>
            <span class="op">}</span>
        <span class="op">;</span>

        <span class="va">fNOP</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">this</span>.<span class="at">prototype</span><span class="op">;</span>
        <span class="va">fBound</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">fNOP</span>()<span class="op">;</span>

        <span class="cf">return</span> fBound<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p><strong>Note:</strong> The <code>bind(..)</code> polyfill shown above differs from the built-in <code>bind(..)</code> in ES5 with respect to hard-bound functions that will be used with <code>new</code> (see below for why that's useful). Because the polyfill cannot create a function without a <code>.prototype</code> as the built-in utility does, there's some nuanced indirection to approximate the same behavior. Tread carefully if you plan to use <code>new</code> with a hard-bound function and you rely on this polyfill.</p>
<p>The part that's allowing <code>new</code> overriding is:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">this</span> <span class="kw">instanceof</span> fNOP <span class="op">&amp;&amp;</span>
oThis <span class="op">?</span> <span class="kw">this</span> : oThis

<span class="co">// ... and:</span>

<span class="va">fNOP</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">this</span>.<span class="at">prototype</span><span class="op">;</span>
<span class="va">fBound</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">fNOP</span>()<span class="op">;</span></code></pre></div>
<p>We won't actually dive into explaining how this trickery works (it's complicated and beyond our scope here), but essentially the utility determines whether or not the hard-bound function has been called with <code>new</code> (resulting in a newly constructed object being its <code>this</code>), and if so, it uses <em>that</em> newly created <code>this</code> rather than the previously specified <em>hard binding</em> for <code>this</code>.</p>
<p>Why is <code>new</code> being able to override <em>hard binding</em> useful?</p>
<p>The primary reason for this behavior is to create a function (that can be used with <code>new</code> for constructing objects) that essentially ignores the <code>this</code> <em>hard binding</em> but which presets some or all of the function's arguments. One of the capabilities of <code>bind(..)</code> is that any arguments passed after the first <code>this</code> binding argument are defaulted as standard arguments to the underlying function (technically called &quot;partial application&quot;, which is a subset of &quot;currying&quot;).</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(p1<span class="op">,</span>p2) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">val</span> <span class="op">=</span> p1 <span class="op">+</span> p2<span class="op">;</span>
<span class="op">}</span>

<span class="co">// using `null` here because we don&#39;t care about</span>
<span class="co">// the `this` hard-binding in this scenario, and</span>
<span class="co">// it will be overridden by the `new` call anyway!</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">bind</span>( <span class="kw">null</span><span class="op">,</span> <span class="st">&quot;p1&quot;</span> )<span class="op">;</span>

<span class="kw">var</span> baz <span class="op">=</span> <span class="kw">new</span> <span class="at">bar</span>( <span class="st">&quot;p2&quot;</span> )<span class="op">;</span>

<span class="va">baz</span>.<span class="at">val</span><span class="op">;</span> <span class="co">// p1p2</span></code></pre></div>
<h3 id="determining-this">Determining <code>this</code></h3>
<p>Now, we can summarize the rules for determining <code>this</code> from a function call's call-site, in their order of precedence. Ask these questions in this order, and stop when the first rule applies.</p>
<ol type="1">
<li><p>Is the function called with <code>new</code> (<strong>new binding</strong>)? If so, <code>this</code> is the newly constructed object.</p>
<p><code>var bar = new foo()</code></p></li>
<li><p>Is the function called with <code>call</code> or <code>apply</code> (<strong>explicit binding</strong>), even hidden inside a <code>bind</code> <em>hard binding</em>? If so, <code>this</code> is the explicitly specified object.</p>
<p><code>var bar = foo.call( obj2 )</code></p></li>
<li><p>Is the function called with a context (<strong>implicit binding</strong>), otherwise known as an owning or containing object? If so, <code>this</code> is <em>that</em> context object.</p>
<p><code>var bar = obj1.foo()</code></p></li>
<li><p>Otherwise, default the <code>this</code> (<strong>default binding</strong>). If in <code>strict mode</code>, pick <code>undefined</code>, otherwise pick the <code>global</code> object.</p>
<p><code>var bar = foo()</code></p></li>
</ol>
<p>That's it. That's <em>all it takes</em> to understand the rules of <code>this</code> binding for normal function calls. Well... almost.</p>
<h2 id="binding-exceptions">Binding Exceptions</h2>
<p>As usual, there are some <em>exceptions</em> to the &quot;rules&quot;.</p>
<p>The <code>this</code>-binding behavior can in some scenarios be surprising, where you intended a different binding but you end up with binding behavior from the <em>default binding</em> rule (see previous).</p>
<h3 id="ignored-this">Ignored <code>this</code></h3>
<p>If you pass <code>null</code> or <code>undefined</code> as a <code>this</code> binding parameter to <code>call</code>, <code>apply</code>, or <code>bind</code>, those values are effectively ignored, and instead the <em>default binding</em> rule applies to the invocation.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>

<span class="va">foo</span>.<span class="at">call</span>( <span class="kw">null</span> )<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>Why would you intentionally pass something like <code>null</code> for a <code>this</code> binding?</p>
<p>It's quite common to use <code>apply(..)</code> for spreading out arrays of values as parameters to a function call. Similarly, <code>bind(..)</code> can curry parameters (pre-set values), which can be very helpful.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a<span class="op">,</span>b) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;a:&quot;</span> <span class="op">+</span> a <span class="op">+</span> <span class="st">&quot;, b:&quot;</span> <span class="op">+</span> b )<span class="op">;</span>
<span class="op">}</span>

<span class="co">// spreading out array as parameters</span>
<span class="va">foo</span>.<span class="at">apply</span>( <span class="kw">null</span><span class="op">,</span> [<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] )<span class="op">;</span> <span class="co">// a:2, b:3</span>

<span class="co">// currying with `bind(..)`</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">bind</span>( <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span> )<span class="op">;</span>
<span class="at">bar</span>( <span class="dv">3</span> )<span class="op">;</span> <span class="co">// a:2, b:3</span></code></pre></div>
<p>Both these utilities require a <code>this</code> binding for the first parameter. If the functions in question don't care about <code>this</code>, you need a placeholder value, and <code>null</code> might seem like a reasonable choice as shown in this snippet.</p>
<p><strong>Note:</strong> We don't cover it in this book, but ES6 has the <code>...</code> spread operator which will let you syntactically &quot;spread out&quot; an array as parameters without needing <code>apply(..)</code>, such as <code>foo(...[1,2])</code>, which amounts to <code>foo(1,2)</code> -- syntactically avoiding a <code>this</code> binding if it's unnecessary. Unfortunately, there's no ES6 syntactic substitute for currying, so the <code>this</code> parameter of the <code>bind(..)</code> call still needs attention.</p>
<p>However, there's a slight hidden &quot;danger&quot; in always using <code>null</code> when you don't care about the <code>this</code> binding. If you ever use that against a function call (for instance, a third-party library function that you don't control), and that function <em>does</em> make a <code>this</code> reference, the <em>default binding</em> rule means it might inadvertently reference (or worse, mutate!) the <code>global</code> object (<code>window</code> in the browser).</p>
<p>Obviously, such a pitfall can lead to a variety of <em>very difficult</em> to diagnose/track-down bugs.</p>
<h4 id="safer-this">Safer <code>this</code></h4>
<p>Perhaps a somewhat &quot;safer&quot; practice is to pass a specifically set up object for <code>this</code> which is guaranteed not to be an object that can create problematic side effects in your program. Borrowing terminology from networking (and the military), we can create a &quot;DMZ&quot; (de-militarized zone) object -- nothing more special than a completely empty, non-delegated (see Chapters 5 and 6) object.</p>
<p>If we always pass a DMZ object for ignored <code>this</code> bindings we don't think we need to care about, we're sure any hidden/unexpected usage of <code>this</code> will be restricted to the empty object, which insulates our program's <code>global</code> object from side-effects.</p>
<p>Since this object is totally empty, I personally like to give it the variable name <code>ø</code> (the lowercase mathematical symbol for the empty set). On many keyboards (like US-layout on Mac), this symbol is easily typed with <code>⌥</code>+<code>o</code> (option+<code>o</code>). Some systems also let you set up hotkeys for specific symbols. If you don't like the <code>ø</code> symbol, or your keyboard doesn't make that as easy to type, you can of course call it whatever you want.</p>
<p>Whatever you call it, the easiest way to set it up as <strong>totally empty</strong> is <code>Object.create(null)</code> (see Chapter 5). <code>Object.create(null)</code> is similar to <code>{ }</code>, but without the delegation to <code>Object.prototype</code>, so it's &quot;more empty&quot; than just <code>{ }</code>.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a<span class="op">,</span>b) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;a:&quot;</span> <span class="op">+</span> a <span class="op">+</span> <span class="st">&quot;, b:&quot;</span> <span class="op">+</span> b )<span class="op">;</span>
<span class="op">}</span>

<span class="co">// our DMZ empty object</span>
<span class="kw">var</span> ø <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( <span class="kw">null</span> )<span class="op">;</span>

<span class="co">// spreading out array as parameters</span>
<span class="va">foo</span>.<span class="at">apply</span>( ø<span class="op">,</span> [<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] )<span class="op">;</span> <span class="co">// a:2, b:3</span>

<span class="co">// currying with `bind(..)`</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">bind</span>( ø<span class="op">,</span> <span class="dv">2</span> )<span class="op">;</span>
<span class="at">bar</span>( <span class="dv">3</span> )<span class="op">;</span> <span class="co">// a:2, b:3</span></code></pre></div>
<p>Not only functionally &quot;safer&quot;, there's a sort of stylistic benefit to <code>ø</code>, in that it semantically conveys &quot;I want the <code>this</code> to be empty&quot; a little more clearly than <code>null</code> might. But again, name your DMZ object whatever you prefer.</p>
<h3 id="indirection">Indirection</h3>
<p>Another thing to be aware of is you can (intentionally or not!) create &quot;indirect references&quot; to functions, and in those cases, when that function reference is invoked, the <em>default binding</em> rule also applies.</p>
<p>One of the most common ways that <em>indirect references</em> occur is from an assignment:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
<span class="kw">var</span> o <span class="op">=</span> <span class="op">{</span> <span class="dt">a</span><span class="op">:</span> <span class="dv">3</span><span class="op">,</span> <span class="dt">foo</span><span class="op">:</span> foo <span class="op">};</span>
<span class="kw">var</span> p <span class="op">=</span> <span class="op">{</span> <span class="dt">a</span><span class="op">:</span> <span class="dv">4</span> <span class="op">};</span>

<span class="va">o</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// 3</span>
(<span class="va">p</span>.<span class="at">foo</span> <span class="op">=</span> <span class="va">o</span>.<span class="at">foo</span>)()<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>The <em>result value</em> of the assignment expression <code>p.foo = o.foo</code> is a reference to just the underlying function object. As such, the effective call-site is just <code>foo()</code>, not <code>p.foo()</code> or <code>o.foo()</code> as you might expect. Per the rules above, the <em>default binding</em> rule applies.</p>
<p>Reminder: regardless of how you get to a function invocation using the <em>default binding</em> rule, the <code>strict mode</code> status of the <strong>contents</strong> of the invoked function making the <code>this</code> reference -- not the function call-site -- determines the <em>default binding</em> value: either the <code>global</code> object if in non-<code>strict mode</code> or <code>undefined</code> if in <code>strict mode</code>.</p>
<h3 id="softening-binding">Softening Binding</h3>
<p>We saw earlier that <em>hard binding</em> was one strategy for preventing a function call falling back to the <em>default binding</em> rule inadvertently, by forcing it to be bound to a specific <code>this</code> (unless you use <code>new</code> to override it!). The problem is, <em>hard-binding</em> greatly reduces the flexibility of a function, preventing manual <code>this</code> override with either the <em>implicit binding</em> or even subsequent <em>explicit binding</em> attempts.</p>
<p>It would be nice if there was a way to provide a different default for <em>default binding</em> (not <code>global</code> or <code>undefined</code>), while still leaving the function able to be manually <code>this</code> bound via <em>implicit binding</em> or <em>explicit binding</em> techniques.</p>
<p>We can construct a so-called <em>soft binding</em> utility which emulates our desired behavior.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">softBind</span>) <span class="op">{</span>
    <span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">softBind</span> <span class="op">=</span> <span class="kw">function</span>(obj) <span class="op">{</span>
        <span class="kw">var</span> fn <span class="op">=</span> <span class="kw">this</span><span class="op">,</span>
            curried <span class="op">=</span> [].<span class="va">slice</span>.<span class="at">call</span>( arguments<span class="op">,</span> <span class="dv">1</span> )<span class="op">,</span>
            bound <span class="op">=</span> <span class="kw">function</span> <span class="at">bound</span>() <span class="op">{</span>
                <span class="cf">return</span> <span class="va">fn</span>.<span class="at">apply</span>(
                    (<span class="op">!</span><span class="kw">this</span> <span class="op">||</span>
                        (<span class="kw">typeof</span> window <span class="op">!==</span> <span class="st">&quot;undefined&quot;</span> <span class="op">&amp;&amp;</span>
                            <span class="kw">this</span> <span class="op">===</span> window) <span class="op">||</span>
                        (<span class="kw">typeof</span> global <span class="op">!==</span> <span class="st">&quot;undefined&quot;</span> <span class="op">&amp;&amp;</span>
                            <span class="kw">this</span> <span class="op">===</span> global)
                    ) <span class="op">?</span> obj : <span class="kw">this</span><span class="op">,</span>
                    <span class="va">curried</span>.<span class="va">concat</span>.<span class="at">apply</span>( curried<span class="op">,</span> arguments )
                )<span class="op">;</span>
            <span class="op">};</span>
        <span class="va">bound</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( <span class="va">fn</span>.<span class="at">prototype</span> )<span class="op">;</span>
        <span class="cf">return</span> bound<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p>The <code>softBind(..)</code> utility provided here works similarly to the built-in ES5 <code>bind(..)</code> utility, except with our <em>soft binding</em> behavior. It wraps the specified function in logic that checks the <code>this</code> at call-time and if it's <code>global</code> or <code>undefined</code>, uses a pre-specified alternate <em>default</em> (<code>obj</code>). Otherwise the <code>this</code> is left untouched. It also provides optional currying (see the <code>bind(..)</code> discussion earlier).</p>
<p>Let's demonstrate its usage:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
   <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;name: &quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">name</span>)<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span> <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;obj&quot;</span> <span class="op">},</span>
    obj2 <span class="op">=</span> <span class="op">{</span> <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;obj2&quot;</span> <span class="op">},</span>
    obj3 <span class="op">=</span> <span class="op">{</span> <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;obj3&quot;</span> <span class="op">};</span>

<span class="kw">var</span> fooOBJ <span class="op">=</span> <span class="va">foo</span>.<span class="at">softBind</span>( obj )<span class="op">;</span>

<span class="at">fooOBJ</span>()<span class="op">;</span> <span class="co">// name: obj</span>

<span class="va">obj2</span>.<span class="at">foo</span> <span class="op">=</span> <span class="va">foo</span>.<span class="at">softBind</span>(obj)<span class="op">;</span>
<span class="va">obj2</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// name: obj2   &lt;---- look!!!</span>

<span class="va">fooOBJ</span>.<span class="at">call</span>( obj3 )<span class="op">;</span> <span class="co">// name: obj3   &lt;---- look!</span>

<span class="at">setTimeout</span>( <span class="va">obj2</span>.<span class="at">foo</span><span class="op">,</span> <span class="dv">10</span> )<span class="op">;</span> <span class="co">// name: obj   &lt;---- falls back to soft-binding</span></code></pre></div>
<p>The soft-bound version of the <code>foo()</code> function can be manually <code>this</code>-bound to <code>obj2</code> or <code>obj3</code> as shown, but it falls back to <code>obj</code> if the <em>default binding</em> would otherwise apply.</p>
<h2 id="lexical-this">Lexical <code>this</code></h2>
<p>Normal functions abide by the 4 rules we just covered. But ES6 introduces a special kind of function that does not use these rules: arrow-function.</p>
<p>Arrow-functions are signified not by the <code>function</code> keyword, but by the <code>=&gt;</code> so called &quot;fat arrow&quot; operator. Instead of using the four standard <code>this</code> rules, arrow-functions adopt the <code>this</code> binding from the enclosing (function or global) scope.</p>
<p>Let's illustrate arrow-function lexical scope:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="co">// return an arrow function</span>
    <span class="cf">return</span> (a) <span class="op">=&gt;</span> <span class="op">{</span>
        <span class="co">// `this` here is lexically adopted from `foo()`</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span>

<span class="kw">var</span> obj1 <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="kw">var</span> obj2 <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">3</span>
<span class="op">};</span>

<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">call</span>( obj1 )<span class="op">;</span>
<span class="va">bar</span>.<span class="at">call</span>( obj2 )<span class="op">;</span> <span class="co">// 2, not 3!</span></code></pre></div>
<p>The arrow-function created in <code>foo()</code> lexically captures whatever <code>foo()</code>s <code>this</code> is at its call-time. Since <code>foo()</code> was <code>this</code>-bound to <code>obj1</code>, <code>bar</code> (a reference to the returned arrow-function) will also be <code>this</code>-bound to <code>obj1</code>. The lexical binding of an arrow-function cannot be overridden (even with <code>new</code>!).</p>
<p>The most common use-case will likely be in the use of callbacks, such as event handlers or timers:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="at">setTimeout</span>(() <span class="op">=&gt;</span> <span class="op">{</span>
        <span class="co">// `this` here is lexically adopted from `foo()`</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
    <span class="op">},</span><span class="dv">100</span>)<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">foo</span>.<span class="at">call</span>( obj )<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>While arrow-functions provide an alternative to using <code>bind(..)</code> on a function to ensure its <code>this</code>, which can seem attractive, it's important to note that they essentially are disabling the traditional <code>this</code> mechanism in favor of more widely-understood lexical scoping. Pre-ES6, we already have a fairly common pattern for doing so, which is basically almost indistinguishable from the spirit of ES6 arrow-functions:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="kw">var</span> self <span class="op">=</span> <span class="kw">this</span><span class="op">;</span> <span class="co">// lexical capture of `this`</span>
    <span class="at">setTimeout</span>( <span class="kw">function</span>()<span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="va">self</span>.<span class="at">a</span> )<span class="op">;</span>
    <span class="op">},</span> <span class="dv">100</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">foo</span>.<span class="at">call</span>( obj )<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>While <code>self = this</code> and arrow-functions both seem like good &quot;solutions&quot; to not wanting to use <code>bind(..)</code>, they are essentially fleeing from <code>this</code> instead of understanding and embracing it.</p>
<p>If you find yourself writing <code>this</code>-style code, but most or all the time, you defeat the <code>this</code> mechanism with lexical <code>self = this</code> or arrow-function &quot;tricks&quot;, perhaps you should either:</p>
<ol type="1">
<li><p>Use only lexical scope and forget the false pretense of <code>this</code>-style code.</p></li>
<li><p>Embrace <code>this</code>-style mechanisms completely, including using <code>bind(..)</code> where necessary, and try to avoid <code>self = this</code> and arrow-function &quot;lexical this&quot; tricks.</p></li>
</ol>
<p>A program can effectively use both styles of code (lexical and <code>this</code>), but inside of the same function, and indeed for the same sorts of look-ups, mixing the two mechanisms is usually asking for harder-to-maintain code, and probably working too hard to be clever.</p>
<h2 id="review-tldr-1">Review (TL;DR)</h2>
<p>Determining the <code>this</code> binding for an executing function requires finding the direct call-site of that function. Once examined, four rules can be applied to the call-site, in <em>this</em> order of precedence:</p>
<ol type="1">
<li><p>Called with <code>new</code>? Use the newly constructed object.</p></li>
<li><p>Called with <code>call</code> or <code>apply</code> (or <code>bind</code>)? Use the specified object.</p></li>
<li><p>Called with a context object owning the call? Use that context object.</p></li>
<li><p>Default: <code>undefined</code> in <code>strict mode</code>, global object otherwise.</p></li>
</ol>
<p>Be careful of accidental/unintentional invoking of the <em>default binding</em> rule. In cases where you want to &quot;safely&quot; ignore a <code>this</code> binding, a &quot;DMZ&quot; object like <code>ø = Object.create(null)</code> is a good placeholder value that protects the <code>global</code> object from unintended side-effects.</p>
<p>Instead of the four standard binding rules, ES6 arrow-functions use lexical scoping for <code>this</code> binding, which means they adopt the <code>this</code> binding (whatever it is) from its enclosing function call. They are essentially a syntactic replacement of <code>self = this</code> in pre-ES6 coding.</p>
<h1 id="you-dont-know-js-this-object-prototypes-2">You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>
<h1 id="chapter-3-objects">Chapter 3: Objects</h1>
<p>In Chapters 1 and 2, we explained how the <code>this</code> binding points to various objects depending on the call-site of the function invocation. But what exactly are objects, and why do we need to point to them? We will explore objects in detail in this chapter.</p>
<h2 id="syntax">Syntax</h2>
<p>Objects come in two forms: the declarative (literal) form, and the constructed form.</p>
<p>The literal syntax for an object looks like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">key</span><span class="op">:</span> value
    <span class="co">// ...</span>
<span class="op">};</span></code></pre></div>
<p>The constructed form looks like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObj <span class="op">=</span> <span class="kw">new</span> <span class="at">Object</span>()<span class="op">;</span>
<span class="va">myObj</span>.<span class="at">key</span> <span class="op">=</span> value<span class="op">;</span></code></pre></div>
<p>The constructed form and the literal form result in exactly the same sort of object. The only difference really is that you can add one or more key/value pairs to the literal declaration, whereas with constructed-form objects, you must add the properties one-by-one.</p>
<p><strong>Note:</strong> It's extremely uncommon to use the &quot;constructed form&quot; for creating objects as just shown. You would pretty much always want to use the literal syntax form. The same will be true of most of the built-in objects (see below).</p>
<h2 id="type">Type</h2>
<p>Objects are the general building block upon which much of JS is built. They are one of the 6 primary types (called &quot;language types&quot; in the specification) in JS:</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>object</code></li>
</ul>
<p>Note that the <em>simple primitives</em> (<code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, and <code>undefined</code>) are <strong>not</strong> themselves <code>objects</code>. <code>null</code> is sometimes referred to as an object type, but this misconception stems from a bug in the language which causes <code>typeof null</code> to return the string <code>&quot;object&quot;</code> incorrectly (and confusingly). In fact, <code>null</code> is its own primitive type.</p>
<p><strong>It's a common mis-statement that &quot;everything in JavaScript is an object&quot;. This is clearly not true.</strong></p>
<p>By contrast, there <em>are</em> a few special object sub-types, which we can refer to as <em>complex primitives</em>.</p>
<p><code>function</code> is a sub-type of object (technically, a &quot;callable object&quot;). Functions in JS are said to be &quot;first class&quot; in that they are basically just normal objects (with callable behavior semantics bolted on), and so they can be handled like any other plain object.</p>
<p>Arrays are also a form of objects, with extra behavior. The organization of contents in arrays is slightly more structured than for general objects.</p>
<h3 id="built-in-objects">Built-in Objects</h3>
<p>There are several other object sub-types, usually referred to as built-in objects. For some of them, their names seem to imply they are directly related to their simple primitives counter-parts, but in fact, their relationship is more complicated, which we'll explore shortly.</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Object</code></li>
<li><code>Function</code></li>
<li><code>Array</code></li>
<li><code>Date</code></li>
<li><code>RegExp</code></li>
<li><code>Error</code></li>
</ul>
<p>These built-ins have the appearance of being actual types, even classes, if you rely on the similarity to other languages such as Java's <code>String</code> class.</p>
<p>But in JS, these are actually just built-in functions. Each of these built-in functions can be used as a constructor (that is, a function call with the <code>new</code> operator -- see Chapter 2), with the result being a newly <em>constructed</em> object of the sub-type in question. For instance:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> strPrimitive <span class="op">=</span> <span class="st">&quot;I am a string&quot;</span><span class="op">;</span>
<span class="kw">typeof</span> strPrimitive<span class="op">;</span>                            <span class="co">// &quot;string&quot;</span>
strPrimitive <span class="kw">instanceof</span> String<span class="op">;</span>                 <span class="co">// false</span>

<span class="kw">var</span> strObject <span class="op">=</span> <span class="kw">new</span> <span class="at">String</span>( <span class="st">&quot;I am a string&quot;</span> )<span class="op">;</span>
<span class="kw">typeof</span> strObject<span class="op">;</span>                               <span class="co">// &quot;object&quot;</span>
strObject <span class="kw">instanceof</span> String<span class="op">;</span>                    <span class="co">// true</span>

<span class="co">// inspect the object sub-type</span>
<span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( strObject )<span class="op">;</span>    <span class="co">// [object String]</span></code></pre></div>
<p>We'll see in detail in a later chapter exactly how the <code>Object.prototype.toString...</code> bit works, but briefly, we can inspect the internal sub-type by borrowing the base default <code>toString()</code> method, and you can see it reveals that <code>strObject</code> is an object that was in fact created by the <code>String</code> constructor.</p>
<p>The primitive value <code>&quot;I am a string&quot;</code> is not an object, it's a primitive literal and immutable value. To perform operations on it, such as checking its length, accessing its individual character contents, etc, a <code>String</code> object is required.</p>
<p>Luckily, the language automatically coerces a <code>&quot;string&quot;</code> primitive to a <code>String</code> object when necessary, which means you almost never need to explicitly create the Object form. It is <strong>strongly preferred</strong> by the majority of the JS community to use the literal form for a value, where possible, rather than the constructed object form.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> strPrimitive <span class="op">=</span> <span class="st">&quot;I am a string&quot;</span><span class="op">;</span>

<span class="va">console</span>.<span class="at">log</span>( <span class="va">strPrimitive</span>.<span class="at">length</span> )<span class="op">;</span>         <span class="co">// 13</span>

<span class="va">console</span>.<span class="at">log</span>( <span class="va">strPrimitive</span>.<span class="at">charAt</span>( <span class="dv">3</span> ) )<span class="op">;</span>    <span class="co">// &quot;m&quot;</span></code></pre></div>
<p>In both cases, we call a property or method on a string primitive, and the engine automatically coerces it to a <code>String</code> object, so that the property/method access works.</p>
<p>The same sort of coercion happens between the number literal primitive <code>42</code> and the <code>new Number(42)</code> object wrapper, when using methods like <code>42.359.toFixed(2)</code>. Likewise for <code>Boolean</code> objects from <code>&quot;boolean&quot;</code> primitives.</p>
<p><code>null</code> and <code>undefined</code> have no object wrapper form, only their primitive values. By contrast, <code>Date</code> values can <em>only</em> be created with their constructed object form, as they have no literal form counter-part.</p>
<p><code>Object</code>s, <code>Array</code>s, <code>Function</code>s, and <code>RegExp</code>s (regular expressions) are all objects regardless of whether the literal or constructed form is used. The constructed form does offer, in some cases, more options in creation than the literal form counterpart. Since objects are created either way, the simpler literal form is almost universally preferred. <strong>Only use the constructed form if you need the extra options.</strong></p>
<p><code>Error</code> objects are rarely created explicitly in code, but usually created automatically when exceptions are thrown. They can be created with the constructed form <code>new Error(..)</code>, but it's often unnecessary.</p>
<h2 id="contents">Contents</h2>
<p>As mentioned earlier, the contents of an object consist of values (any type) stored at specifically named <em>locations</em>, which we call properties.</p>
<p>It's important to note that while we say &quot;contents&quot; which implies that these values are <em>actually</em> stored inside the object, that's merely an appearance. The engine stores values in implementation-dependent ways, and may very well not store them <em>in</em> some object container. What <em>is</em> stored in the container are these property names, which act as pointers (technically, <em>references</em>) to where the values are stored.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span>     <span class="co">// 2</span>

myObject[<span class="st">&quot;a&quot;</span>]<span class="op">;</span>  <span class="co">// 2</span></code></pre></div>
<p>To access the value at the <em>location</em> <code>a</code> in <code>myObject</code>, we need to use either the <code>.</code> operator or the <code>[ ]</code> operator. The <code>.a</code> syntax is usually referred to as &quot;property&quot; access, whereas the <code>[&quot;a&quot;]</code> syntax is usually referred to as &quot;key&quot; access. In reality, they both access the same <em>location</em>, and will pull out the same value, <code>2</code>, so the terms can be used interchangeably. We will use the most common term, &quot;property access&quot; from here on.</p>
<p>The main difference between the two syntaxes is that the <code>.</code> operator requires an <code>Identifier</code> compatible property name after it, whereas the <code>[&quot;..&quot;]</code> syntax can take basically any UTF-8/unicode compatible string as the name for the property. To reference a property of the name &quot;Super-Fun!&quot;, for instance, you would have to use the <code>[&quot;Super-Fun!&quot;]</code> access syntax, as <code>Super-Fun!</code> is not a valid <code>Identifier</code> property name.</p>
<p>Also, since the <code>[&quot;..&quot;]</code> syntax uses a string's <strong>value</strong> to specify the location, this means the program can programmatically build up the value of the string, such as:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> wantA <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
<span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="kw">var</span> idx<span class="op">;</span>

<span class="cf">if</span> (wantA) <span class="op">{</span>
    idx <span class="op">=</span> <span class="st">&quot;a&quot;</span><span class="op">;</span>
<span class="op">}</span>

<span class="co">// later</span>

<span class="va">console</span>.<span class="at">log</span>( myObject[idx] )<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>In objects, property names are <strong>always</strong> strings. If you use any other value besides a <code>string</code> (primitive) as the property, it will first be converted to a string. This even includes numbers, which are commonly used as array indexes, so be careful not to confuse the use of numbers between objects and arrays.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span> <span class="op">};</span>

myObject[<span class="kw">true</span>] <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>
myObject[<span class="dv">3</span>] <span class="op">=</span> <span class="st">&quot;bar&quot;</span><span class="op">;</span>
myObject[myObject] <span class="op">=</span> <span class="st">&quot;baz&quot;</span><span class="op">;</span>

myObject[<span class="st">&quot;true&quot;</span>]<span class="op">;</span>               <span class="co">// &quot;foo&quot;</span>
myObject[<span class="st">&quot;3&quot;</span>]<span class="op">;</span>                  <span class="co">// &quot;bar&quot;</span>
myObject[<span class="st">&quot;[object Object]&quot;</span>]<span class="op">;</span>    <span class="co">// &quot;baz&quot;</span></code></pre></div>
<h3 id="computed-property-names">Computed Property Names</h3>
<p>The <code>myObject[..]</code> property access syntax we just described is useful if you need to use a computed expression value <em>as</em> the key name, like <code>myObject[prefix + name]</code>. But that's not really helpful when declaring objects using the object-literal syntax.</p>
<p>ES6 adds <em>computed property names</em>, where you can specify an expression, surrounded by a <code>[ ]</code> pair, in the key-name position of an object-literal declaration:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> prefix <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>

<span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    [prefix <span class="op">+</span> <span class="st">&quot;bar&quot;</span>]<span class="op">:</span> <span class="st">&quot;hello&quot;</span><span class="op">,</span>
    [prefix <span class="op">+</span> <span class="st">&quot;baz&quot;</span>]<span class="op">:</span> <span class="st">&quot;world&quot;</span>
<span class="op">};</span>

myObject[<span class="st">&quot;foobar&quot;</span>]<span class="op">;</span> <span class="co">// hello</span>
myObject[<span class="st">&quot;foobaz&quot;</span>]<span class="op">;</span> <span class="co">// world</span></code></pre></div>
<p>The most common usage of <em>computed property names</em> will probably be for ES6 <code>Symbol</code>s, which we will not be covering in detail in this book. In short, they're a new primitive data type which has an opaque unguessable value (technically a <code>string</code> value). You will be strongly discouraged from working with the <em>actual value</em> of a <code>Symbol</code> (which can theoretically be different between different JS engines), so the name of the <code>Symbol</code>, like <code>Symbol.Something</code> (just a made up name!), will be what you use:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    [<span class="va">Symbol</span>.<span class="at">Something</span>]<span class="op">:</span> <span class="st">&quot;hello world&quot;</span>
<span class="op">};</span></code></pre></div>
<h3 id="property-vs.-method">Property vs. Method</h3>
<p>Some developers like to make a distinction when talking about a property access on an object, if the value being accessed happens to be a function. Because it's tempting to think of the function as <em>belonging</em> to the object, and in other languages, functions which belong to objects (aka, &quot;classes&quot;) are referred to as &quot;methods&quot;, it's not uncommon to hear, &quot;method access&quot; as opposed to &quot;property access&quot;.</p>
<p><strong>The specification makes this same distinction</strong>, interestingly.</p>
<p>Technically, functions never &quot;belong&quot; to objects, so saying that a function that just happens to be accessed on an object reference is automatically a &quot;method&quot; seems a bit of a stretch of semantics.</p>
<p>It <em>is</em> true that some functions have <code>this</code> references in them, and that <em>sometimes</em> these <code>this</code> references refer to the object reference at the call-site. But this usage really does not make that function any more a &quot;method&quot; than any other function, as <code>this</code> is dynamically bound at run-time, at the call-site, and thus its relationship to the object is indirect, at best.</p>
<p>Every time you access a property on an object, that is a <strong>property access</strong>, regardless of the type of value you get back. If you <em>happen</em> to get a function from that property access, it's not magically a &quot;method&quot; at that point. There's nothing special (outside of possible implicit <code>this</code> binding as explained earlier) about a function that comes from a property access.</p>
<p>For instance:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;foo&quot;</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> someFoo <span class="op">=</span> foo<span class="op">;</span>  <span class="co">// variable reference to `foo`</span>

<span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">someFoo</span><span class="op">:</span> foo
<span class="op">};</span>

foo<span class="op">;</span>                <span class="co">// function foo(){..}</span>

someFoo<span class="op">;</span>            <span class="co">// function foo(){..}</span>

<span class="va">myObject</span>.<span class="at">someFoo</span><span class="op">;</span>   <span class="co">// function foo(){..}</span></code></pre></div>
<p><code>someFoo</code> and <code>myObject.someFoo</code> are just two separate references to the same function, and neither implies anything about the function being special or &quot;owned&quot; by any other object. If <code>foo()</code> above was defined to have a <code>this</code> reference inside it, that <code>myObject.someFoo</code> <em>implicit binding</em> would be the <strong>only</strong> observable difference between the two references. Neither reference really makes sense to be called a &quot;method&quot;.</p>
<p><strong>Perhaps one could argue</strong> that a function <em>becomes a method</em>, not at definition time, but during run-time just for that invocation, depending on how it's called at its call-site (with an object reference context or not -- see Chapter 2 for more details). Even this interpretation is a bit of a stretch.</p>
<p>The safest conclusion is probably that &quot;function&quot; and &quot;method&quot; are interchangeable in JavaScript.</p>
<p><strong>Note:</strong> ES6 adds a <code>super</code> reference, which is typically going to be used with <code>class</code> (see Appendix A). The way <code>super</code> behaves (static binding rather than late binding as <code>this</code>) gives further weight to the idea that a function which is <code>super</code> bound somewhere is more a &quot;method&quot; than &quot;function&quot;. But again, these are just subtle semantic (and mechanical) nuances.</p>
<p>Even when you declare a function expression as part of the object-literal, that function doesn't magically <em>belong</em> more to the object -- still just multiple references to the same function object:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;foo&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> someFoo <span class="op">=</span> <span class="va">myObject</span>.<span class="at">foo</span><span class="op">;</span>

someFoo<span class="op">;</span>        <span class="co">// function foo(){..}</span>

<span class="va">myObject</span>.<span class="at">foo</span><span class="op">;</span>   <span class="co">// function foo(){..}</span></code></pre></div>
<p><strong>Note:</strong> In Chapter 6, we will cover an ES6 short-hand for that <code>foo: function foo(){ .. }</code> declaration syntax in our object-literal.</p>
<h3 id="arrays">Arrays</h3>
<p>Arrays also use the <code>[ ]</code> access form, but as mentioned above, they have slightly more structured organization for how and where values are stored (though still no restriction on what <em>type</em> of values are stored). Arrays assume <em>numeric indexing</em>, which means that values are stored in locations, usually called <em>indices</em>, at non-negative integers, such as <code>0</code> and <code>42</code>.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myArray <span class="op">=</span> [ <span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">,</span> <span class="st">&quot;bar&quot;</span> ]<span class="op">;</span>

<span class="va">myArray</span>.<span class="at">length</span><span class="op">;</span>     <span class="co">// 3</span>

myArray[<span class="dv">0</span>]<span class="op">;</span>         <span class="co">// &quot;foo&quot;</span>

myArray[<span class="dv">2</span>]<span class="op">;</span>         <span class="co">// &quot;bar&quot;</span></code></pre></div>
<p>Arrays <em>are</em> objects, so even though each index is a positive integer, you can <em>also</em> add properties onto the array:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myArray <span class="op">=</span> [ <span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">,</span> <span class="st">&quot;bar&quot;</span> ]<span class="op">;</span>

<span class="va">myArray</span>.<span class="at">baz</span> <span class="op">=</span> <span class="st">&quot;baz&quot;</span><span class="op">;</span>

<span class="va">myArray</span>.<span class="at">length</span><span class="op">;</span> <span class="co">// 3</span>

<span class="va">myArray</span>.<span class="at">baz</span><span class="op">;</span>    <span class="co">// &quot;baz&quot;</span></code></pre></div>
<p>Notice that adding named properties (regardless of <code>.</code> or <code>[ ]</code> operator syntax) does not change the reported <code>length</code> of the array.</p>
<p>You <em>could</em> use an array as a plain key/value object, and never add any numeric indices, but this is a bad idea because arrays have behavior and optimizations specific to their intended use, and likewise with plain objects. Use objects to store key/value pairs, and arrays to store values at numeric indices.</p>
<p><strong>Be careful:</strong> If you try to add a property to an array, but the property name <em>looks</em> like a number, it will end up instead as a numeric index (thus modifying the array contents):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myArray <span class="op">=</span> [ <span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">,</span> <span class="st">&quot;bar&quot;</span> ]<span class="op">;</span>

myArray[<span class="st">&quot;3&quot;</span>] <span class="op">=</span> <span class="st">&quot;baz&quot;</span><span class="op">;</span>

<span class="va">myArray</span>.<span class="at">length</span><span class="op">;</span> <span class="co">// 4</span>

myArray[<span class="dv">3</span>]<span class="op">;</span>     <span class="co">// &quot;baz&quot;</span></code></pre></div>
<h3 id="duplicating-objects">Duplicating Objects</h3>
<p>One of the most commonly requested features when developers newly take up the JavaScript language is how to duplicate an object. It would seem like there should just be a built-in <code>copy()</code> method, right? It turns out that it's a little more complicated than that, because it's not fully clear what, by default, should be the algorithm for the duplication.</p>
<p>For example, consider this object:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">anotherFunction</span>() <span class="op">{</span> <span class="co">/*..*/</span> <span class="op">}</span>

<span class="kw">var</span> anotherObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">c</span><span class="op">:</span> <span class="kw">true</span>
<span class="op">};</span>

<span class="kw">var</span> anotherArray <span class="op">=</span> []<span class="op">;</span>

<span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">b</span><span class="op">:</span> anotherObject<span class="op">,</span>   <span class="co">// reference, not a copy!</span>
    <span class="dt">c</span><span class="op">:</span> anotherArray<span class="op">,</span>    <span class="co">// another reference!</span>
    <span class="dt">d</span><span class="op">:</span> anotherFunction
<span class="op">};</span>

<span class="va">anotherArray</span>.<span class="at">push</span>( anotherObject<span class="op">,</span> myObject )<span class="op">;</span></code></pre></div>
<p>What exactly should be the representation of a <em>copy</em> of <code>myObject</code>?</p>
<p>Firstly, we should answer if it should be a <em>shallow</em> or <em>deep</em> copy. A <em>shallow copy</em> would end up with <code>a</code> on the new object as a copy of the value <code>2</code>, but <code>b</code>, <code>c</code>, and <code>d</code> properties as just references to the same places as the references in the original object. A <em>deep copy</em> would duplicate not only <code>myObject</code>, but <code>anotherObject</code> and <code>anotherArray</code>. But then we have issues that <code>anotherArray</code> has references to <code>anotherObject</code> and <code>myObject</code> in it, so <em>those</em> should also be duplicated rather than reference-preserved. Now we have an infinite circular duplication problem because of the circular reference.</p>
<p>Should we detect a circular reference and just break the circular traversal (leaving the deep element not fully duplicated)? Should we error out completely? Something in between?</p>
<p>Moreover, it's not really clear what &quot;duplicating&quot; a function would mean? There are some hacks like pulling out the <code>toString()</code> serialization of a function's source code (which varies across implementations and is not even reliable in all engines depending on the type of function being inspected).</p>
<p>So how do we resolve all these tricky questions? Various JS frameworks have each picked their own interpretations and made their own decisions. But which of these (if any) should JS adopt as <em>the</em> standard? For a long time, there was no clear answer.</p>
<p>One subset solution is that objects which are JSON-safe (that is, can be serialized to a JSON string and then re-parsed to an object with the same structure and values) can easily be <em>duplicated</em> with:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> newObj <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>( <span class="va">JSON</span>.<span class="at">stringify</span>( someObj ) )<span class="op">;</span></code></pre></div>
<p>Of course, that requires you to ensure your object is JSON safe. For some situations, that's trivial. For others, it's insufficient.</p>
<p>At the same time, a shallow copy is fairly understandable and has far less issues, so ES6 has now defined <code>Object.assign(..)</code> for this task. <code>Object.assign(..)</code> takes a <em>target</em> object as its first parameter, and one or more <em>source</em> objects as its subsequent parameters. It iterates over all the <em>enumerable</em> (see below), <em>owned keys</em> (<strong>immediately present</strong>) on the <em>source</em> object(s) and copies them (via <code>=</code> assignment only) to <em>target</em>. It also, helpfully, returns <em>target</em>, as you can see below:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> newObj <span class="op">=</span> <span class="va">Object</span>.<span class="at">assign</span>( <span class="op">{},</span> myObject )<span class="op">;</span>

<span class="va">newObj</span>.<span class="at">a</span><span class="op">;</span>                       <span class="co">// 2</span>
<span class="va">newObj</span>.<span class="at">b</span> <span class="op">===</span> anotherObject<span class="op">;</span>     <span class="co">// true</span>
<span class="va">newObj</span>.<span class="at">c</span> <span class="op">===</span> anotherArray<span class="op">;</span>      <span class="co">// true</span>
<span class="va">newObj</span>.<span class="at">d</span> <span class="op">===</span> anotherFunction<span class="op">;</span>   <span class="co">// true</span></code></pre></div>
<p><strong>Note:</strong> In the next section, we describe &quot;property descriptors&quot; (property characteristics) and show the use of <code>Object.defineProperty(..)</code>. The duplication that occurs for <code>Object.assign(..)</code> however is purely <code>=</code> style assignment, so any special characteristics of a property (like <code>writable</code>) on a source object <strong>are not preserved</strong> on the target object.</p>
<h3 id="property-descriptors">Property Descriptors</h3>
<p>Prior to ES5, the JavaScript language gave no direct way for your code to inspect or draw any distinction between the characteristics of properties, such as whether the property was read-only or not.</p>
<p>But as of ES5, all properties are described in terms of a <strong>property descriptor</strong>.</p>
<p>Consider this code:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">Object</span>.<span class="at">getOwnPropertyDescriptor</span>( myObject<span class="op">,</span> <span class="st">&quot;a&quot;</span> )<span class="op">;</span>
<span class="co">// {</span>
<span class="co">//    value: 2,</span>
<span class="co">//    writable: true,</span>
<span class="co">//    enumerable: true,</span>
<span class="co">//    configurable: true</span>
<span class="co">// }</span></code></pre></div>
<p>As you can see, the property descriptor (called a &quot;data descriptor&quot; since it's only for holding a data value) for our normal object property <code>a</code> is much more than just its <code>value</code> of <code>2</code>. It includes 3 other characteristics: <code>writable</code>, <code>enumerable</code>, and <code>configurable</code>.</p>
<p>While we can see what the default values for the property descriptor characteristics are when we create a normal property, we can use <code>Object.defineProperty(..)</code> to add a new property, or modify an existing one (if it's <code>configurable</code>!), with the desired characteristics.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{};</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>( myObject<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">value</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">writable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">configurable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">true</span>
<span class="op">}</span> )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>Using <code>defineProperty(..)</code>, we added the plain, normal <code>a</code> property to <code>myObject</code> in a manually explicit way. However, you generally wouldn't use this manual approach unless you wanted to modify one of the descriptor characteristics from its normal behavior.</p>
<h4 id="writable">Writable</h4>
<p>The ability for you to change the value of a property is controlled by <code>writable</code>.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{};</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>( myObject<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">value</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">writable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span> <span class="co">// not writable!</span>
    <span class="dt">configurable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">true</span>
<span class="op">}</span> )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>As you can see, our modification of the <code>value</code> silently failed. If we try in <code>strict mode</code>, we get an error:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&quot;use strict&quot;</span><span class="op">;</span>

<span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{};</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>( myObject<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">value</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">writable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span> <span class="co">// not writable!</span>
    <span class="dt">configurable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">true</span>
<span class="op">}</span> )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// TypeError</span></code></pre></div>
<p>The <code>TypeError</code> tells us we cannot change a non-writable property.</p>
<p><strong>Note:</strong> We will discuss getters/setters shortly, but briefly, you can observe that <code>writable:false</code> means a value cannot be changed, which is somewhat equivalent to if you defined a no-op setter. Actually, your no-op setter would need to throw a <code>TypeError</code> when called, to be truly conformant to <code>writable:false</code>.</p>
<h4 id="configurable">Configurable</h4>
<p>As long as a property is currently configurable, we can modify its descriptor definition, using the same <code>defineProperty(..)</code> utility.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">myObject</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>
<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span>                 <span class="co">// 3</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>( myObject<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">value</span><span class="op">:</span> <span class="dv">4</span><span class="op">,</span>
    <span class="dt">writable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">configurable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>    <span class="co">// not configurable!</span>
    <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">true</span>
<span class="op">}</span> )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span>                 <span class="co">// 4</span>
<span class="va">myObject</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>
<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span>                 <span class="co">// 5</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>( myObject<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">value</span><span class="op">:</span> <span class="dv">6</span><span class="op">,</span>
    <span class="dt">writable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">configurable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">true</span>
<span class="op">}</span> )<span class="op">;</span> <span class="co">// TypeError</span></code></pre></div>
<p>The final <code>defineProperty(..)</code> call results in a TypeError, regardless of <code>strict mode</code>, if you attempt to change the descriptor definition of a non-configurable property. Be careful: as you can see, changing <code>configurable</code> to <code>false</code> is a <strong>one-way action, and cannot be undone!</strong></p>
<p><strong>Note:</strong> There's a nuanced exception to be aware of: even if the property is already <code>configurable:false</code>, <code>writable</code> can always be changed from <code>true</code> to <code>false</code> without error, but not back to <code>true</code> if already <code>false</code>.</p>
<p>Another thing <code>configurable:false</code> prevents is the ability to use the <code>delete</code> operator to remove an existing property.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span>             <span class="co">// 2</span>
<span class="kw">delete</span> <span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span>
<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span>             <span class="co">// undefined</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>( myObject<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">value</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">writable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">configurable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
    <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">true</span>
<span class="op">}</span> )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span>             <span class="co">// 2</span>
<span class="kw">delete</span> <span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span>
<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span>             <span class="co">// 2</span></code></pre></div>
<p>As you can see, the last <code>delete</code> call failed (silently) because we made the <code>a</code> property non-configurable.</p>
<p><code>delete</code> is only used to remove object properties (which can be removed) directly from the object in question. If an object property is the last remaining <em>reference</em> to some object/function, and you <code>delete</code> it, that removes the reference and now that unreferenced object/function can be garbage collected. But, it is <strong>not</strong> proper to think of <code>delete</code> as a tool to free up allocated memory as it does in other languages (like C/C++). <code>delete</code> is just an object property removal operation -- nothing more.</p>
<h4 id="enumerable">Enumerable</h4>
<p>The final descriptor characteristic we will mention here (there are two others, which we deal with shortly when we discuss getter/setters) is <code>enumerable</code>.</p>
<p>The name probably makes it obvious, but this characteristic controls if a property will show up in certain object-property enumerations, such as the <code>for..in</code> loop. Set to <code>false</code> to keep it from showing up in such enumerations, even though it's still completely accessible. Set to <code>true</code> to keep it present.</p>
<p>All normal user-defined properties are defaulted to <code>enumerable</code>, as this is most commonly what you want. But if you have a special property you want to hide from enumeration, set it to <code>enumerable:false</code>.</p>
<p>We'll demonstrate enumerability in much more detail shortly, so keep a mental bookmark on this topic.</p>
<h3 id="immutability">Immutability</h3>
<p>It is sometimes desired to make properties or objects that cannot be changed (either by accident or intentionally). ES5 adds support for handling that in a variety of different nuanced ways.</p>
<p>It's important to note that <strong>all</strong> of these approaches create shallow immutability. That is, they affect only the object and its direct property characteristics. If an object has a reference to another object (array, object, function, etc), the <em>contents</em> of that object are not affected, and remain mutable.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">myImmutableObject</span>.<span class="at">foo</span><span class="op">;</span> <span class="co">// [1,2,3]</span>
<span class="va">myImmutableObject</span>.<span class="va">foo</span>.<span class="at">push</span>( <span class="dv">4</span> )<span class="op">;</span>
<span class="va">myImmutableObject</span>.<span class="at">foo</span><span class="op">;</span> <span class="co">// [1,2,3,4]</span></code></pre></div>
<p>We assume in this snippet that <code>myImmutableObject</code> is already created and protected as immutable. But, to also protect the contents of <code>myImmutableObject.foo</code> (which is its own object -- array), you would also need to make <code>foo</code> immutable, using one or more of the following functionalities.</p>
<p><strong>Note:</strong> It is not terribly common to create deeply entrenched immutable objects in JS programs. Special cases can certainly call for it, but as a general design pattern, if you find yourself wanting to <em>seal</em> or <em>freeze</em> all your objects, you may want to take a step back and reconsider your program design to be more robust to potential changes in objects' values.</p>
<h4 id="object-constant">Object Constant</h4>
<p>By combining <code>writable:false</code> and <code>configurable:false</code>, you can essentially create a <em>constant</em> (cannot be changed, redefined or deleted) as an object property, like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{};</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>( myObject<span class="op">,</span> <span class="st">&quot;FAVORITE_NUMBER&quot;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">value</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span>
    <span class="dt">writable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
    <span class="dt">configurable</span><span class="op">:</span> <span class="kw">false</span>
<span class="op">}</span> )<span class="op">;</span></code></pre></div>
<h4 id="prevent-extensions">Prevent Extensions</h4>
<p>If you want to prevent an object from having new properties added to it, but otherwise leave the rest of the object's properties alone, call <code>Object.preventExtensions(..)</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">Object</span>.<span class="at">preventExtensions</span>( myObject )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">b</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>
<span class="va">myObject</span>.<span class="at">b</span><span class="op">;</span> <span class="co">// undefined</span></code></pre></div>
<p>In <code>non-strict mode</code>, the creation of <code>b</code> fails silently. In <code>strict mode</code>, it throws a <code>TypeError</code>.</p>
<h4 id="seal">Seal</h4>
<p><code>Object.seal(..)</code> creates a &quot;sealed&quot; object, which means it takes an existing object and essentially calls <code>Object.preventExtensions(..)</code> on it, but also marks all its existing properties as <code>configurable:false</code>.</p>
<p>So, not only can you not add any more properties, but you also cannot reconfigure or delete any existing properties (though you <em>can</em> still modify their values).</p>
<h4 id="freeze">Freeze</h4>
<p><code>Object.freeze(..)</code> creates a frozen object, which means it takes an existing object and essentially calls <code>Object.seal(..)</code> on it, but it also marks all &quot;data accessor&quot; properties as <code>writable:false</code>, so that their values cannot be changed.</p>
<p>This approach is the highest level of immutability that you can attain for an object itself, as it prevents any changes to the object or to any of its direct properties (though, as mentioned above, the contents of any referenced other objects are unaffected).</p>
<p>You could &quot;deep freeze&quot; an object by calling <code>Object.freeze(..)</code> on the object, and then recursively iterating over all objects it references (which would have been unaffected thus far), and calling <code>Object.freeze(..)</code> on them as well. Be careful, though, as that could affect other (shared) objects you're not intending to affect.</p>
<h3 id="get"><code>[[Get]]</code></h3>
<p>There's a subtle, but important, detail about how property accesses are performed.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>The <code>myObject.a</code> is a property access, but it doesn't <em>just</em> look in <code>myObject</code> for a property of the name <code>a</code>, as it might seem.</p>
<p>According to the spec, the code above actually performs a <code>[[Get]]</code> operation (kinda like a function call: <code>[[Get]]()</code>) on the <code>myObject</code>. The default built-in <code>[[Get]]</code> operation for an object <em>first</em> inspects the object for a property of the requested name, and if it finds it, it will return the value accordingly.</p>
<p>However, the <code>[[Get]]</code> algorithm defines other important behavior if it does <em>not</em> find a property of the requested name. We will examine in Chapter 5 what happens <em>next</em> (traversal of the <code>[[Prototype]]</code> chain, if any).</p>
<p>But one important result of this <code>[[Get]]</code> operation is that if it cannot through any means come up with a value for the requested property, it instead returns the value <code>undefined</code>.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">myObject</span>.<span class="at">b</span><span class="op">;</span> <span class="co">// undefined</span></code></pre></div>
<p>This behavior is different from when you reference <em>variables</em> by their identifier names. If you reference a variable that cannot be resolved within the applicable lexical scope look-up, the result is not <code>undefined</code> as it is for object properties, but instead a <code>ReferenceError</code> is thrown.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="kw">undefined</span>
<span class="op">};</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// undefined</span>

<span class="va">myObject</span>.<span class="at">b</span><span class="op">;</span> <span class="co">// undefined</span></code></pre></div>
<p>From a <em>value</em> perspective, there is no difference between these two references -- they both result in <code>undefined</code>. However, the <code>[[Get]]</code> operation underneath, though subtle at a glance, potentially performed a bit more &quot;work&quot; for the reference <code>myObject.b</code> than for the reference <code>myObject.a</code>.</p>
<p>Inspecting only the value results, you cannot distinguish whether a property exists and holds the explicit value <code>undefined</code>, or whether the property does <em>not</em> exist and <code>undefined</code> was the default return value after <code>[[Get]]</code> failed to return something explicitly. However, we will see shortly how you <em>can</em> distinguish these two scenarios.</p>
<h3 id="put"><code>[[Put]]</code></h3>
<p>Since there's an internally defined <code>[[Get]]</code> operation for getting a value from a property, it should be obvious there's also a default <code>[[Put]]</code> operation.</p>
<p>It may be tempting to think that an assignment to a property on an object would just invoke <code>[[Put]]</code> to set or create that property on the object in question. But the situation is more nuanced than that.</p>
<p>When invoking <code>[[Put]]</code>, how it behaves differs based on a number of factors, including (most impactfully) whether the property is already present on the object or not.</p>
<p>If the property is present, the <code>[[Put]]</code> algorithm will roughly check:</p>
<ol type="1">
<li>Is the property an accessor descriptor (see &quot;Getters &amp; Setters&quot; section below)? <strong>If so, call the setter, if any.</strong></li>
<li>Is the property a data descriptor with <code>writable</code> of <code>false</code>? <strong>If so, silently fail in <code>non-strict mode</code>, or throw <code>TypeError</code> in <code>strict mode</code>.</strong></li>
<li>Otherwise, set the value to the existing property as normal.</li>
</ol>
<p>If the property is not yet present on the object in question, the <code>[[Put]]</code> operation is even more nuanced and complex. We will revisit this scenario in Chapter 5 when we discuss <code>[[Prototype]]</code> to give it more clarity.</p>
<h3 id="getters-setters">Getters &amp; Setters</h3>
<p>The default <code>[[Put]]</code> and <code>[[Get]]</code> operations for objects completely control how values are set to existing or new properties, or retrieved from existing properties, respectively.</p>
<p><strong>Note:</strong> Using future/advanced capabilities of the language, it may be possible to override the default <code>[[Get]]</code> or <code>[[Put]]</code> operations for an entire object (not just per property). This is beyond the scope of our discussion in this book, but will be covered later in the &quot;You Don't Know JS&quot; series.</p>
<p>ES5 introduced a way to override part of these default operations, not on an object level but a per-property level, through the use of getters and setters. Getters are properties which actually call a hidden function to retrieve a value. Setters are properties which actually call a hidden function to set a value.</p>
<p>When you define a property to have either a getter or a setter or both, its definition becomes an &quot;accessor descriptor&quot; (as opposed to a &quot;data descriptor&quot;). For accessor-descriptors, the <code>value</code> and <code>writable</code> characteristics of the descriptor are moot and ignored, and instead JS considers the <code>set</code> and <code>get</code> characteristics of the property (as well as <code>configurable</code> and <code>enumerable</code>).</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="co">// define a getter for `a`</span>
    get <span class="at">a</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>(
    myObject<span class="op">,</span>   <span class="co">// target</span>
    <span class="st">&quot;b&quot;</span><span class="op">,</span>        <span class="co">// property name</span>
    <span class="op">{</span>           <span class="co">// descriptor</span>
        <span class="co">// define a getter for `b`</span>
        <span class="dt">get</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span>.<span class="at">a</span> <span class="op">*</span> <span class="dv">2</span> <span class="op">},</span>

        <span class="co">// make sure `b` shows up as an object property</span>
        <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">true</span>
    <span class="op">}</span>
)<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span>

<span class="va">myObject</span>.<span class="at">b</span><span class="op">;</span> <span class="co">// 4</span></code></pre></div>
<p>Either through object-literal syntax with <code>get a() { .. }</code> or through explicit definition with <code>defineProperty(..)</code>, in both cases we created a property on the object that actually doesn't hold a value, but whose access automatically results in a hidden function call to the getter function, with whatever value it returns being the result of the property access.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="co">// define a getter for `a`</span>
    get <span class="at">a</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="va">myObject</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>Since we only defined a getter for <code>a</code>, if we try to set the value of <code>a</code> later, the set operation won't throw an error but will just silently throw the assignment away. Even if there was a valid setter, our custom getter is hard-coded to return only <code>2</code>, so the set operation would be moot.</p>
<p>To make this scenario more sensible, properties should also be defined with setters, which override the default <code>[[Put]]</code> operation (aka, assignment), per-property, just as you'd expect. You will almost certainly want to always declare both getter and setter (having only one or the other often leads to unexpected/surprising behavior):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="co">// define a getter for `a`</span>
    get <span class="at">a</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="kw">this</span>.<span class="at">_a_</span><span class="op">;</span>
    <span class="op">},</span>

    <span class="co">// define a setter for `a`</span>
    set <span class="at">a</span>(val) <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">_a_</span> <span class="op">=</span> val <span class="op">*</span> <span class="dv">2</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="va">myObject</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 4</span></code></pre></div>
<p><strong>Note:</strong> In this example, we actually store the specified value <code>2</code> of the assignment (<code>[[Put]]</code> operation) into another variable <code>_a_</code>. The <code>_a_</code> name is purely by convention for this example and implies nothing special about its behavior -- it's a normal property like any other.</p>
<h3 id="existence">Existence</h3>
<p>We showed earlier that a property access like <code>myObject.a</code> may result in an <code>undefined</code> value if either the explicit <code>undefined</code> is stored there or the <code>a</code> property doesn't exist at all. So, if the value is the same in both cases, how else do we distinguish them?</p>
<p>We can ask an object if it has a certain property <em>without</em> asking to get that property's value:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

(<span class="st">&quot;a&quot;</span> <span class="kw">in</span> myObject)<span class="op">;</span>              <span class="co">// true</span>
(<span class="st">&quot;b&quot;</span> <span class="kw">in</span> myObject)<span class="op">;</span>              <span class="co">// false</span>

<span class="va">myObject</span>.<span class="at">hasOwnProperty</span>( <span class="st">&quot;a&quot;</span> )<span class="op">;</span> <span class="co">// true</span>
<span class="va">myObject</span>.<span class="at">hasOwnProperty</span>( <span class="st">&quot;b&quot;</span> )<span class="op">;</span> <span class="co">// false</span></code></pre></div>
<p>The <code>in</code> operator will check to see if the property is <em>in</em> the object, or if it exists at any higher level of the <code>[[Prototype]]</code> chain object traversal (see Chapter 5). By contrast, <code>hasOwnProperty(..)</code> checks to see if <em>only</em> <code>myObject</code> has the property or not, and will <em>not</em> consult the <code>[[Prototype]]</code> chain. We'll come back to the important differences between these two operations in Chapter 5 when we explore <code>[[Prototype]]</code>s in detail.</p>
<p><code>hasOwnProperty(..)</code> is accessible for all normal objects via delegation to <code>Object.prototype</code> (see Chapter 5). But it's possible to create an object that does not link to <code>Object.prototype</code> (via <code>Object.create(null)</code> -- see Chapter 5). In this case, a method call like <code>myObject.hasOwnProperty(..)</code> would fail.</p>
<p>In that scenario, a more robust way of performing such a check is <code>Object.prototype.hasOwnProperty.call(myObject,&quot;a&quot;)</code>, which borrows the base <code>hasOwnProperty(..)</code> method and uses <em>explicit <code>this</code> binding</em> (see Chapter 2) to apply it against our <code>myObject</code>.</p>
<p><strong>Note:</strong> The <code>in</code> operator has the appearance that it will check for the existence of a <em>value</em> inside a container, but it actually checks for the existence of a property name. This difference is important to note with respect to arrays, as the temptation to try a check like <code>4 in [2, 4, 6]</code> is strong, but this will not behave as expected.</p>
<h4 id="enumeration">Enumeration</h4>
<p>Previously, we explained briefly the idea of &quot;enumerability&quot; when we looked at the <code>enumerable</code> property descriptor characteristic. Let's revisit that and examine it in more close detail.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span> <span class="op">};</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>(
    myObject<span class="op">,</span>
    <span class="st">&quot;a&quot;</span><span class="op">,</span>
    <span class="co">// make `a` enumerable, as normal</span>
    <span class="op">{</span> <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">2</span> <span class="op">}</span>
)<span class="op">;</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>(
    myObject<span class="op">,</span>
    <span class="st">&quot;b&quot;</span><span class="op">,</span>
    <span class="co">// make `b` NON-enumerable</span>
    <span class="op">{</span> <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">3</span> <span class="op">}</span>
)<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">b</span><span class="op">;</span> <span class="co">// 3</span>
(<span class="st">&quot;b&quot;</span> <span class="kw">in</span> myObject)<span class="op">;</span> <span class="co">// true</span>
<span class="va">myObject</span>.<span class="at">hasOwnProperty</span>( <span class="st">&quot;b&quot;</span> )<span class="op">;</span> <span class="co">// true</span>

<span class="co">// .......</span>

<span class="cf">for</span> (<span class="kw">var</span> k <span class="kw">in</span> myObject) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( k<span class="op">,</span> myObject[k] )<span class="op">;</span>
<span class="op">}</span>
<span class="co">// &quot;a&quot; 2</span></code></pre></div>
<p>You'll notice that <code>myObject.b</code> in fact <strong>exists</strong> and has an accessible value, but it doesn't show up in a <code>for..in</code> loop (though, surprisingly, it <strong>is</strong> revealed by the <code>in</code> operator existence check). That's because &quot;enumerable&quot; basically means &quot;will be included if the object's properties are iterated through&quot;.</p>
<p><strong>Note:</strong> <code>for..in</code> loops applied to arrays can give somewhat unexpected results, in that the enumeration of an array will include not only all the numeric indices, but also any enumerable properties. It's a good idea to use <code>for..in</code> loops <em>only</em> on objects, and traditional <code>for</code> loops with numeric index iteration for the values stored in arrays.</p>
<p>Another way that enumerable and non-enumerable properties can be distinguished:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span> <span class="op">};</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>(
    myObject<span class="op">,</span>
    <span class="st">&quot;a&quot;</span><span class="op">,</span>
    <span class="co">// make `a` enumerable, as normal</span>
    <span class="op">{</span> <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">2</span> <span class="op">}</span>
)<span class="op">;</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>(
    myObject<span class="op">,</span>
    <span class="st">&quot;b&quot;</span><span class="op">,</span>
    <span class="co">// make `b` non-enumerable</span>
    <span class="op">{</span> <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">3</span> <span class="op">}</span>
)<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">propertyIsEnumerable</span>( <span class="st">&quot;a&quot;</span> )<span class="op">;</span> <span class="co">// true</span>
<span class="va">myObject</span>.<span class="at">propertyIsEnumerable</span>( <span class="st">&quot;b&quot;</span> )<span class="op">;</span> <span class="co">// false</span>

<span class="va">Object</span>.<span class="at">keys</span>( myObject )<span class="op">;</span> <span class="co">// [&quot;a&quot;]</span>
<span class="va">Object</span>.<span class="at">getOwnPropertyNames</span>( myObject )<span class="op">;</span> <span class="co">// [&quot;a&quot;, &quot;b&quot;]</span></code></pre></div>
<p><code>propertyIsEnumerable(..)</code> tests whether the given property name exists <em>directly</em> on the object and is also <code>enumerable:true</code>.</p>
<p><code>Object.keys(..)</code> returns an array of all enumerable properties, whereas <code>Object.getOwnPropertyNames(..)</code> returns an array of <em>all</em> properties, enumerable or not.</p>
<p>Whereas <code>in</code> vs. <code>hasOwnProperty(..)</code> differ in whether they consult the <code>[[Prototype]]</code> chain or not, <code>Object.keys(..)</code> and <code>Object.getOwnPropertyNames(..)</code> both inspect <em>only</em> the direct object specified.</p>
<p>There's (currently) no built-in way to get a list of <strong>all properties</strong> which is equivalent to what the <code>in</code> operator test would consult (traversing all properties on the entire <code>[[Prototype]]</code> chain, as explained in Chapter 5). You could approximate such a utility by recursively traversing the <code>[[Prototype]]</code> chain of an object, and for each level, capturing the list from <code>Object.keys(..)</code> -- only enumerable properties.</p>
<h2 id="iteration">Iteration</h2>
<p>The <code>for..in</code> loop iterates over the list of enumerable properties on an object (including its <code>[[Prototype]]</code> chain). But what if you instead want to iterate over the values?</p>
<p>With numerically-indexed arrays, iterating over the values is typically done with a standard <code>for</code> loop, like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myArray <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span>

<span class="cf">for</span> (<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">myArray</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( myArray[i] )<span class="op">;</span>
<span class="op">}</span>
<span class="co">// 1 2 3</span></code></pre></div>
<p>This isn't iterating over the values, though, but iterating over the indices, where you then use the index to reference the value, as <code>myArray[i]</code>.</p>
<p>ES5 also added several iteration helpers for arrays, including <code>forEach(..)</code>, <code>every(..)</code>, and <code>some(..)</code>. Each of these helpers accepts a function callback to apply to each element in the array, differing only in how they respectively respond to a return value from the callback.</p>
<p><code>forEach(..)</code> will iterate over all values in the array, and ignores any callback return values. <code>every(..)</code> keeps going until the end <em>or</em> the callback returns a <code>false</code> (or &quot;falsy&quot;) value, whereas <code>some(..)</code> keeps going until the end <em>or</em> the callback returns a <code>true</code> (or &quot;truthy&quot;) value.</p>
<p>These special return values inside <code>every(..)</code> and <code>some(..)</code> act somewhat like a <code>break</code> statement inside a normal <code>for</code> loop, in that they stop the iteration early before it reaches the end.</p>
<p>If you iterate on an object with a <code>for..in</code> loop, you're also only getting at the values indirectly, because it's actually iterating only over the enumerable properties of the object, leaving you to access the properties manually to get the values.</p>
<p><strong>Note:</strong> As contrasted with iterating over an array's indices in a numerically ordered way (<code>for</code> loop or other iterators), the order of iteration over an object's properties is <strong>not guaranteed</strong> and may vary between different JS engines. <strong>Do not rely</strong> on any observed ordering for anything that requires consistency among environments, as any observed agreement is unreliable.</p>
<p>But what if you want to iterate over the values directly instead of the array indices (or object properties)? Helpfully, ES6 adds a <code>for..of</code> loop syntax for iterating over arrays (and objects, if the object defines its own custom iterator):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myArray <span class="op">=</span> [ <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> ]<span class="op">;</span>

<span class="cf">for</span> (<span class="kw">var</span> v of myArray) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( v )<span class="op">;</span>
<span class="op">}</span>
<span class="co">// 1</span>
<span class="co">// 2</span>
<span class="co">// 3</span></code></pre></div>
<p>The <code>for..of</code> loop asks for an iterator object (from a default internal function known as <code>@@iterator</code> in spec-speak) of the <em>thing</em> to be iterated, and the loop then iterates over the successive return values from calling that iterator object's <code>next()</code> method, once for each loop iteration.</p>
<p>Arrays have a built-in <code>@@iterator</code>, so <code>for..of</code> works easily on them, as shown. But let's manually iterate the array, using the built-in <code>@@iterator</code>, to see how it works:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myArray <span class="op">=</span> [ <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> ]<span class="op">;</span>
<span class="kw">var</span> it <span class="op">=</span> myArray[<span class="va">Symbol</span>.<span class="at">iterator</span>]()<span class="op">;</span>

<span class="va">it</span>.<span class="at">next</span>()<span class="op">;</span> <span class="co">// { value:1, done:false }</span>
<span class="va">it</span>.<span class="at">next</span>()<span class="op">;</span> <span class="co">// { value:2, done:false }</span>
<span class="va">it</span>.<span class="at">next</span>()<span class="op">;</span> <span class="co">// { value:3, done:false }</span>
<span class="va">it</span>.<span class="at">next</span>()<span class="op">;</span> <span class="co">// { done:true }</span></code></pre></div>
<p><strong>Note:</strong> We get at the <code>@@iterator</code> <em>internal property</em> of an object using an ES6 <code>Symbol</code>: <code>Symbol.iterator</code>. We briefly mentioned <code>Symbol</code> semantics earlier in the chapter (see &quot;Computed Property Names&quot;), so the same reasoning applies here. You'll always want to reference such special properties by <code>Symbol</code> name reference instead of by the special value it may hold. Also, despite the name's implications, <code>@@iterator</code> is <strong>not the iterator object</strong> itself, but a <strong>function that returns</strong> the iterator object -- a subtle but important detail!</p>
<p>As the above snippet reveals, the return value from an iterator's <code>next()</code> call is an object of the form <code>{ value: .. , done: .. }</code>, where <code>value</code> is the current iteration value, and <code>done</code> is a <code>boolean</code> that indicates if there's more to iterate.</p>
<p>Notice the value <code>3</code> was returned with a <code>done:false</code>, which seems strange at first glance. You have to call the <code>next()</code> a fourth time (which the <code>for..of</code> loop in the previous snippet automatically does) to get <code>done:true</code> and know you're truly done iterating. The reason for this quirk is beyond the scope of what we'll discuss here, but it comes from the semantics of ES6 generator functions.</p>
<p>While arrays do automatically iterate in <code>for..of</code> loops, regular objects <strong>do not have a built-in <code>@@iterator</code></strong>. The reasons for this intentional omission are more complex than we will examine here, but in general it was better to not include some implementation that could prove troublesome for future types of objects.</p>
<p>It <em>is</em> possible to define your own default <code>@@iterator</code> for any object that you care to iterate over. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">b</span><span class="op">:</span> <span class="dv">3</span>
<span class="op">};</span>

<span class="va">Object</span>.<span class="at">defineProperty</span>( myObject<span class="op">,</span> <span class="va">Symbol</span>.<span class="at">iterator</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
    <span class="dt">writable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
    <span class="dt">configurable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">value</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="kw">var</span> o <span class="op">=</span> <span class="kw">this</span><span class="op">;</span>
        <span class="kw">var</span> idx <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
        <span class="kw">var</span> ks <span class="op">=</span> <span class="va">Object</span>.<span class="at">keys</span>( o )<span class="op">;</span>
        <span class="cf">return</span> <span class="op">{</span>
            <span class="dt">next</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
                <span class="cf">return</span> <span class="op">{</span>
                    <span class="dt">value</span><span class="op">:</span> o[ks[idx<span class="op">++</span>]]<span class="op">,</span>
                    <span class="dt">done</span><span class="op">:</span> (idx <span class="op">&gt;</span> <span class="va">ks</span>.<span class="at">length</span>)
                <span class="op">};</span>
            <span class="op">}</span>
        <span class="op">};</span>
    <span class="op">}</span>
<span class="op">}</span> )<span class="op">;</span>

<span class="co">// iterate `myObject` manually</span>
<span class="kw">var</span> it <span class="op">=</span> myObject[<span class="va">Symbol</span>.<span class="at">iterator</span>]()<span class="op">;</span>
<span class="va">it</span>.<span class="at">next</span>()<span class="op">;</span> <span class="co">// { value:2, done:false }</span>
<span class="va">it</span>.<span class="at">next</span>()<span class="op">;</span> <span class="co">// { value:3, done:false }</span>
<span class="va">it</span>.<span class="at">next</span>()<span class="op">;</span> <span class="co">// { value:undefined, done:true }</span>

<span class="co">// iterate `myObject` with `for..of`</span>
<span class="cf">for</span> (<span class="kw">var</span> v of myObject) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( v )<span class="op">;</span>
<span class="op">}</span>
<span class="co">// 2</span>
<span class="co">// 3</span></code></pre></div>
<p><strong>Note:</strong> We used <code>Object.defineProperty(..)</code> to define our custom <code>@@iterator</code> (mostly so we could make it non-enumerable), but using the <code>Symbol</code> as a <em>computed property name</em> (covered earlier in this chapter), we could have declared it directly, like <code>var myObject = { a:2, b:3, [Symbol.iterator]: function(){ /* .. */ } }</code>.</p>
<p>Each time the <code>for..of</code> loop calls <code>next()</code> on <code>myObject</code>'s iterator object, the internal pointer will advance and return back the next value from the object's properties list (see a previous note about iteration ordering on object properties/values).</p>
<p>The iteration we just demonstrated is a simple value-by-value iteration, but you can of course define arbitrarily complex iterations for your custom data structures, as you see fit. Custom iterators combined with ES6's <code>for..of</code> loop are a powerful new syntactic tool for manipulating user-defined objects.</p>
<p>For example, a list of <code>Pixel</code> objects (with <code>x</code> and <code>y</code> coordinate values) could decide to order its iteration based on the linear distance from the <code>(0,0)</code> origin, or filter out points that are &quot;too far away&quot;, etc. As long as your iterator returns the expected <code>{ value: .. }</code> return values from <code>next()</code> calls, and a <code>{ done: true }</code> after the iteration is complete, ES6's <code>for..of</code> can iterate over it.</p>
<p>In fact, you can even generate &quot;infinite&quot; iterators which never &quot;finish&quot; and always return a new value (such as a random number, an incremented value, a unique identifier, etc), though you probably will not use such iterators with an unbounded <code>for..of</code> loop, as it would never end and would hang your program.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> randoms <span class="op">=</span> <span class="op">{</span>
    [<span class="va">Symbol</span>.<span class="at">iterator</span>]<span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="op">{</span>
            <span class="dt">next</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
                <span class="cf">return</span> <span class="op">{</span> <span class="dt">value</span><span class="op">:</span> <span class="va">Math</span>.<span class="at">random</span>() <span class="op">};</span>
            <span class="op">}</span>
        <span class="op">};</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> randoms_pool <span class="op">=</span> []<span class="op">;</span>
<span class="cf">for</span> (<span class="kw">var</span> n of randoms) <span class="op">{</span>
    <span class="va">randoms_pool</span>.<span class="at">push</span>( n )<span class="op">;</span>

    <span class="co">// don&#39;t proceed unbounded!</span>
    <span class="cf">if</span> (<span class="va">randoms_pool</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">100</span>) <span class="cf">break</span><span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>This iterator will generate random numbers &quot;forever&quot;, so we're careful to only pull out 100 values so our program doesn't hang.</p>
<h2 id="review-tldr-2">Review (TL;DR)</h2>
<p>Objects in JS have both a literal form (such as <code>var a = { .. }</code>) and a constructed form (such as <code>var a = new Array(..)</code>). The literal form is almost always preferred, but the constructed form offers, in some cases, more creation options.</p>
<p>Many people mistakenly claim &quot;everything in JavaScript is an object&quot;, but this is incorrect. Objects are one of the 6 (or 7, depending on your perspective) primitive types. Objects have sub-types, including <code>function</code>, and also can be behavior-specialized, like <code>[object Array]</code> as the internal label representing the array object sub-type.</p>
<p>Objects are collections of key/value pairs. The values can be accessed as properties, via <code>.propName</code> or <code>[&quot;propName&quot;]</code> syntax. Whenever a property is accessed, the engine actually invokes the internal default <code>[[Get]]</code> operation (and <code>[[Put]]</code> for setting values), which not only looks for the property directly on the object, but which will traverse the <code>[[Prototype]]</code> chain (see Chapter 5) if not found.</p>
<p>Properties have certain characteristics that can be controlled through property descriptors, such as <code>writable</code> and <code>configurable</code>. In addition, objects can have their mutability (and that of their properties) controlled to various levels of immutability using <code>Object.preventExtensions(..)</code>, <code>Object.seal(..)</code>, and <code>Object.freeze(..)</code>.</p>
<p>Properties don't have to contain values -- they can be &quot;accessor properties&quot; as well, with getters/setters. They can also be either <em>enumerable</em> or not, which controls if they show up in <code>for..in</code> loop iterations, for instance.</p>
<p>You can also iterate over <strong>the values</strong> in data structures (arrays, objects, etc) using the ES6 <code>for..of</code> syntax, which looks for either a built-in or custom <code>@@iterator</code> object consisting of a <code>next()</code> method to advance through the data values one at a time.</p>
<h1 id="you-dont-know-js-this-object-prototypes-3">You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>
<h1 id="chapter-4-mixing-up-class-objects">Chapter 4: Mixing (Up) &quot;Class&quot; Objects</h1>
<p>Following our exploration of objects from the previous chapter, it's natural that we now turn our attention to &quot;object oriented (OO) programming&quot;, with &quot;classes&quot;. We'll first look at &quot;class orientation&quot; as a design pattern, before examining the mechanics of &quot;classes&quot;: &quot;instantiation&quot;, &quot;inheritance&quot; and &quot;(relative) polymorphism&quot;.</p>
<p>We'll see that these concepts don't really map very naturally to the object mechanism in JS, and the lengths (mixins, etc.) many JavaScript developers go to overcome such challenges.</p>
<p><strong>Note:</strong> This chapter spends quite a bit of time (the first half!) on heavy &quot;objected oriented programming&quot; theory. We eventually relate these ideas to real concrete JavaScript code in the second half, when we talk about &quot;Mixins&quot;. But there's a lot of concept and pseudo-code to wade through first, so don't get lost -- just stick with it!</p>
<h2 id="class-theory">Class Theory</h2>
<p>&quot;Class/Inheritance&quot; describes a certain form of code organization and architecture -- a way of modeling real world problem domains in our software.</p>
<p>OO or class oriented programming stresses that data intrinsically has associated behavior (of course, different depending on the type and nature of the data!) that operates on it, so proper design is to package up (aka, encapsulate) the data and the behavior together. This is sometimes called &quot;data structures&quot; in formal computer science.</p>
<p>For example, a series of characters that represents a word or phrase is usually called a &quot;string&quot;. The characters are the data. But you almost never just care about the data, you usually want to <em>do things</em> with the data, so the behaviors that can apply <em>to</em> that data (calculating its length, appending data, searching, etc.) are all designed as methods of a <code>String</code> class.</p>
<p>Any given string is just an instance of this class, which means that it's a neatly collected packaging of both the character data and the functionality we can perform on it.</p>
<p>Classes also imply a way of <em>classifying</em> a certain data structure. The way we do this is to think about any given structure as a specific variation of a more general base definition.</p>
<p>Let's explore this classification process by looking at a commonly cited example. A <em>car</em> can be described as a specific implementation of a more general &quot;class&quot; of thing, called a <em>vehicle</em>.</p>
<p>We model this relationship in software with classes by defining a <code>Vehicle</code> class and a <code>Car</code> class.</p>
<p>The definition of <code>Vehicle</code> might include things like propulsion (engines, etc.), the ability to carry people, etc., which would all be the behaviors. What we define in <code>Vehicle</code> is all the stuff that is common to all (or most of) the different types of vehicles (the &quot;planes, trains, and automobiles&quot;).</p>
<p>It might not make sense in our software to re-define the basic essence of &quot;ability to carry people&quot; over and over again for each different type of vehicle. Instead, we define that capability once in <code>Vehicle</code>, and then when we define <code>Car</code>, we simply indicate that it &quot;inherits&quot; (or &quot;extends&quot;) the base definition from <code>Vehicle</code>. The definition of <code>Car</code> is said to specialize the general <code>Vehicle</code> definition.</p>
<p>While <code>Vehicle</code> and <code>Car</code> collectively define the behavior by way of methods, the data in an instance would be things like the unique VIN of a specific car, etc.</p>
<p><strong>And thus, classes, inheritance, and instantiation emerge.</strong></p>
<p>Another key concept with classes is &quot;polymorphism&quot;, which describes the idea that a general behavior from a parent class can be overridden in a child class to give it more specifics. In fact, relative polymorphism lets us reference the base behavior from the overridden behavior.</p>
<p>Class theory strongly suggests that a parent class and a child class share the same method name for a certain behavior, so that the child overrides the parent (differentially). As we'll see later, doing so in your JavaScript code is opting into frustration and code brittleness.</p>
<h3 id="class-design-pattern">&quot;Class&quot; Design Pattern</h3>
<p>You may never have thought about classes as a &quot;design pattern&quot;, since it's most common to see discussion of popular &quot;OO Design Patterns&quot;, like &quot;Iterator&quot;, &quot;Observer&quot;, &quot;Factory&quot;, &quot;Singleton&quot;, etc. As presented this way, it's almost an assumption that OO classes are the lower-level mechanics by which we implement all (higher level) design patterns, as if OO is a given foundation for <em>all</em> (proper) code.</p>
<p>Depending on your level of formal education in programming, you may have heard of &quot;procedural programming&quot; as a way of describing code which only consists of procedures (aka, functions) calling other functions, without any higher abstractions. You may have been taught that classes were the <em>proper</em> way to transform procedural-style &quot;spaghetti code&quot; into well-formed, well-organized code.</p>
<p>Of course, if you have experience with &quot;functional programming&quot; (Monads, etc.), you know very well that classes are just one of several common design patterns. But for others, this may be the first time you've asked yourself if classes really are a fundamental foundation for code, or if they are an optional abstraction on top of code.</p>
<p>Some languages (like Java) don't give you the choice, so it's not very <em>optional</em> at all -- everything's a class. Other languages like C/C++ or PHP give you both procedural and class-oriented syntaxes, and it's left more to the developer's choice which style or mixture of styles is appropriate.</p>
<h3 id="javascript-classes">JavaScript &quot;Classes&quot;</h3>
<p>Where does JavaScript fall in this regard? JS has had <em>some</em> class-like syntactic elements (like <code>new</code> and <code>instanceof</code>) for quite awhile, and more recently in ES6, some additions, like the <code>class</code> keyword (see Appendix A).</p>
<p>But does that mean JavaScript actually <em>has</em> classes? Plain and simple: <strong>No.</strong></p>
<p>Since classes are a design pattern, you <em>can</em>, with quite a bit of effort (as we'll see throughout the rest of this chapter), implement approximations for much of classical class functionality. JS tries to satisfy the extremely pervasive <em>desire</em> to design with classes by providing seemingly class-like syntax.</p>
<p>While we may have a syntax that looks like classes, it's as if JavaScript mechanics are fighting against you using the <em>class design pattern</em>, because behind the curtain, the mechanisms that you build on are operating quite differently. Syntactic sugar and (extremely widely used) JS &quot;Class&quot; libraries go a long way toward hiding this reality from you, but sooner or later you will face the fact that the <em>classes</em> you have in other languages are not like the &quot;classes&quot; you're faking in JS.</p>
<p>What this boils down to is that classes are an optional pattern in software design, and you have the choice to use them in JavaScript or not. Since many developers have a strong affinity to class oriented software design, we'll spend the rest of this chapter exploring what it takes to maintain the illusion of classes with what JS provides, and the pain points we experience.</p>
<h2 id="class-mechanics">Class Mechanics</h2>
<p>In many class-oriented languages, the &quot;standard library&quot; provides a &quot;stack&quot; data structure (push, pop, etc.) as a <code>Stack</code> class. This class would have an internal set of variables that stores the data, and it would have a set of publicly accessible behaviors (&quot;methods&quot;) provided by the class, which gives your code the ability to interact with the (hidden) data (adding &amp; removing data, etc.).</p>
<p>But in such languages, you don't really operate directly on <code>Stack</code> (unless making a <strong>Static</strong> class member reference, which is outside the scope of our discussion). The <code>Stack</code> class is merely an abstract explanation of what <em>any</em> &quot;stack&quot; should do, but it's not itself <em>a</em> &quot;stack&quot;. You must <strong>instantiate</strong> the <code>Stack</code> class before you have a concrete data structure <em>thing</em> to operate against.</p>
<h3 id="building">Building</h3>
<p>The traditional metaphor for &quot;class&quot; and &quot;instance&quot; based thinking comes from a building construction.</p>
<p>An architect plans out all the characteristics of a building: how wide, how tall, how many windows and in what locations, even what type of material to use for the walls and roof. She doesn't necessarily care, at this point, <em>where</em> the building will be built, nor does she care <em>how many</em> copies of that building will be built.</p>
<p>She also doesn't care very much about the contents of the building -- the furniture, wall paper, ceiling fans, etc. -- only what type of structure they will be contained by.</p>
<p>The architectural blue-prints she produces are only <em>plans</em> for a building. They don't actually constitute a building we can walk into and sit down. We need a builder for that task. A builder will take those plans and follow them, exactly, as he <em>builds</em> the building. In a very real sense, he is <em>copying</em> the intended characteristics from the plans to the physical building.</p>
<p>Once complete, the building is a physical instantiation of the blue-print plans, hopefully an essentially perfect <em>copy</em>. And then the builder can move to the open lot next door and do it all over again, creating yet another <em>copy</em>.</p>
<p>The relationship between building and blue-print is indirect. You can examine a blue-print to understand how the building was structured, for any parts where direct inspection of the building itself was insufficient. But if you want to open a door, you have to go to the building itself -- the blue-print merely has lines drawn on a page that <em>represent</em> where the door should be.</p>
<p>A class is a blue-print. To actually <em>get</em> an object we can interact with, we must build (aka, &quot;instantiate&quot;) something from the class. The end result of such &quot;construction&quot; is an object, typically called an &quot;instance&quot;, which we can directly call methods on and access any public data properties from, as necessary.</p>
<p><strong>This object is a <em>copy</em></strong> of all the characteristics described by the class.</p>
<p>You likely wouldn't expect to walk into a building and find, framed and hanging on the wall, a copy of the blue-prints used to plan the building, though the blue-prints are probably on file with a public records office. Similarly, you don't generally use an object instance to directly access and manipulate its class, but it is usually possible to at least determine <em>which class</em> an object instance comes from.</p>
<p>It's more useful to consider the direct relationship of a class to an object instance, rather than any indirect relationship between an object instance and the class it came from. <strong>A class is instantiated into object form by a copy operation.</strong></p>
<p><img src="fig1.png"/></p>
<p>As you can see, the arrows move from left to right, and from top to bottom, which indicates the copy operations that occur, both conceptually and physically.</p>
<h3 id="constructor">Constructor</h3>
<p>Instances of classes are constructed by a special method of the class, usually of the same name as the class, called a <em>constructor</em>. This method's explicit job is to initialize any information (state) the instance will need.</p>
<p>For example, consider this loose pseudo-code (invented syntax) for classes:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> CoolGuy <span class="op">{</span>
    specialTrick <span class="op">=</span> nothing

    <span class="at">CoolGuy</span>( trick ) <span class="op">{</span>
        specialTrick <span class="op">=</span> trick
    <span class="op">}</span>

    <span class="at">showOff</span>() <span class="op">{</span>
        <span class="at">output</span>( <span class="st">&quot;Here&#39;s my trick: &quot;</span><span class="op">,</span> specialTrick )
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>To <em>make</em> a <code>CoolGuy</code> instance, we would call the class constructor:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">Joe <span class="op">=</span> <span class="kw">new</span> <span class="at">CoolGuy</span>( <span class="st">&quot;jumping rope&quot;</span> )

<span class="va">Joe</span>.<span class="at">showOff</span>() <span class="co">// Here&#39;s my trick: jumping rope</span></code></pre></div>
<p>Notice that the <code>CoolGuy</code> class has a constructor <code>CoolGuy()</code>, which is actually what we call when we say <code>new CoolGuy(..)</code>. We get an object back (an instance of our class) from the constructor, and we can call the method <code>showOff()</code>, which prints out that particular <code>CoolGuy</code>s special trick.</p>
<p><em>Obviously, jumping rope makes Joe a pretty cool guy.</em></p>
<p>The constructor of a class <em>belongs</em> to the class, almost universally with the same name as the class. Also, constructors pretty much always need to be called with <code>new</code> to let the language engine know you want to construct a <em>new</em> class instance.</p>
<h2 id="class-inheritance">Class Inheritance</h2>
<p>In class-oriented languages, not only can you define a class which can be instantiated itself, but you can define another class that <strong>inherits</strong> from the first class.</p>
<p>The second class is often said to be a &quot;child class&quot; whereas the first is the &quot;parent class&quot;. These terms obviously come from the metaphor of parents and children, though the metaphors here are a bit stretched, as you'll see shortly.</p>
<p>When a parent has a biological child, the genetic characteristics of the parent are copied into the child. Obviously, in most biological reproduction systems, there are two parents who co-equally contribute genes to the mix. But for the purposes of the metaphor, we'll assume just one parent.</p>
<p>Once the child exists, he or she is separate from the parent. The child was heavily influenced by the inheritance from his or her parent, but is unique and distinct. If a child ends up with red hair, that doesn't mean the parent's hair <em>was</em> or automatically <em>becomes</em> red.</p>
<p>In a similar way, once a child class is defined, it's separate and distinct from the parent class. The child class contains an initial copy of the behavior from the parent, but can then override any inherited behavior and even define new behavior.</p>
<p>It's important to remember that we're talking about parent and child <strong>classes</strong>, which aren't physical things. This is where the metaphor of parent and child gets a little confusing, because we actually should say that a parent class is like a parent's DNA and a child class is like a child's DNA. We have to make (aka &quot;instantiate&quot;) a person out of each set of DNA to actually have a physical person to have a conversation with.</p>
<p>Let's set aside biological parents and children, and look at inheritance through a slightly different lens: different types of vehicles. That's one of the most canonical (and often groan-worthy) metaphors to understand inheritance.</p>
<p>Let's revisit the <code>Vehicle</code> and <code>Car</code> discussion from earlier in this chapter. Consider this loose pseudo-code (invented syntax) for inherited classes:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> Vehicle <span class="op">{</span>
    engines <span class="op">=</span> <span class="dv">1</span>

    <span class="at">ignition</span>() <span class="op">{</span>
        <span class="at">output</span>( <span class="st">&quot;Turning on my engine.&quot;</span> )
    <span class="op">}</span>

    <span class="at">drive</span>() <span class="op">{</span>
        <span class="at">ignition</span>()
        <span class="at">output</span>( <span class="st">&quot;Steering and moving forward!&quot;</span> )
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">class</span> Car inherits Vehicle <span class="op">{</span>
    wheels <span class="op">=</span> <span class="dv">4</span>

    <span class="at">drive</span>() <span class="op">{</span>
        <span class="dt">inherited</span><span class="op">:</span><span class="at">drive</span>()
        <span class="at">output</span>( <span class="st">&quot;Rolling on all &quot;</span><span class="op">,</span> wheels<span class="op">,</span> <span class="st">&quot; wheels!&quot;</span> )
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">class</span> SpeedBoat inherits Vehicle <span class="op">{</span>
    engines <span class="op">=</span> <span class="dv">2</span>

    <span class="at">ignition</span>() <span class="op">{</span>
        <span class="at">output</span>( <span class="st">&quot;Turning on my &quot;</span><span class="op">,</span> engines<span class="op">,</span> <span class="st">&quot; engines.&quot;</span> )
    <span class="op">}</span>

    <span class="at">pilot</span>() <span class="op">{</span>
        <span class="dt">inherited</span><span class="op">:</span><span class="at">drive</span>()
        <span class="at">output</span>( <span class="st">&quot;Speeding through the water with ease!&quot;</span> )
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p><strong>Note:</strong> For clarity and brevity, constructors for these classes have been omitted.</p>
<p>We define the <code>Vehicle</code> class to assume an engine, a way to turn on the ignition, and a way to drive around. But you wouldn't ever manufacture just a generic &quot;vehicle&quot;, so it's really just an abstract concept at this point.</p>
<p>So then we define two specific kinds of vehicle: <code>Car</code> and <code>SpeedBoat</code>. They each inherit the general characteristics of <code>Vehicle</code>, but then they specialize the characteristics appropriately for each kind. A car needs 4 wheels, and a speed boat needs 2 engines, which means it needs extra attention to turn on the ignition of both engines.</p>
<h3 id="polymorphism">Polymorphism</h3>
<p><code>Car</code> defines its own <code>drive()</code> method, which overrides the method of the same name it inherited from <code>Vehicle</code>. But then, <code>Car</code>s <code>drive()</code> method calls <code>inherited:drive()</code>, which indicates that <code>Car</code> can reference the original pre-overridden <code>drive()</code> it inherited. <code>SpeedBoat</code>s <code>pilot()</code> method also makes a reference to its inherited copy of <code>drive()</code>.</p>
<p>This technique is called &quot;polymorphism&quot;, or &quot;virtual polymorphism&quot;. More specifically to our current point, we'll call it &quot;relative polymorphism&quot;.</p>
<p>Polymorphism is a much broader topic than we will exhaust here, but our current &quot;relative&quot; semantics refers to one particular aspect: the idea that any method can reference another method (of the same or different name) at a higher level of the inheritance hierarchy. We say &quot;relative&quot; because we don't absolutely define which inheritance level (aka, class) we want to access, but rather relatively reference it by essentially saying &quot;look one level up&quot;.</p>
<p>In many languages, the keyword <code>super</code> is used, in place of this example's <code>inherited:</code>, which leans on the idea that a &quot;super class&quot; is the parent/ancestor of the current class.</p>
<p>Another aspect of polymorphism is that a method name can have multiple definitions at different levels of the inheritance chain, and these definitions are automatically selected as appropriate when resolving which methods are being called.</p>
<p>We see two occurrences of that behavior in our example above: <code>drive()</code> is defined in both <code>Vehicle</code> and <code>Car</code>, and <code>ignition()</code> is defined in both <code>Vehicle</code> and <code>SpeedBoat</code>.</p>
<p><strong>Note:</strong> Another thing that traditional class-oriented languages give you via <code>super</code> is a direct way for the constructor of a child class to reference the constructor of its parent class. This is largely true because with real classes, the constructor belongs to the class. However, in JS, it's the reverse -- it's actually more appropriate to think of the &quot;class&quot; belonging to the constructor (the <code>Foo.prototype...</code> type references). Since in JS the relationship between child and parent exists only between the two <code>.prototype</code> objects of the respective constructors, the constructors themselves are not directly related, and thus there's no simple way to relatively reference one from the other (see Appendix A for ES6 <code>class</code> which &quot;solves&quot; this with <code>super</code>).</p>
<p>An interesting implication of polymorphism can be seen specifically with <code>ignition()</code>. Inside <code>pilot()</code>, a relative-polymorphic reference is made to (the inherited) <code>Vehicle</code>s version of <code>drive()</code>. But that <code>drive()</code> references an <code>ignition()</code> method just by name (no relative reference).</p>
<p>Which version of <code>ignition()</code> will the language engine use, the one from <code>Vehicle</code> or the one from <code>SpeedBoat</code>? <strong>It uses the <code>SpeedBoat</code> version of <code>ignition()</code>.</strong> If you <em>were</em> to instantiate <code>Vehicle</code> class itself, and then call its <code>drive()</code>, the language engine would instead just use <code>Vehicle</code>s <code>ignition()</code> method definition.</p>
<p>Put another way, the definition for the method <code>ignition()</code> <em>polymorphs</em> (changes) depending on which class (level of inheritance) you are referencing an instance of.</p>
<p>This may seem like overly deep academic detail. But understanding these details is necessary to properly contrast similar (but distinct) behaviors in JavaScript's <code>[[Prototype]]</code> mechanism.</p>
<p>When classes are inherited, there is a way <strong>for the classes themselves</strong> (not the object instances created from them!) to <em>relatively</em> reference the class inherited from, and this relative reference is usually called <code>super</code>.</p>
<p>Remember this figure from earlier:</p>
<p><img src="fig1.png"/></p>
<p>Notice how for both instantiation (<code>a1</code>, <code>a2</code>, <code>b1</code>, and <code>b2</code>) <em>and</em> inheritance (<code>Bar</code>), the arrows indicate a copy operation.</p>
<p>Conceptually, it would seem a child class <code>Bar</code> can access behavior in its parent class <code>Foo</code> using a relative polymorphic reference (aka, <code>super</code>). However, in reality, the child class is merely given a copy of the inherited behavior from its parent class. If the child &quot;overrides&quot; a method it inherits, both the original and overridden versions of the method are actually maintained, so that they are both accessible.</p>
<p>Don't let polymorphism confuse you into thinking a child class is linked to its parent class. A child class instead gets a copy of what it needs from the parent class. <strong>Class inheritance implies copies.</strong></p>
<h3 id="multiple-inheritance">Multiple Inheritance</h3>
<p>Recall our earlier discussion of parent(s) and children and DNA? We said that the metaphor was a bit weird because biologically most offspring come from two parents. If a class could inherit from two other classes, it would more closely fit the parent/child metaphor.</p>
<p>Some class-oriented languages allow you to specify more than one &quot;parent&quot; class to &quot;inherit&quot; from. Multiple-inheritance means that each parent class definition is copied into the child class.</p>
<p>On the surface, this seems like a powerful addition to class-orientation, giving us the ability to compose more functionality together. However, there are certainly some complicating questions that arise. If both parent classes provide a method called <code>drive()</code>, which version would a <code>drive()</code> reference in the child resolve to? Would you always have to manually specify which parent's <code>drive()</code> you meant, thus losing some of the gracefulness of polymorphic inheritance?</p>
<p>There's another variation, the so called &quot;Diamond Problem&quot;, which refers to the scenario where a child class &quot;D&quot; inherits from two parent classes (&quot;B&quot; and &quot;C&quot;), and each of those in turn inherits from a common &quot;A&quot; parent. If &quot;A&quot; provides a method <code>drive()</code>, and both &quot;B&quot; and &quot;C&quot; override (polymorph) that method, when <code>D</code> references <code>drive()</code>, which version should it use (<code>B:drive()</code> or <code>C:drive()</code>)?</p>
<p><img src="fig2.png"/></p>
<p>These complications go even much deeper than this quick glance. We address them here only so we can contrast to how JavaScript's mechanisms work.</p>
<p>JavaScript is simpler: it does not provide a native mechanism for &quot;multiple inheritance&quot;. Many see this is a good thing, because the complexity savings more than make up for the &quot;reduced&quot; functionality. But this doesn't stop developers from trying to fake it in various ways, as we'll see next.</p>
<h2 id="mixins">Mixins</h2>
<p>JavaScript's object mechanism does not <em>automatically</em> perform copy behavior when you &quot;inherit&quot; or &quot;instantiate&quot;. Plainly, there are no &quot;classes&quot; in JavaScript to instantiate, only objects. And objects don't get copied to other objects, they get <em>linked together</em> (more on that in Chapter 5).</p>
<p>Since observed class behaviors in other languages imply copies, let's examine how JS developers <strong>fake</strong> the <em>missing</em> copy behavior of classes in JavaScript: mixins. We'll look at two types of &quot;mixin&quot;: <strong>explicit</strong> and <strong>implicit</strong>.</p>
<h3 id="explicit-mixins">Explicit Mixins</h3>
<p>Let's again revisit our <code>Vehicle</code> and <code>Car</code> example from before. Since JavaScript will not automatically copy behavior from <code>Vehicle</code> to <code>Car</code>, we can instead create a utility that manually copies. Such a utility is often called <code>extend(..)</code> by many libraries/frameworks, but we will call it <code>mixin(..)</code> here for illustrative purposes.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// vastly simplified `mixin(..)` example:</span>
<span class="kw">function</span> <span class="at">mixin</span>( sourceObj<span class="op">,</span> targetObj ) <span class="op">{</span>
    <span class="cf">for</span> (<span class="kw">var</span> key <span class="kw">in</span> sourceObj) <span class="op">{</span>
        <span class="co">// only copy if not already present</span>
        <span class="cf">if</span> (<span class="op">!</span>(key <span class="kw">in</span> targetObj)) <span class="op">{</span>
            targetObj[key] <span class="op">=</span> sourceObj[key]<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="cf">return</span> targetObj<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> Vehicle <span class="op">=</span> <span class="op">{</span>
    <span class="dt">engines</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span>

    <span class="dt">ignition</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Turning on my engine.&quot;</span> )<span class="op">;</span>
    <span class="op">},</span>

    <span class="dt">drive</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">ignition</span>()<span class="op">;</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Steering and moving forward!&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> Car <span class="op">=</span> <span class="at">mixin</span>( Vehicle<span class="op">,</span> <span class="op">{</span>
    <span class="dt">wheels</span><span class="op">:</span> <span class="dv">4</span><span class="op">,</span>

    <span class="dt">drive</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="va">Vehicle</span>.<span class="va">drive</span>.<span class="at">call</span>( <span class="kw">this</span> )<span class="op">;</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Rolling on all &quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">wheels</span> <span class="op">+</span> <span class="st">&quot; wheels!&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span> )<span class="op">;</span></code></pre></div>
<p><strong>Note:</strong> Subtly but importantly, we're not dealing with classes anymore, because there are no classes in JavaScript. <code>Vehicle</code> and <code>Car</code> are just objects that we make copies from and to, respectively.</p>
<p><code>Car</code> now has a copy of the properties and functions from <code>Vehicle</code>. Technically, functions are not actually duplicated, but rather <em>references</em> to the functions are copied. So, <code>Car</code> now has a property called <code>ignition</code>, which is a copied reference to the <code>ignition()</code> function, as well as a property called <code>engines</code> with the copied value of <code>1</code> from <code>Vehicle</code>.</p>
<p><code>Car</code> <em>already</em> had a <code>drive</code> property (function), so that property reference was not overridden (see the <code>if</code> statement in <code>mixin(..)</code> above).</p>
<h4 id="polymorphism-revisited">&quot;Polymorphism&quot; Revisited</h4>
<p>Let's examine this statement: <code>Vehicle.drive.call( this )</code>. This is what I call &quot;explicit pseudo-polymorphism&quot;. Recall in our previous pseudo-code this line was <code>inherited:drive()</code>, which we called &quot;relative polymorphism&quot;.</p>
<p>JavaScript does not have (prior to ES6; see Appendix A) a facility for relative polymorphism. So, <strong>because both <code>Car</code> and <code>Vehicle</code> had a function of the same name: <code>drive()</code></strong>, to distinguish a call to one or the other, we must make an absolute (not relative) reference. We explicitly specify the <code>Vehicle</code> object by name, and call the <code>drive()</code> function on it.</p>
<p>But if we said <code>Vehicle.drive()</code>, the <code>this</code> binding for that function call would be the <code>Vehicle</code> object instead of the <code>Car</code> object (see Chapter 2), which is not what we want. So, instead we use <code>.call( this )</code> (Chapter 2) to ensure that <code>drive()</code> is executed in the context of the <code>Car</code> object.</p>
<p><strong>Note:</strong> If the function name identifier for <code>Car.drive()</code> hadn't overlapped with (aka, &quot;shadowed&quot;; see Chapter 5) <code>Vehicle.drive()</code>, we wouldn't have been exercising &quot;method polymorphism&quot;. So, a reference to <code>Vehicle.drive()</code> would have been copied over by the <code>mixin(..)</code> call, and we could have accessed directly with <code>this.drive()</code>. The chosen identifier overlap <strong>shadowing</strong> is <em>why</em> we have to use the more complex <em>explicit pseudo-polymorphism</em> approach.</p>
<p>In class-oriented languages, which have relative polymorphism, the linkage between <code>Car</code> and <code>Vehicle</code> is established once, at the top of the class definition, which makes for only one place to maintain such relationships.</p>
<p>But because of JavaScript's peculiarities, explicit pseudo-polymorphism (because of shadowing!) creates brittle manual/explicit linkage <strong>in every single function where you need such a (pseudo-)polymorphic reference</strong>. This can significantly increase the maintenance cost. Moreover, while explicit pseudo-polymorphism can emulate the behavior of &quot;multiple inheritance&quot;, it only increases the complexity and brittleness.</p>
<p>The result of such approaches is usually more complex, harder-to-read, <em>and</em> harder-to-maintain code. <strong>Explicit pseudo-polymorphism should be avoided wherever possible</strong>, because the cost outweighs the benefit in most respects.</p>
<h4 id="mixing-copies">Mixing Copies</h4>
<p>Recall the <code>mixin(..)</code> utility from above:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// vastly simplified `mixin()` example:</span>
<span class="kw">function</span> <span class="at">mixin</span>( sourceObj<span class="op">,</span> targetObj ) <span class="op">{</span>
    <span class="cf">for</span> (<span class="kw">var</span> key <span class="kw">in</span> sourceObj) <span class="op">{</span>
        <span class="co">// only copy if not already present</span>
        <span class="cf">if</span> (<span class="op">!</span>(key <span class="kw">in</span> targetObj)) <span class="op">{</span>
            targetObj[key] <span class="op">=</span> sourceObj[key]<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="cf">return</span> targetObj<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Now, let's examine how <code>mixin(..)</code> works. It iterates over the properties of <code>sourceObj</code> (<code>Vehicle</code> in our example) and if there's no matching property of that name in <code>targetObj</code> (<code>Car</code> in our example), it makes a copy. Since we're making the copy after the initial object exists, we are careful to not copy over a target property.</p>
<p>If we made the copies first, before specifying the <code>Car</code> specific contents, we could omit this check against <code>targetObj</code>, but that's a little more clunky and less efficient, so it's generally less preferred:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// alternate mixin, less &quot;safe&quot; to overwrites</span>
<span class="kw">function</span> <span class="at">mixin</span>( sourceObj<span class="op">,</span> targetObj ) <span class="op">{</span>
    <span class="cf">for</span> (<span class="kw">var</span> key <span class="kw">in</span> sourceObj) <span class="op">{</span>
        targetObj[key] <span class="op">=</span> sourceObj[key]<span class="op">;</span>
    <span class="op">}</span>

    <span class="cf">return</span> targetObj<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> Vehicle <span class="op">=</span> <span class="op">{</span>
    <span class="co">// ...</span>
<span class="op">};</span>

<span class="co">// first, create an empty object with</span>
<span class="co">// Vehicle&#39;s stuff copied in</span>
<span class="kw">var</span> Car <span class="op">=</span> <span class="at">mixin</span>( Vehicle<span class="op">,</span> <span class="op">{</span> <span class="op">}</span> )<span class="op">;</span>

<span class="co">// now copy the intended contents into Car</span>
<span class="at">mixin</span>( <span class="op">{</span>
    <span class="dt">wheels</span><span class="op">:</span> <span class="dv">4</span><span class="op">,</span>

    <span class="dt">drive</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="co">// ...</span>
    <span class="op">}</span>
<span class="op">},</span> Car )<span class="op">;</span></code></pre></div>
<p>Either approach, we have explicitly copied the non-overlapping contents of <code>Vehicle</code> into <code>Car</code>. The name &quot;mixin&quot; comes from an alternate way of explaining the task: <code>Car</code> has <code>Vehicle</code>s contents <strong>mixed-in</strong>, just like you mix in chocolate chips into your favorite cookie dough.</p>
<p>As a result of the copy operation, <code>Car</code> will operate somewhat separately from <code>Vehicle</code>. If you add a property onto <code>Car</code>, it will not affect <code>Vehicle</code>, and vice versa.</p>
<p><strong>Note:</strong> A few minor details have been skimmed over here. There are still some subtle ways the two objects can &quot;affect&quot; each other even after copying, such as if they both share a reference to a common object (such as an array).</p>
<p>Since the two objects also share references to their common functions, that means that <strong>even manual copying of functions (aka, mixins) from one object to another doesn't <em>actually emulate</em> the real duplication from class to instance that occurs in class-oriented languages</strong>.</p>
<p>JavaScript functions can't really be duplicated (in a standard, reliable way), so what you end up with instead is a <strong>duplicated reference</strong> to the same shared function object (functions are objects; see Chapter 3). If you modified one of the shared <strong>function objects</strong> (like <code>ignition()</code>) by adding properties on top of it, for instance, both <code>Vehicle</code> and <code>Car</code> would be &quot;affected&quot; via the shared reference.</p>
<p>Explicit mixins are a fine mechanism in JavaScript. But they appear more powerful than they really are. Not much benefit is <em>actually</em> derived from copying a property from one object to another, <strong>as opposed to just defining the properties twice</strong>, once on each object. And that's especially true given the function-object reference nuance we just mentioned.</p>
<p>If you explicitly mix-in two or more objects into your target object, you can <strong>partially emulate</strong> the behavior of &quot;multiple inheritance&quot;, but there's no direct way to handle collisions if the same method or property is being copied from more than one source. Some developers/libraries have come up with &quot;late binding&quot; techniques and other exotic work-arounds, but fundamentally these &quot;tricks&quot; are <em>usually</em> more effort (and lesser performance!) than the pay-off.</p>
<p>Take care only to use explicit mixins where it actually helps make more readable code, and avoid the pattern if you find it making code that's harder to trace, or if you find it creates unnecessary or unwieldy dependencies between objects.</p>
<p><strong>If it starts to get <em>harder</em> to properly use mixins than before you used them</strong>, you should probably stop using mixins. In fact, if you have to use a complex library/utility to work out all these details, it might be a sign that you're going about it the harder way, perhaps unnecessarily. In Chapter 6, we'll try to distill a simpler way that accomplishes the desired outcomes without all the fuss.</p>
<h4 id="parasitic-inheritance">Parasitic Inheritance</h4>
<p>A variation on this explicit mixin pattern, which is both in some ways explicit and in other ways implicit, is called &quot;parasitic inheritance&quot;, popularized mainly by Douglas Crockford.</p>
<p>Here's how it can work:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// &quot;Traditional JS Class&quot; `Vehicle`</span>
<span class="kw">function</span> <span class="at">Vehicle</span>() <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">engines</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
<span class="op">}</span>
<span class="va">Vehicle</span>.<span class="va">prototype</span>.<span class="at">ignition</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Turning on my engine.&quot;</span> )<span class="op">;</span>
<span class="op">};</span>
<span class="va">Vehicle</span>.<span class="va">prototype</span>.<span class="at">drive</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">ignition</span>()<span class="op">;</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Steering and moving forward!&quot;</span> )<span class="op">;</span>
<span class="op">};</span>

<span class="co">// &quot;Parasitic Class&quot; `Car`</span>
<span class="kw">function</span> <span class="at">Car</span>() <span class="op">{</span>
    <span class="co">// first, `car` is a `Vehicle`</span>
    <span class="kw">var</span> car <span class="op">=</span> <span class="kw">new</span> <span class="at">Vehicle</span>()<span class="op">;</span>

    <span class="co">// now, let&#39;s modify our `car` to specialize it</span>
    <span class="va">car</span>.<span class="at">wheels</span> <span class="op">=</span> <span class="dv">4</span><span class="op">;</span>

    <span class="co">// save a privileged reference to `Vehicle::drive()`</span>
    <span class="kw">var</span> vehDrive <span class="op">=</span> <span class="va">car</span>.<span class="at">drive</span><span class="op">;</span>

    <span class="co">// override `Vehicle::drive()`</span>
    <span class="va">car</span>.<span class="at">drive</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="va">vehDrive</span>.<span class="at">call</span>( <span class="kw">this</span> )<span class="op">;</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Rolling on all &quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">wheels</span> <span class="op">+</span> <span class="st">&quot; wheels!&quot;</span> )<span class="op">;</span>
    <span class="op">};</span>

    <span class="cf">return</span> car<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> myCar <span class="op">=</span> <span class="kw">new</span> <span class="at">Car</span>()<span class="op">;</span>

<span class="va">myCar</span>.<span class="at">drive</span>()<span class="op">;</span>
<span class="co">// Turning on my engine.</span>
<span class="co">// Steering and moving forward!</span>
<span class="co">// Rolling on all 4 wheels!</span></code></pre></div>
<p>As you can see, we initially make a copy of the definition from the <code>Vehicle</code> &quot;parent class&quot; (object), then mixin our &quot;child class&quot; (object) definition (preserving privileged parent-class references as needed), and pass off this composed object <code>car</code> as our child instance.</p>
<p><strong>Note:</strong> when we call <code>new Car()</code>, a new object is created and referenced by <code>Car</code>s <code>this</code> reference (see Chapter 2). But since we don't use that object, and instead return our own <code>car</code> object, the initially created object is just discarded. So, <code>Car()</code> could be called without the <code>new</code> keyword, and the functionality above would be identical, but without the wasted object creation/garbage-collection.</p>
<h3 id="implicit-mixins">Implicit Mixins</h3>
<p>Implicit mixins are closely related to <em>explicit pseudo-polymorphism</em> as explained previously. As such, they come with the same caveats and warnings.</p>
<p>Consider this code:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> Something <span class="op">=</span> <span class="op">{</span>
    <span class="dt">cool</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">greeting</span> <span class="op">=</span> <span class="st">&quot;Hello World&quot;</span><span class="op">;</span>
        <span class="kw">this</span>.<span class="at">count</span> <span class="op">=</span> <span class="kw">this</span>.<span class="at">count</span> <span class="op">?</span> <span class="kw">this</span>.<span class="at">count</span> <span class="op">+</span> <span class="dv">1</span> : <span class="dv">1</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="va">Something</span>.<span class="at">cool</span>()<span class="op">;</span>
<span class="va">Something</span>.<span class="at">greeting</span><span class="op">;</span> <span class="co">// &quot;Hello World&quot;</span>
<span class="va">Something</span>.<span class="at">count</span><span class="op">;</span> <span class="co">// 1</span>

<span class="kw">var</span> Another <span class="op">=</span> <span class="op">{</span>
    <span class="dt">cool</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="co">// implicit mixin of `Something` to `Another`</span>
        <span class="va">Something</span>.<span class="va">cool</span>.<span class="at">call</span>( <span class="kw">this</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="va">Another</span>.<span class="at">cool</span>()<span class="op">;</span>
<span class="va">Another</span>.<span class="at">greeting</span><span class="op">;</span> <span class="co">// &quot;Hello World&quot;</span>
<span class="va">Another</span>.<span class="at">count</span><span class="op">;</span> <span class="co">// 1 (not shared state with `Something`)</span></code></pre></div>
<p>With <code>Something.cool.call( this )</code>, which can happen either in a &quot;constructor&quot; call (most common) or in a method call (shown here), we essentially &quot;borrow&quot; the function <code>Something.cool()</code> and call it in the context of <code>Another</code> (via its <code>this</code> binding; see Chapter 2) instead of <code>Something</code>. The end result is that the assignments that <code>Something.cool()</code> makes are applied against the <code>Another</code> object rather than the <code>Something</code> object.</p>
<p>So, it is said that we &quot;mixed in&quot; <code>Something</code>s behavior with (or into) <code>Another</code>.</p>
<p>While this sort of technique seems to take useful advantage of <code>this</code> rebinding functionality, it is the brittle <code>Something.cool.call( this )</code> call, which cannot be made into a relative (and thus more flexible) reference, that you should <strong>heed with caution</strong>. Generally, <strong>avoid such constructs where possible</strong> to keep cleaner and more maintainable code.</p>
<h2 id="review-tldr-3">Review (TL;DR)</h2>
<p>Classes are a design pattern. Many languages provide syntax which enables natural class-oriented software design. JS also has a similar syntax, but it behaves <strong>very differently</strong> from what you're used to with classes in those other languages.</p>
<p><strong>Classes mean copies.</strong></p>
<p>When traditional classes are instantiated, a copy of behavior from class to instance occurs. When classes are inherited, a copy of behavior from parent to child also occurs.</p>
<p>Polymorphism (having different functions at multiple levels of an inheritance chain with the same name) may seem like it implies a referential relative link from child back to parent, but it's still just a result of copy behavior.</p>
<p>JavaScript <strong>does not automatically</strong> create copies (as classes imply) between objects.</p>
<p>The mixin pattern (both explicit and implicit) is often used to <em>sort of</em> emulate class copy behavior, but this usually leads to ugly and brittle syntax like explicit pseudo-polymorphism (<code>OtherObj.methodName.call(this, ...)</code>), which often results in harder to understand and maintain code.</p>
<p>Explicit mixins are also not exactly the same as class <em>copy</em>, since objects (and functions!) only have shared references duplicated, not the objects/functions duplicated themselves. Not paying attention to such nuance is the source of a variety of gotchas.</p>
<p>In general, faking classes in JS often sets more landmines for future coding than solving present <em>real</em> problems.</p>
<h1 id="you-dont-know-js-this-object-prototypes-4">You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>
<h1 id="chapter-5-prototypes">Chapter 5: Prototypes</h1>
<p>In Chapters 3 and 4, we mentioned the <code>[[Prototype]]</code> chain several times, but haven't said what exactly it is. We will now examine prototypes in detail.</p>
<p><strong>Note:</strong> All of the attempts to emulate class-copy behavior, as described previously in Chapter 4, labeled as variations of &quot;mixins&quot;, completely circumvent the <code>[[Prototype]]</code> chain mechanism we examine here in this chapter.</p>
<h2 id="prototype"><code>[[Prototype]]</code></h2>
<p>Objects in JavaScript have an internal property, denoted in the specification as <code>[[Prototype]]</code>, which is simply a reference to another object. Almost all objects are given a non-<code>null</code> value for this property, at the time of their creation.</p>
<p><strong>Note:</strong> We will see shortly that it <em>is</em> possible for an object to have an empty <code>[[Prototype]]</code> linkage, though this is somewhat less common.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>What is the <code>[[Prototype]]</code> reference used for? In Chapter 3, we examined the <code>[[Get]]</code> operation that is invoked when you reference a property on an object, such as <code>myObject.a</code>. For that default <code>[[Get]]</code> operation, the first step is to check if the object itself has a property <code>a</code> on it, and if so, it's used.</p>
<p><strong>Note:</strong> ES6 Proxies are outside of our discussion scope in this book (will be covered in a later book in the series!), but everything we discuss here about normal <code>[[Get]]</code> and <code>[[Put]]</code> behavior does not apply if a <code>Proxy</code> is involved.</p>
<p>But it's what happens if <code>a</code> <strong>isn't</strong> present on <code>myObject</code> that brings our attention now to the <code>[[Prototype]]</code> link of the object.</p>
<p>The default <code>[[Get]]</code> operation proceeds to follow the <code>[[Prototype]]</code> <strong>link</strong> of the object if it cannot find the requested property on the object directly.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> anotherObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="co">// create an object linked to `anotherObject`</span>
<span class="kw">var</span> myObject <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( anotherObject )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p><strong>Note:</strong> We will explain what <code>Object.create(..)</code> does, and how it operates, shortly. For now, just assume it creates an object with the <code>[[Prototype]]</code> linkage we're examining to the object specified.</p>
<p>So, we have <code>myObject</code> that is now <code>[[Prototype]]</code> linked to <code>anotherObject</code>. Clearly <code>myObject.a</code> doesn't actually exist, but nevertheless, the property access succeeds (being found on <code>anotherObject</code> instead) and indeed finds the value <code>2</code>.</p>
<p>But, if <code>a</code> weren't found on <code>anotherObject</code> either, its <code>[[Prototype]]</code> chain, if non-empty, is again consulted and followed.</p>
<p>This process continues until either a matching property name is found, or the <code>[[Prototype]]</code> chain ends. If no matching property is <em>ever</em> found by the end of the chain, the return result from the <code>[[Get]]</code> operation is <code>undefined</code>.</p>
<p>Similar to this <code>[[Prototype]]</code> chain look-up process, if you use a <code>for..in</code> loop to iterate over an object, any property that can be reached via its chain (and is also <code>enumerable</code> -- see Chapter 3) will be enumerated. If you use the <code>in</code> operator to test for the existence of a property on an object, <code>in</code> will check the entire chain of the object (regardless of <em>enumerability</em>).</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> anotherObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="co">// create an object linked to `anotherObject`</span>
<span class="kw">var</span> myObject <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( anotherObject )<span class="op">;</span>

<span class="cf">for</span> (<span class="kw">var</span> k <span class="kw">in</span> myObject) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;found: &quot;</span> <span class="op">+</span> k)<span class="op">;</span>
<span class="op">}</span>
<span class="co">// found: a</span>

(<span class="st">&quot;a&quot;</span> <span class="kw">in</span> myObject)<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>So, the <code>[[Prototype]]</code> chain is consulted, one link at a time, when you perform property look-ups in various fashions. The look-up stops once the property is found or the chain ends.</p>
<h3 id="object.prototype"><code>Object.prototype</code></h3>
<p>But <em>where</em> exactly does the <code>[[Prototype]]</code> chain &quot;end&quot;?</p>
<p>The top-end of every <em>normal</em> <code>[[Prototype]]</code> chain is the built-in <code>Object.prototype</code>. This object includes a variety of common utilities used all over JS, because all normal (built-in, not host-specific extension) objects in JavaScript &quot;descend from&quot; (aka, have at the top of their <code>[[Prototype]]</code> chain) the <code>Object.prototype</code> object.</p>
<p>Some utilities found here you may be familiar with include <code>.toString()</code> and <code>.valueOf()</code>. In Chapter 3, we introduced another: <code>.hasOwnProperty(..)</code>. And yet another function on <code>Object.prototype</code> you may not be familiar with, but which we'll address later in this chapter, is <code>.isPrototypeOf(..)</code>.</p>
<h3 id="setting-shadowing-properties">Setting &amp; Shadowing Properties</h3>
<p>Back in Chapter 3, we mentioned that setting properties on an object was more nuanced than just adding a new property to the object or changing an existing property's value. We will now revisit this situation more completely.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">myObject</span>.<span class="at">foo</span> <span class="op">=</span> <span class="st">&quot;bar&quot;</span><span class="op">;</span></code></pre></div>
<p>If the <code>myObject</code> object already has a normal data accessor property called <code>foo</code> directly present on it, the assignment is as simple as changing the value of the existing property.</p>
<p>If <code>foo</code> is not already present directly on <code>myObject</code>, the <code>[[Prototype]]</code> chain is traversed, just like for the <code>[[Get]]</code> operation. If <code>foo</code> is not found anywhere in the chain, the property <code>foo</code> is added directly to <code>myObject</code> with the specified value, as expected.</p>
<p>However, if <code>foo</code> is already present somewhere higher in the chain, nuanced (and perhaps surprising) behavior can occur with the <code>myObject.foo = &quot;bar&quot;</code> assignment. We'll examine that more in just a moment.</p>
<p>If the property name <code>foo</code> ends up both on <code>myObject</code> itself and at a higher level of the <code>[[Prototype]]</code> chain that starts at <code>myObject</code>, this is called <em>shadowing</em>. The <code>foo</code> property directly on <code>myObject</code> <em>shadows</em> any <code>foo</code> property which appears higher in the chain, because the <code>myObject.foo</code> look-up would always find the <code>foo</code> property that's lowest in the chain.</p>
<p>As we just hinted, shadowing <code>foo</code> on <code>myObject</code> is not as simple as it may seem. We will now examine three scenarios for the <code>myObject.foo = &quot;bar&quot;</code> assignment when <code>foo</code> is <strong>not</strong> already on <code>myObject</code> directly, but <strong>is</strong> at a higher level of <code>myObject</code>'s <code>[[Prototype]]</code> chain:</p>
<ol type="1">
<li>If a normal data accessor (see Chapter 3) property named <code>foo</code> is found anywhere higher on the <code>[[Prototype]]</code> chain, <strong>and it's not marked as read-only (<code>writable:false</code>)</strong> then a new property called <code>foo</code> is added directly to <code>myObject</code>, resulting in a <strong>shadowed property</strong>.</li>
<li>If a <code>foo</code> is found higher on the <code>[[Prototype]]</code> chain, but it's marked as <strong>read-only (<code>writable:false</code>)</strong>, then both the setting of that existing property as well as the creation of the shadowed property on <code>myObject</code> <strong>are disallowed</strong>. If the code is running in <code>strict mode</code>, an error will be thrown. Otherwise, the setting of the property value will silently be ignored. Either way, <strong>no shadowing occurs</strong>.</li>
<li>If a <code>foo</code> is found higher on the <code>[[Prototype]]</code> chain and it's a setter (see Chapter 3), then the setter will always be called. No <code>foo</code> will be added to (aka, shadowed on) <code>myObject</code>, nor will the <code>foo</code> setter be redefined.</li>
</ol>
<p>Most developers assume that assignment of a property (<code>[[Put]]</code>) will always result in shadowing if the property already exists higher on the <code>[[Prototype]]</code> chain, but as you can see, that's only true in one (#1) of the three situations just described.</p>
<p>If you want to shadow <code>foo</code> in cases #2 and #3, you cannot use <code>=</code> assignment, but must instead use <code>Object.defineProperty(..)</code> (see Chapter 3) to add <code>foo</code> to <code>myObject</code>.</p>
<p><strong>Note:</strong> Case #2 may be the most surprising of the three. The presence of a <em>read-only</em> property prevents a property of the same name being implicitly created (shadowed) at a lower level of a <code>[[Prototype]]</code> chain. The reason for this restriction is primarily to reinforce the illusion of class-inherited properties. If you think of the <code>foo</code> at a higher level of the chain as having been inherited (copied down) to <code>myObject</code>, then it makes sense to enforce the non-writable nature of that <code>foo</code> property on <code>myObject</code>. If you however separate the illusion from the fact, and recognize that no such inheritance copying <em>actually</em> occurred (see Chapters 4 and 5), it's a little unnatural that <code>myObject</code> would be prevented from having a <code>foo</code> property just because some other object had a non-writable <code>foo</code> on it. It's even stranger that this restriction only applies to <code>=</code> assignment, but is not enforced when using <code>Object.defineProperty(..)</code>.</p>
<p>Shadowing with <strong>methods</strong> leads to ugly <em>explicit pseudo-polymorphism</em> (see Chapter 4) if you need to delegate between them. Usually, shadowing is more complicated and nuanced than it's worth, <strong>so you should try to avoid it if possible</strong>. See Chapter 6 for an alternative design pattern, which among other things discourages shadowing in favor of cleaner alternatives.</p>
<p>Shadowing can even occur implicitly in subtle ways, so care must be taken if trying to avoid it. Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> anotherObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="kw">var</span> myObject <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( anotherObject )<span class="op">;</span>

<span class="va">anotherObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span>
<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span>

<span class="va">anotherObject</span>.<span class="at">hasOwnProperty</span>( <span class="st">&quot;a&quot;</span> )<span class="op">;</span> <span class="co">// true</span>
<span class="va">myObject</span>.<span class="at">hasOwnProperty</span>( <span class="st">&quot;a&quot;</span> )<span class="op">;</span> <span class="co">// false</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">++;</span> <span class="co">// oops, implicit shadowing!</span>

<span class="va">anotherObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span>
<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 3</span>

<span class="va">myObject</span>.<span class="at">hasOwnProperty</span>( <span class="st">&quot;a&quot;</span> )<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>Though it may appear that <code>myObject.a++</code> should (via delegation) look-up and just increment the <code>anotherObject.a</code> property itself <em>in place</em>, instead the <code>++</code> operation corresponds to <code>myObject.a = myObject.a + 1</code>. The result is <code>[[Get]]</code> looking up <code>a</code> property via <code>[[Prototype]]</code> to get the current value <code>2</code> from <code>anotherObject.a</code>, incrementing the value by one, then <code>[[Put]]</code> assigning the <code>3</code> value to a new shadowed property <code>a</code> on <code>myObject</code>. Oops!</p>
<p>Be very careful when dealing with delegated properties that you modify. If you wanted to increment <code>anotherObject.a</code>, the only proper way is <code>anotherObject.a++</code>.</p>
<h2 id="class">&quot;Class&quot;</h2>
<p>At this point, you might be wondering: &quot;<em>Why</em> does one object need to link to another object?&quot; What's the real benefit? That is a very appropriate question to ask, but we must first understand what <code>[[Prototype]]</code> is <strong>not</strong> before we can fully understand and appreciate what it <em>is</em> and how it's useful.</p>
<p>As we explained in Chapter 4, in JavaScript, there are no abstract patterns/blueprints for objects called &quot;classes&quot; as there are in class-oriented languages. JavaScript <strong>just</strong> has objects.</p>
<p>In fact, JavaScript is <strong>almost unique</strong> among languages as perhaps the only language with the right to use the label &quot;object oriented&quot;, because it's one of a very short list of languages where an object can be created directly, without a class at all.</p>
<p>In JavaScript, classes can't (being that they don't exist!) describe what an object can do. The object defines its own behavior directly. <strong>There's <em>just</em> the object.</strong></p>
<h3 id="class-functions">&quot;Class&quot; Functions</h3>
<p>There's a peculiar kind of behavior in JavaScript that has been shamelessly abused for years to <em>hack</em> something that <em>looks</em> like &quot;classes&quot;. We'll examine this approach in detail.</p>
<p>The peculiar &quot;sort-of class&quot; behavior hinges on a strange characteristic of functions: all functions by default get a public, non-enumerable (see Chapter 3) property on them called <code>prototype</code>, which points at an otherwise arbitrary object.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Foo</span>() <span class="op">{</span>
    <span class="co">// ...</span>
<span class="op">}</span>

<span class="va">Foo</span>.<span class="at">prototype</span><span class="op">;</span> <span class="co">// { }</span></code></pre></div>
<p>This object is often called &quot;Foo's prototype&quot;, because we access it via an unfortunately-named <code>Foo.prototype</code> property reference. However, that terminology is hopelessly destined to lead us into confusion, as we'll see shortly. Instead, I will call it &quot;the object formerly known as Foo's prototype&quot;. Just kidding. How about: &quot;object arbitrarily labeled 'Foo dot prototype'&quot;?</p>
<p>Whatever we call it, what exactly is this object?</p>
<p>The most direct way to explain it is that each object created from calling <code>new Foo()</code> (see Chapter 2) will end up (somewhat arbitrarily) <code>[[Prototype]]</code>-linked to this &quot;Foo dot prototype&quot; object.</p>
<p>Let's illustrate:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Foo</span>() <span class="op">{</span>
    <span class="co">// ...</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Foo</span>()<span class="op">;</span>

<span class="va">Object</span>.<span class="at">getPrototypeOf</span>( a ) <span class="op">===</span> <span class="va">Foo</span>.<span class="at">prototype</span><span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>When <code>a</code> is created by calling <code>new Foo()</code>, one of the things (see Chapter 2 for all <em>four</em> steps) that happens is that <code>a</code> gets an internal <code>[[Prototype]]</code> link to the object that <code>Foo.prototype</code> is pointing at.</p>
<p>Stop for a moment and ponder the implications of that statement.</p>
<p>In class-oriented languages, multiple <strong>copies</strong> (aka, &quot;instances&quot;) of a class can be made, like stamping something out from a mold. As we saw in Chapter 4, this happens because the process of instantiating (or inheriting from) a class means, &quot;copy the behavior plan from that class into a physical object&quot;, and this is done again for each new instance.</p>
<p>But in JavaScript, there are no such copy-actions performed. You don't create multiple instances of a class. You can create multiple objects that <code>[[Prototype]]</code> <em>link</em> to a common object. But by default, no copying occurs, and thus these objects don't end up totally separate and disconnected from each other, but rather, quite <strong><em>linked</em></strong>.</p>
<p><code>new Foo()</code> results in a new object (we called it <code>a</code>), and <strong>that</strong> new object <code>a</code> is internally <code>[[Prototype]]</code> linked to the <code>Foo.prototype</code> object.</p>
<p><strong>We end up with two objects, linked to each other.</strong> That's <em>it</em>. We didn't instantiate a class. We certainly didn't do any copying of behavior from a &quot;class&quot; into a concrete object. We just caused two objects to be linked to each other.</p>
<p>In fact, the secret, which eludes most JS developers, is that the <code>new Foo()</code> function calling had really almost nothing <em>direct</em> to do with the process of creating the link. <strong>It was sort of an accidental side-effect.</strong> <code>new Foo()</code> is an indirect, round-about way to end up with what we want: <strong>a new object linked to another object</strong>.</p>
<p>Can we get what we want in a more <em>direct</em> way? <strong>Yes!</strong> The hero is <code>Object.create(..)</code>. But we'll get to that in a little bit.</p>
<h4 id="whats-in-a-name">What's in a name?</h4>
<p>In JavaScript, we don't make <em>copies</em> from one object (&quot;class&quot;) to another (&quot;instance&quot;). We make <em>links</em> between objects. For the <code>[[Prototype]]</code> mechanism, visually, the arrows move from right to left, and from bottom to top.</p>
<p><img src="fig3.png"/></p>
<p>This mechanism is often called &quot;prototypal inheritance&quot; (we'll explore the code in detail shortly), which is commonly said to be the dynamic-language version of &quot;classical inheritance&quot;. It's an attempt to piggy-back on the common understanding of what &quot;inheritance&quot; means in the class-oriented world, but <em>tweak</em> (<strong>read: pave over</strong>) the understood semantics, to fit dynamic scripting.</p>
<p>The word &quot;inheritance&quot; has a very strong meaning (see Chapter 4), with plenty of mental precedent. Merely adding &quot;prototypal&quot; in front to distinguish the <em>actually nearly opposite</em> behavior in JavaScript has left in its wake nearly two decades of miry confusion.</p>
<p>I like to say that sticking &quot;prototypal&quot; in front &quot;inheritance&quot; to drastically reverse its actual meaning is like holding an orange in one hand, an apple in the other, and insisting on calling the apple a &quot;red orange&quot;. No matter what confusing label I put in front of it, that doesn't change the <em>fact</em> that one fruit is an apple and the other is an orange.</p>
<p>The better approach is to plainly call an apple an apple -- to use the most accurate and direct terminology. That makes it easier to understand both their similarities and their <strong>many differences</strong>, because we all have a simple, shared understanding of what &quot;apple&quot; means.</p>
<p>Because of the confusion and conflation of terms, I believe the label &quot;prototypal inheritance&quot; itself (and trying to mis-apply all its associated class-orientation terminology, like &quot;class&quot;, &quot;constructor&quot;, &quot;instance&quot;, &quot;polymorphism&quot;, etc) has done <strong>more harm than good</strong> in explaining how JavaScript's mechanism <em>really</em> works.</p>
<p>&quot;Inheritance&quot; implies a <em>copy</em> operation, and JavaScript doesn't copy object properties (natively, by default). Instead, JS creates a link between two objects, where one object can essentially <em>delegate</em> property/function access to another object. &quot;Delegation&quot; (see Chapter 6) is a much more accurate term for JavaScript's object-linking mechanism.</p>
<p>Another term which is sometimes thrown around in JavaScript is &quot;differential inheritance&quot;. The idea here is that we describe an object's behavior in terms of what is <em>different</em> from a more general descriptor. For example, you explain that a car is a kind of vehicle, but one that has exactly 4 wheels, rather than re-describing all the specifics of what makes up a general vehicle (engine, etc).</p>
<p>If you try to think of any given object in JS as the sum total of all behavior that is <em>available</em> via delegation, and <strong>in your mind you flatten</strong> all that behavior into one tangible <em>thing</em>, then you can (sorta) see how &quot;differential inheritance&quot; might fit.</p>
<p>But just like with &quot;prototypal inheritance&quot;, &quot;differential inheritance&quot; pretends that your mental model is more important than what is physically happening in the language. It overlooks the fact that object <code>B</code> is not actually differentially constructed, but is instead built with specific characteristics defined, alongside &quot;holes&quot; where nothing is defined. It is in these &quot;holes&quot; (gaps in, or lack of, definition) that delegation <em>can</em> take over and, on the fly, &quot;fill them in&quot; with delegated behavior.</p>
<p>The object is not, by native default, flattened into the single differential object, <strong>through copying</strong>, that the mental model of &quot;differential inheritance&quot; implies. As such, &quot;differential inheritance&quot; is just not as natural a fit for describing how JavaScript's <code>[[Prototype]]</code> mechanism actually works.</p>
<p>You <em>can choose</em> to prefer the &quot;differential inheritance&quot; terminology and mental model, as a matter of taste, but there's no denying the fact that it <em>only</em> fits the mental acrobatics in your mind, not the physical behavior in the engine.</p>
<h3 id="constructors">&quot;Constructors&quot;</h3>
<p>Let's go back to some earlier code:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Foo</span>() <span class="op">{</span>
    <span class="co">// ...</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Foo</span>()<span class="op">;</span></code></pre></div>
<p>What exactly leads us to think <code>Foo</code> is a &quot;class&quot;?</p>
<p>For one, we see the use of the <code>new</code> keyword, just like class-oriented languages do when they construct class instances. For another, it appears that we are in fact executing a <em>constructor</em> method of a class, because <code>Foo()</code> is actually a method that gets called, just like how a real class's constructor gets called when you instantiate that class.</p>
<p>To further the confusion of &quot;constructor&quot; semantics, the arbitrarily labeled <code>Foo.prototype</code> object has another trick up its sleeve. Consider this code:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Foo</span>() <span class="op">{</span>
    <span class="co">// ...</span>
<span class="op">}</span>

<span class="va">Foo</span>.<span class="va">prototype</span>.<span class="at">constructor</span> <span class="op">===</span> Foo<span class="op">;</span> <span class="co">// true</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Foo</span>()<span class="op">;</span>
<span class="va">a</span>.<span class="at">constructor</span> <span class="op">===</span> Foo<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>The <code>Foo.prototype</code> object by default (at declaration time on line 1 of the snippet!) gets a public, non-enumerable (see Chapter 3) property called <code>.constructor</code>, and this property is a reference back to the function (<code>Foo</code> in this case) that the object is associated with. Moreover, we see that object <code>a</code> created by the &quot;constructor&quot; call <code>new Foo()</code> <em>seems</em> to also have a property on it called <code>.constructor</code> which similarly points to &quot;the function which created it&quot;.</p>
<p><strong>Note:</strong> This is not actually true. <code>a</code> has no <code>.constructor</code> property on it, and though <code>a.constructor</code> does in fact resolve to the <code>Foo</code> function, &quot;constructor&quot; <strong>does not actually mean</strong> &quot;was constructed by&quot;, as it appears. We'll explain this strangeness shortly.</p>
<p>Oh, yeah, also... by convention in the JavaScript world, &quot;class&quot;es are named with a capital letter, so the fact that it's <code>Foo</code> instead of <code>foo</code> is a strong clue that we intend it to be a &quot;class&quot;. That's totally obvious to you, right!?</p>
<p><strong>Note:</strong> This convention is so strong that many JS linters actually <em>complain</em> if you call <code>new</code> on a method with a lowercase name, or if we don't call <code>new</code> on a function that happens to start with a capital letter. That sort of boggles the mind that we struggle so much to get (fake) &quot;class-orientation&quot; <em>right</em> in JavaScript that we create linter rules to ensure we use capital letters, even though the capital letter doesn't mean <strong><em>anything</em> at all</strong> to the JS engine.</p>
<h4 id="constructor-or-call">Constructor Or Call?</h4>
<p>In the above snippet, it's tempting to think that <code>Foo</code> is a &quot;constructor&quot;, because we call it with <code>new</code> and we observe that it &quot;constructs&quot; an object.</p>
<p>In reality, <code>Foo</code> is no more a &quot;constructor&quot; than any other function in your program. Functions themselves are <strong>not</strong> constructors. However, when you put the <code>new</code> keyword in front of a normal function call, that makes that function call a &quot;constructor call&quot;. In fact, <code>new</code> sort of hijacks any normal function and calls it in a fashion that constructs an object, <strong>in addition to whatever else it was going to do</strong>.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">NothingSpecial</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Don&#39;t mind me!&quot;</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">NothingSpecial</span>()<span class="op">;</span>
<span class="co">// &quot;Don&#39;t mind me!&quot;</span>

a<span class="op">;</span> <span class="co">// {}</span></code></pre></div>
<p><code>NothingSpecial</code> is just a plain old normal function, but when called with <code>new</code>, it <em>constructs</em> an object, almost as a side-effect, which we happen to assign to <code>a</code>. The <strong>call</strong> was a <em>constructor call</em>, but <code>NothingSpecial</code> is not, in and of itself, a <em>constructor</em>.</p>
<p>In other words, in JavaScript, it's most appropriate to say that a &quot;constructor&quot; is <strong>any function called with the <code>new</code> keyword</strong> in front of it.</p>
<p>Functions aren't constructors, but function calls are &quot;constructor calls&quot; if and only if <code>new</code> is used.</p>
<h3 id="mechanics">Mechanics</h3>
<p>Are <em>those</em> the only common triggers for ill-fated &quot;class&quot; discussions in JavaScript?</p>
<p><strong>Not quite.</strong> JS developers have strived to simulate as much as they can of class-orientation:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Foo</span>(name) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> name<span class="op">;</span>
<span class="op">}</span>

<span class="va">Foo</span>.<span class="va">prototype</span>.<span class="at">myName</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">name</span><span class="op">;</span>
<span class="op">};</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Foo</span>( <span class="st">&quot;a&quot;</span> )<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="kw">new</span> <span class="at">Foo</span>( <span class="st">&quot;b&quot;</span> )<span class="op">;</span>

<span class="va">a</span>.<span class="at">myName</span>()<span class="op">;</span> <span class="co">// &quot;a&quot;</span>
<span class="va">b</span>.<span class="at">myName</span>()<span class="op">;</span> <span class="co">// &quot;b&quot;</span></code></pre></div>
<p>This snippet shows two additional &quot;class-orientation&quot; tricks in play:</p>
<ol type="1">
<li><p><code>this.name = name</code>: adds the <code>.name</code> property onto each object (<code>a</code> and <code>b</code>, respectively; see Chapter 2 about <code>this</code> binding), similar to how class instances encapsulate data values.</p></li>
<li><p><code>Foo.prototype.myName = ...</code>: perhaps the more interesting technique, this adds a property (function) to the <code>Foo.prototype</code> object. Now, <code>a.myName()</code> works, but perhaps surprisingly. How?</p></li>
</ol>
<p>In the above snippet, it's strongly tempting to think that when <code>a</code> and <code>b</code> are created, the properties/functions on the <code>Foo.prototype</code> object are <em>copied</em> over to each of <code>a</code> and <code>b</code> objects. <strong>However, that's not what happens.</strong></p>
<p>At the beginning of this chapter, we explained the <code>[[Prototype]]</code> link, and how it provides the fall-back look-up steps if a property reference isn't found directly on an object, as part of the default <code>[[Get]]</code> algorithm.</p>
<p>So, by virtue of how they are created, <code>a</code> and <code>b</code> each end up with an internal <code>[[Prototype]]</code> linkage to <code>Foo.prototype</code>. When <code>myName</code> is not found on <code>a</code> or <code>b</code>, respectively, it's instead found (through delegation, see Chapter 6) on <code>Foo.prototype</code>.</p>
<h4 id="constructor-redux">&quot;Constructor&quot; Redux</h4>
<p>Recall the discussion from earlier about the <code>.constructor</code> property, and how it <em>seems</em> like <code>a.constructor === Foo</code> being true means that <code>a</code> has an actual <code>.constructor</code> property on it, pointing at <code>Foo</code>? <strong>Not correct.</strong></p>
<p>This is just unfortunate confusion. In actuality, the <code>.constructor</code> reference is also <em>delegated</em> up to <code>Foo.prototype</code>, which <strong>happens to</strong>, by default, have a <code>.constructor</code> that points at <code>Foo</code>.</p>
<p>It <em>seems</em> awfully convenient that an object <code>a</code> &quot;constructed by&quot; <code>Foo</code> would have access to a <code>.constructor</code> property that points to <code>Foo</code>. But that's nothing more than a false sense of security. It's a happy accident, almost tangentially, that <code>a.constructor</code> <em>happens</em> to point at <code>Foo</code> via this default <code>[[Prototype]]</code> delegation. There's actually several ways that the ill-fated assumption of <code>.constructor</code> meaning &quot;was constructed by&quot; can come back to bite you.</p>
<p>For one, the <code>.constructor</code> property on <code>Foo.prototype</code> is only there by default on the object created when <code>Foo</code> the function is declared. If you create a new object, and replace a function's default <code>.prototype</code> object reference, the new object will not by default magically get a <code>.constructor</code> on it.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Foo</span>() <span class="op">{</span> <span class="co">/* .. */</span> <span class="op">}</span>

<span class="va">Foo</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="op">{</span> <span class="co">/* .. */</span> <span class="op">};</span> <span class="co">// create a new prototype object</span>

<span class="kw">var</span> a1 <span class="op">=</span> <span class="kw">new</span> <span class="at">Foo</span>()<span class="op">;</span>
<span class="va">a1</span>.<span class="at">constructor</span> <span class="op">===</span> Foo<span class="op">;</span> <span class="co">// false!</span>
<span class="va">a1</span>.<span class="at">constructor</span> <span class="op">===</span> Object<span class="op">;</span> <span class="co">// true!</span></code></pre></div>
<p><code>Object(..)</code> didn't &quot;construct&quot; <code>a1</code> did it? It sure seems like <code>Foo()</code> &quot;constructed&quot; it. Many developers think of <code>Foo()</code> as doing the construction, but where everything falls apart is when you think &quot;constructor&quot; means &quot;was constructed by&quot;, because by that reasoning, <code>a1.constructor</code> should be <code>Foo</code>, but it isn't!</p>
<p>What's happening? <code>a1</code> has no <code>.constructor</code> property, so it delegates up the <code>[[Prototype]]</code> chain to <code>Foo.prototype</code>. But that object doesn't have a <code>.constructor</code> either (like the default <code>Foo.prototype</code> object would have had!), so it keeps delegating, this time up to <code>Object.prototype</code>, the top of the delegation chain. <em>That</em> object indeed has a <code>.constructor</code> on it, which points to the built-in <code>Object(..)</code> function.</p>
<p><strong>Misconception, busted.</strong></p>
<p>Of course, you can add <code>.constructor</code> back to the <code>Foo.prototype</code> object, but this takes manual work, especially if you want to match native behavior and have it be non-enumerable (see Chapter 3).</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Foo</span>() <span class="op">{</span> <span class="co">/* .. */</span> <span class="op">}</span>

<span class="va">Foo</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="op">{</span> <span class="co">/* .. */</span> <span class="op">};</span> <span class="co">// create a new prototype object</span>

<span class="co">// Need to properly &quot;fix&quot; the missing `.constructor`</span>
<span class="co">// property on the new object serving as `Foo.prototype`.</span>
<span class="co">// See Chapter 3 for `defineProperty(..)`.</span>
<span class="va">Object</span>.<span class="at">defineProperty</span>( <span class="va">Foo</span>.<span class="at">prototype</span><span class="op">,</span> <span class="st">&quot;constructor&quot;</span> <span class="op">,</span> <span class="op">{</span>
    <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
    <span class="dt">writable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">configurable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">value</span><span class="op">:</span> Foo    <span class="co">// point `.constructor` at `Foo`</span>
<span class="op">}</span> )<span class="op">;</span></code></pre></div>
<p>That's a lot of manual work to fix <code>.constructor</code>. Moreover, all we're really doing is perpetuating the misconception that &quot;constructor&quot; means &quot;was constructed by&quot;. That's an <em>expensive</em> illusion.</p>
<p>The fact is, <code>.constructor</code> on an object arbitrarily points, by default, at a function who, reciprocally, has a reference back to the object -- a reference which it calls <code>.prototype</code>. The words &quot;constructor&quot; and &quot;prototype&quot; only have a loose default meaning that might or might not hold true later. The best thing to do is remind yourself, &quot;constructor does not mean constructed by&quot;.</p>
<p><code>.constructor</code> is not a magic immutable property. It <em>is</em> non-enumerable (see snippet above), but its value is writable (can be changed), and moreover, you can add or overwrite (intentionally or accidentally) a property of the name <code>constructor</code> on any object in any <code>[[Prototype]]</code> chain, with any value you see fit.</p>
<p>By virtue of how the <code>[[Get]]</code> algorithm traverses the <code>[[Prototype]]</code> chain, a <code>.constructor</code> property reference found anywhere may resolve quite differently than you'd expect.</p>
<p>See how arbitrary its meaning actually is?</p>
<p>The result? Some arbitrary object-property reference like <code>a1.constructor</code> cannot actually be <em>trusted</em> to be the assumed default function reference. Moreover, as we'll see shortly, just by simple omission, <code>a1.constructor</code> can even end up pointing somewhere quite surprising and insensible.</p>
<p><code>.constructor</code> is extremely unreliable, and an unsafe reference to rely upon in your code. <strong>Generally, such references should be avoided where possible.</strong></p>
<h2 id="prototypal-inheritance">&quot;(Prototypal) Inheritance&quot;</h2>
<p>We've seen some approximations of &quot;class&quot; mechanics as typically hacked into JavaScript programs. But JavaScript &quot;class&quot;es would be rather hollow if we didn't have an approximation of &quot;inheritance&quot;.</p>
<p>Actually, we've already seen the mechanism which is commonly called &quot;prototypal inheritance&quot; at work when <code>a</code> was able to &quot;inherit from&quot; <code>Foo.prototype</code>, and thus get access to the <code>myName()</code> function. But we traditionally think of &quot;inheritance&quot; as being a relationship between two &quot;classes&quot;, rather than between &quot;class&quot; and &quot;instance&quot;.</p>
<p><img src="fig3.png"/></p>
<p>Recall this figure from earlier, which shows not only delegation from an object (aka, &quot;instance&quot;) <code>a1</code> to object <code>Foo.prototype</code>, but from <code>Bar.prototype</code> to <code>Foo.prototype</code>, which somewhat resembles the concept of Parent-Child class inheritance. <em>Resembles</em>, except of course for the direction of the arrows, which show these are delegation links rather than copy operations.</p>
<p>And, here's the typical &quot;prototype style&quot; code that creates such links:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Foo</span>(name) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> name<span class="op">;</span>
<span class="op">}</span>

<span class="va">Foo</span>.<span class="va">prototype</span>.<span class="at">myName</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">name</span><span class="op">;</span>
<span class="op">};</span>

<span class="kw">function</span> <span class="at">Bar</span>(name<span class="op">,</span>label) <span class="op">{</span>
    <span class="va">Foo</span>.<span class="at">call</span>( <span class="kw">this</span><span class="op">,</span> name )<span class="op">;</span>
    <span class="kw">this</span>.<span class="at">label</span> <span class="op">=</span> label<span class="op">;</span>
<span class="op">}</span>

<span class="co">// here, we make a new `Bar.prototype`</span>
<span class="co">// linked to `Foo.prototype`</span>
<span class="va">Bar</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( <span class="va">Foo</span>.<span class="at">prototype</span> )<span class="op">;</span>

<span class="co">// Beware! Now `Bar.prototype.constructor` is gone,</span>
<span class="co">// and might need to be manually &quot;fixed&quot; if you&#39;re</span>
<span class="co">// in the habit of relying on such properties!</span>

<span class="va">Bar</span>.<span class="va">prototype</span>.<span class="at">myLabel</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">label</span><span class="op">;</span>
<span class="op">};</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Bar</span>( <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;obj a&quot;</span> )<span class="op">;</span>

<span class="va">a</span>.<span class="at">myName</span>()<span class="op">;</span> <span class="co">// &quot;a&quot;</span>
<span class="va">a</span>.<span class="at">myLabel</span>()<span class="op">;</span> <span class="co">// &quot;obj a&quot;</span></code></pre></div>
<p><strong>Note:</strong> To understand why <code>this</code> points to <code>a</code> in the above code snippet, see Chapter 2.</p>
<p>The important part is <code>Bar.prototype = Object.create( Foo.prototype )</code>. <code>Object.create(..)</code> <em>creates</em> a &quot;new&quot; object out of thin air, and links that new object's internal <code>[[Prototype]]</code> to the object you specify (<code>Foo.prototype</code> in this case).</p>
<p>In other words, that line says: &quot;make a <em>new</em> 'Bar dot prototype' object that's linked to 'Foo dot prototype'.&quot;</p>
<p>When <code>function Bar() { .. }</code> is declared, <code>Bar</code>, like any other function, has a <code>.prototype</code> link to its default object. But <em>that</em> object is not linked to <code>Foo.prototype</code> like we want. So, we create a <em>new</em> object that <em>is</em> linked as we want, effectively throwing away the original incorrectly-linked object.</p>
<p><strong>Note:</strong> A common mis-conception/confusion here is that either of the following approaches would <em>also</em> work, but they do not work as you'd expect:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// doesn&#39;t work like you want!</span>
<span class="va">Bar</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Foo</span>.<span class="at">prototype</span><span class="op">;</span>

<span class="co">// works kinda like you want, but with</span>
<span class="co">// side-effects you probably don&#39;t want :(</span>
<span class="va">Bar</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">Foo</span>()<span class="op">;</span></code></pre></div>
<p><code>Bar.prototype = Foo.prototype</code> doesn't create a new object for <code>Bar.prototype</code> to be linked to. It just makes <code>Bar.prototype</code> be another reference to <code>Foo.prototype</code>, which effectively links <code>Bar</code> directly to <strong>the same object as</strong> <code>Foo</code> links to: <code>Foo.prototype</code>. This means when you start assigning, like <code>Bar.prototype.myLabel = ...</code>, you're modifying <strong>not a separate object</strong> but <em>the</em> shared <code>Foo.prototype</code> object itself, which would affect any objects linked to <code>Foo.prototype</code>. This is almost certainly not what you want. If it <em>is</em> what you want, then you likely don't need <code>Bar</code> at all, and should just use only <code>Foo</code> and make your code simpler.</p>
<p><code>Bar.prototype = new Foo()</code> <strong>does in fact</strong> create a new object which is duly linked to <code>Foo.prototype</code> as we'd want. But, it uses the <code>Foo(..)</code> &quot;constructor call&quot; to do it. If that function has any side-effects (such as logging, changing state, registering against other objects, <strong>adding data properties to <code>this</code></strong>, etc.), those side-effects happen at the time of this linking (and likely against the wrong object!), rather than only when the eventual <code>Bar()</code> &quot;descendants&quot; are created, as would likely be expected.</p>
<p>So, we're left with using <code>Object.create(..)</code> to make a new object that's properly linked, but without having the side-effects of calling <code>Foo(..)</code>. The slight downside is that we have to create a new object, throwing the old one away, instead of modifying the existing default object we're provided.</p>
<p>It would be <em>nice</em> if there was a standard and reliable way to modify the linkage of an existing object. Prior to ES6, there's a non-standard and not fully-cross-browser way, via the <code>.__proto__</code> property, which is settable. ES6 adds a <code>Object.setPrototypeOf(..)</code> helper utility, which does the trick in a standard and predictable way.</p>
<p>Compare the pre-ES6 and ES6-standardized techniques for linking <code>Bar.prototype</code> to <code>Foo.prototype</code>, side-by-side:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// pre-ES6</span>
<span class="co">// throws away default existing `Bar.prototype`</span>
<span class="va">Bar</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( <span class="va">Foo</span>.<span class="at">prototype</span> )<span class="op">;</span>

<span class="co">// ES6+</span>
<span class="co">// modifies existing `Bar.prototype`</span>
<span class="va">Object</span>.<span class="at">setPrototypeOf</span>( <span class="va">Bar</span>.<span class="at">prototype</span><span class="op">,</span> <span class="va">Foo</span>.<span class="at">prototype</span> )<span class="op">;</span></code></pre></div>
<p>Ignoring the slight performance disadvantage (throwing away an object that's later garbage collected) of the <code>Object.create(..)</code> approach, it's a little bit shorter and may be perhaps a little easier to read than the ES6+ approach. But it's probably a syntactic wash either way.</p>
<h3 id="inspecting-class-relationships">Inspecting &quot;Class&quot; Relationships</h3>
<p>What if you have an object like <code>a</code> and want to find out what object (if any) it delegates to? Inspecting an instance (just an object in JS) for its inheritance ancestry (delegation linkage in JS) is often called <em>introspection</em> (or <em>reflection</em>) in traditional class-oriented environments.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Foo</span>() <span class="op">{</span>
    <span class="co">// ...</span>
<span class="op">}</span>

<span class="va">Foo</span>.<span class="va">prototype</span>.<span class="at">blah</span> <span class="op">=</span> ...<span class="op">;</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Foo</span>()<span class="op">;</span></code></pre></div>
<p>How do we then introspect <code>a</code> to find out its &quot;ancestry&quot; (delegation linkage)? The first approach embraces the &quot;class&quot; confusion:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">a <span class="kw">instanceof</span> Foo<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>The <code>instanceof</code> operator takes a plain object as its left-hand operand and a <strong>function</strong> as its right-hand operand. The question <code>instanceof</code> answers is: <strong>in the entire <code>[[Prototype]]</code> chain of <code>a</code>, does the object arbitrarily pointed to by <code>Foo.prototype</code> ever appear?</strong></p>
<p>Unfortunately, this means that you can only inquire about the &quot;ancestry&quot; of some object (<code>a</code>) if you have some <strong>function</strong> (<code>Foo</code>, with its attached <code>.prototype</code> reference) to test with. If you have two arbitrary objects, say <code>a</code> and <code>b</code>, and want to find out if <em>the objects</em> are related to each other through a <code>[[Prototype]]</code> chain, <code>instanceof</code> alone can't help.</p>
<p><strong>Note:</strong> If you use the built-in <code>.bind(..)</code> utility to make a hard-bound function (see Chapter 2), the function created will not have a <code>.prototype</code> property. Using <code>instanceof</code> with such a function transparently substitutes the <code>.prototype</code> of the <em>target function</em> that the hard-bound function was created from.</p>
<p>It's fairly uncommon to use hard-bound functions as &quot;constructor calls&quot;, but if you do, it will behave as if the original <em>target function</em> was invoked instead, which means that using <code>instanceof</code> with a hard-bound function also behaves according to the original function.</p>
<p>This snippet illustrates the ridiculousness of trying to reason about relationships between <strong>two objects</strong> using &quot;class&quot; semantics and <code>instanceof</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// helper utility to see if `o1` is</span>
<span class="co">// related to (delegates to) `o2`</span>
<span class="kw">function</span> <span class="at">isRelatedTo</span>(o1<span class="op">,</span> o2) <span class="op">{</span>
    <span class="kw">function</span> <span class="at">F</span>()<span class="op">{}</span>
    <span class="va">F</span>.<span class="at">prototype</span> <span class="op">=</span> o2<span class="op">;</span>
    <span class="cf">return</span> o1 <span class="kw">instanceof</span> F<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="op">{};</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( a )<span class="op">;</span>

<span class="at">isRelatedTo</span>( b<span class="op">,</span> a )<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>Inside <code>isRelatedTo(..)</code>, we borrow a throw-away function <code>F</code>, reassign its <code>.prototype</code> to arbitrarily point to some object <code>o2</code>, then ask if <code>o1</code> is an &quot;instance of&quot; <code>F</code>. Obviously <code>o1</code> isn't <em>actually</em> inherited or descended or even constructed from <code>F</code>, so it should be clear why this kind of exercise is silly and confusing. <strong>The problem comes down to the awkwardness of class semantics forced upon JavaScript</strong>, in this case as revealed by the indirect semantics of <code>instanceof</code>.</p>
<p>The second, and much cleaner, approach to <code>[[Prototype]]</code> reflection is:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Foo</span>.<span class="va">prototype</span>.<span class="at">isPrototypeOf</span>( a )<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>Notice that in this case, we don't really care about (or even <em>need</em>) <code>Foo</code>, we just need an <strong>object</strong> (in our case, arbitrarily labeled <code>Foo.prototype</code>) to test against another <strong>object</strong>. The question <code>isPrototypeOf(..)</code> answers is: <strong>in the entire <code>[[Prototype]]</code> chain of <code>a</code>, does <code>Foo.prototype</code> ever appear?</strong></p>
<p>Same question, and exact same answer. But in this second approach, we don't actually need the indirection of referencing a <strong>function</strong> (<code>Foo</code>) whose <code>.prototype</code> property will automatically be consulted.</p>
<p>We <em>just need</em> two <strong>objects</strong> to inspect a relationship between them. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Simply: does `b` appear anywhere in</span>
<span class="co">// `c`s [[Prototype]] chain?</span>
<span class="va">b</span>.<span class="at">isPrototypeOf</span>( c )<span class="op">;</span></code></pre></div>
<p>Notice, this approach doesn't require a function (&quot;class&quot;) at all. It just uses object references directly to <code>b</code> and <code>c</code>, and inquires about their relationship. In other words, our <code>isRelatedTo(..)</code> utility above is built-in to the language, and it's called <code>isPrototypeOf(..)</code>.</p>
<p>We can also directly retrieve the <code>[[Prototype]]</code> of an object. As of ES5, the standard way to do this is:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">getPrototypeOf</span>( a )<span class="op">;</span></code></pre></div>
<p>And you'll notice that object reference is what we'd expect:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">getPrototypeOf</span>( a ) <span class="op">===</span> <span class="va">Foo</span>.<span class="at">prototype</span><span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>Most browsers (not all!) have also long supported a non-standard alternate way of accessing the internal <code>[[Prototype]]</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">a</span>.<span class="at">__proto__</span> <span class="op">===</span> <span class="va">Foo</span>.<span class="at">prototype</span><span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>The strange <code>.__proto__</code> (not standardized until ES6!) property &quot;magically&quot; retrieves the internal <code>[[Prototype]]</code> of an object as a reference, which is quite helpful if you want to directly inspect (or even traverse: <code>.__proto__.__proto__...</code>) the chain.</p>
<p>Just as we saw earlier with <code>.constructor</code>, <code>.__proto__</code> doesn't actually exist on the object you're inspecting (<code>a</code> in our running example). In fact, it exists (non-enumerable; see Chapter 2) on the built-in <code>Object.prototype</code>, along with the other common utilities (<code>.toString()</code>, <code>.isPrototypeOf(..)</code>, etc).</p>
<p>Moreover, <code>.__proto__</code> looks like a property, but it's actually more appropriate to think of it as a getter/setter (see Chapter 3).</p>
<p>Roughly, we could envision <code>.__proto__</code> implemented (see Chapter 3 for object property definitions) like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">defineProperty</span>( <span class="va">Object</span>.<span class="at">prototype</span><span class="op">,</span> <span class="st">&quot;__proto__&quot;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">get</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="va">Object</span>.<span class="at">getPrototypeOf</span>( <span class="kw">this</span> )<span class="op">;</span>
    <span class="op">},</span>
    <span class="dt">set</span><span class="op">:</span> <span class="kw">function</span>(o) <span class="op">{</span>
        <span class="co">// setPrototypeOf(..) as of ES6</span>
        <span class="va">Object</span>.<span class="at">setPrototypeOf</span>( <span class="kw">this</span><span class="op">,</span> o )<span class="op">;</span>
        <span class="cf">return</span> o<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span> )<span class="op">;</span></code></pre></div>
<p>So, when we access (retrieve the value of) <code>a.__proto__</code>, it's like calling <code>a.__proto__()</code> (calling the getter function). <em>That</em> function call has <code>a</code> as its <code>this</code> even though the getter function exists on the <code>Object.prototype</code> object (see Chapter 2 for <code>this</code> binding rules), so it's just like saying <code>Object.getPrototypeOf( a )</code>.</p>
<p><code>.__proto__</code> is also a settable property, just like using ES6's <code>Object.setPrototypeOf(..)</code> shown earlier. However, generally you <strong>should not change the <code>[[Prototype]]</code> of an existing object</strong>.</p>
<p>There are some very complex, advanced techniques used deep in some frameworks that allow tricks like &quot;subclassing&quot; an <code>Array</code>, but this is commonly frowned on in general programming practice, as it usually leads to <em>much</em> harder to understand/maintain code.</p>
<p><strong>Note:</strong> As of ES6, the <code>class</code> keyword will allow something that approximates &quot;subclassing&quot; of built-in's like <code>Array</code>. See Appendix A for discussion of the <code>class</code> syntax added in ES6.</p>
<p>The only other narrow exception (as mentioned earlier) would be setting the <code>[[Prototype]]</code> of a default function's <code>.prototype</code> object to reference some other object (besides <code>Object.prototype</code>). That would avoid replacing that default object entirely with a new linked object. Otherwise, <strong>it's best to treat object <code>[[Prototype]]</code> linkage as a read-only characteristic</strong> for ease of reading your code later.</p>
<p><strong>Note:</strong> The JavaScript community unofficially coined a term for the double-underscore, specifically the leading one in properties like <code>__proto__</code>: &quot;dunder&quot;. So, the &quot;cool kids&quot; in JavaScript would generally pronounce <code>__proto__</code> as &quot;dunder proto&quot;.</p>
<h2 id="object-links">Object Links</h2>
<p>As we've now seen, the <code>[[Prototype]]</code> mechanism is an internal link that exists on one object which references some other object.</p>
<p>This linkage is (primarily) exercised when a property/method reference is made against the first object, and no such property/method exists. In that case, the <code>[[Prototype]]</code> linkage tells the engine to look for the property/method on the linked-to object. In turn, if that object cannot fulfill the look-up, its <code>[[Prototype]]</code> is followed, and so on. This series of links between objects forms what is called the &quot;prototype chain&quot;.</p>
<h3 id="createing-links"><code>Create()</code>ing Links</h3>
<p>We've thoroughly debunked why JavaScript's <code>[[Prototype]]</code> mechanism is <strong>not</strong> like <em>classes</em>, and we've seen how it instead creates <strong>links</strong> between proper objects.</p>
<p>What's the point of the <code>[[Prototype]]</code> mechanism? Why is it so common for JS developers to go to so much effort (emulating classes) in their code to wire up these linkages?</p>
<p>Remember we said much earlier in this chapter that <code>Object.create(..)</code> would be a hero? Now, we're ready to see how.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> foo <span class="op">=</span> <span class="op">{</span>
    <span class="dt">something</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Tell me something good...&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> bar <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( foo )<span class="op">;</span>

<span class="va">bar</span>.<span class="at">something</span>()<span class="op">;</span> <span class="co">// Tell me something good...</span></code></pre></div>
<p><code>Object.create(..)</code> creates a new object (<code>bar</code>) linked to the object we specified (<code>foo</code>), which gives us all the power (delegation) of the <code>[[Prototype]]</code> mechanism, but without any of the unnecessary complication of <code>new</code> functions acting as classes and constructor calls, confusing <code>.prototype</code> and <code>.constructor</code> references, or any of that extra stuff.</p>
<p><strong>Note:</strong> <code>Object.create(null)</code> creates an object that has an empty (aka, <code>null</code>) <code>[[Prototype]]</code> linkage, and thus the object can't delegate anywhere. Since such an object has no prototype chain, the <code>instanceof</code> operator (explained earlier) has nothing to check, so it will always return <code>false</code>. These special empty-<code>[[Prototype]]</code> objects are often called &quot;dictionaries&quot; as they are typically used purely for storing data in properties, mostly because they have no possible surprise effects from any delegated properties/functions on the <code>[[Prototype]]</code> chain, and are thus purely flat data storage.</p>
<p>We don't <em>need</em> classes to create meaningful relationships between two objects. The only thing we should <strong>really care about</strong> is objects linked together for delegation, and <code>Object.create(..)</code> gives us that linkage without all the class cruft.</p>
<h4 id="object.create-polyfilled"><code>Object.create()</code> Polyfilled</h4>
<p><code>Object.create(..)</code> was added in ES5. You may need to support pre-ES5 environments (like older IE's), so let's take a look at a simple <strong>partial</strong> polyfill for <code>Object.create(..)</code> that gives us the capability that we need even in those older JS environments:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Object</span>.<span class="at">create</span>) <span class="op">{</span>
    <span class="va">Object</span>.<span class="at">create</span> <span class="op">=</span> <span class="kw">function</span>(o) <span class="op">{</span>
        <span class="kw">function</span> <span class="at">F</span>()<span class="op">{}</span>
        <span class="va">F</span>.<span class="at">prototype</span> <span class="op">=</span> o<span class="op">;</span>
        <span class="cf">return</span> <span class="kw">new</span> <span class="at">F</span>()<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p>This polyfill works by using a throw-away <code>F</code> function and overriding its <code>.prototype</code> property to point to the object we want to link to. Then we use <code>new F()</code> construction to make a new object that will be linked as we specified.</p>
<p>This usage of <code>Object.create(..)</code> is by far the most common usage, because it's the part that <em>can be</em> polyfilled. There's an additional set of functionality that the standard ES5 built-in <code>Object.create(..)</code> provides, which is <strong>not polyfillable</strong> for pre-ES5. As such, this capability is far-less commonly used. For completeness sake, let's look at that additional functionality:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> anotherObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="kw">var</span> myObject <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( anotherObject<span class="op">,</span> <span class="op">{</span>
    <span class="dt">b</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
        <span class="dt">writable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
        <span class="dt">configurable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
        <span class="dt">value</span><span class="op">:</span> <span class="dv">3</span>
    <span class="op">},</span>
    <span class="dt">c</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
        <span class="dt">writable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
        <span class="dt">configurable</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
        <span class="dt">value</span><span class="op">:</span> <span class="dv">4</span>
    <span class="op">}</span>
<span class="op">}</span> )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">hasOwnProperty</span>( <span class="st">&quot;a&quot;</span> )<span class="op">;</span> <span class="co">// false</span>
<span class="va">myObject</span>.<span class="at">hasOwnProperty</span>( <span class="st">&quot;b&quot;</span> )<span class="op">;</span> <span class="co">// true</span>
<span class="va">myObject</span>.<span class="at">hasOwnProperty</span>( <span class="st">&quot;c&quot;</span> )<span class="op">;</span> <span class="co">// true</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span>
<span class="va">myObject</span>.<span class="at">b</span><span class="op">;</span> <span class="co">// 3</span>
<span class="va">myObject</span>.<span class="at">c</span><span class="op">;</span> <span class="co">// 4</span></code></pre></div>
<p>The second argument to <code>Object.create(..)</code> specifies property names to add to the newly created object, via declaring each new property's <em>property descriptor</em> (see Chapter 3). Because polyfilling property descriptors into pre-ES5 is not possible, this additional functionality on <code>Object.create(..)</code> also cannot be polyfilled.</p>
<p>The vast majority of usage of <code>Object.create(..)</code> uses the polyfill-safe subset of functionality, so most developers are fine with using the <strong>partial polyfill</strong> in pre-ES5 environments.</p>
<p>Some developers take a much stricter view, which is that no function should be polyfilled unless it can be <em>fully</em> polyfilled. Since <code>Object.create(..)</code> is one of those partial-polyfill'able utilities, this narrower perspective says that if you need to use any of the functionality of <code>Object.create(..)</code> in a pre-ES5 environment, instead of polyfilling, you should use a custom utility, and stay away from using the name <code>Object.create</code> entirely. You could instead define your own utility, like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">createAndLinkObject</span>(o) <span class="op">{</span>
    <span class="kw">function</span> <span class="at">F</span>()<span class="op">{}</span>
    <span class="va">F</span>.<span class="at">prototype</span> <span class="op">=</span> o<span class="op">;</span>
    <span class="cf">return</span> <span class="kw">new</span> <span class="at">F</span>()<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> anotherObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="kw">var</span> myObject <span class="op">=</span> <span class="at">createAndLinkObject</span>( anotherObject )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>I do not share this strict opinion. I fully endorse the common partial-polyfill of <code>Object.create(..)</code> as shown above, and using it in your code even in pre-ES5. I'll leave it to you to make your own decision.</p>
<h3 id="links-as-fallbacks">Links As Fallbacks?</h3>
<p>It may be tempting to think that these links between objects <em>primarily</em> provide a sort of fallback for &quot;missing&quot; properties or methods. While that may be an observed outcome, I don't think it represents the right way of thinking about <code>[[Prototype]]</code>.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> anotherObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">cool</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;cool!&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> myObject <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( anotherObject )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">cool</span>()<span class="op">;</span> <span class="co">// &quot;cool!&quot;</span></code></pre></div>
<p>That code will work by virtue of <code>[[Prototype]]</code>, but if you wrote it that way so that <code>anotherObject</code> was acting as a fallback <strong>just in case</strong> <code>myObject</code> couldn't handle some property/method that some developer may try to call, odds are that your software is going to be a bit more &quot;magical&quot; and harder to understand and maintain.</p>
<p>That's not to say there aren't cases where fallbacks are an appropriate design pattern, but it's not very common or idiomatic in JS, so if you find yourself doing so, you might want to take a step back and reconsider if that's really appropriate and sensible design.</p>
<p><strong>Note:</strong> In ES6, an advanced functionality called <code>Proxy</code> is introduced which can provide something of a &quot;method not found&quot; type of behavior. <code>Proxy</code> is beyond the scope of this book, but will be covered in detail in a later book in the <em>&quot;You Don't Know JS&quot;</em> series.</p>
<p><strong>Don't miss an important but nuanced point here.</strong></p>
<p>Designing software where you intend for a developer to, for instance, call <code>myObject.cool()</code> and have that work even though there is no <code>cool()</code> method on <code>myObject</code> introduces some &quot;magic&quot; into your API design that can be surprising for future developers who maintain your software.</p>
<p>You can however design your API with less &quot;magic&quot; to it, but still take advantage of the power of <code>[[Prototype]]</code> linkage.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> anotherObject <span class="op">=</span> <span class="op">{</span>
    <span class="dt">cool</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;cool!&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> myObject <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( anotherObject )<span class="op">;</span>

<span class="va">myObject</span>.<span class="at">doCool</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">cool</span>()<span class="op">;</span> <span class="co">// internal delegation!</span>
<span class="op">};</span>

<span class="va">myObject</span>.<span class="at">doCool</span>()<span class="op">;</span> <span class="co">// &quot;cool!&quot;</span></code></pre></div>
<p>Here, we call <code>myObject.doCool()</code>, which is a method that <em>actually exists</em> on <code>myObject</code>, making our API design more explicit (less &quot;magical&quot;). <em>Internally</em>, our implementation follows the <strong>delegation design pattern</strong> (see Chapter 6), taking advantage of <code>[[Prototype]]</code> delegation to <code>anotherObject.cool()</code>.</p>
<p>In other words, delegation will tend to be less surprising/confusing if it's an internal implementation detail rather than plainly exposed in your API design. We will expound on <strong>delegation</strong> in great detail in the next chapter.</p>
<h2 id="review-tldr-4">Review (TL;DR)</h2>
<p>When attempting a property access on an object that doesn't have that property, the object's internal <code>[[Prototype]]</code> linkage defines where the <code>[[Get]]</code> operation (see Chapter 3) should look next. This cascading linkage from object to object essentially defines a &quot;prototype chain&quot; (somewhat similar to a nested scope chain) of objects to traverse for property resolution.</p>
<p>All normal objects have the built-in <code>Object.prototype</code> as the top of the prototype chain (like the global scope in scope look-up), where property resolution will stop if not found anywhere prior in the chain. <code>toString()</code>, <code>valueOf()</code>, and several other common utilities exist on this <code>Object.prototype</code> object, explaining how all objects in the language are able to access them.</p>
<p>The most common way to get two objects linked to each other is using the <code>new</code> keyword with a function call, which among its four steps (see Chapter 2), it creates a new object linked to another object.</p>
<p>The &quot;another object&quot; that the new object is linked to happens to be the object referenced by the arbitrarily named <code>.prototype</code> property of the function called with <code>new</code>. Functions called with <code>new</code> are often called &quot;constructors&quot;, despite the fact that they are not actually instantiating a class as <em>constructors</em> do in traditional class-oriented languages.</p>
<p>While these JavaScript mechanisms can seem to resemble &quot;class instantiation&quot; and &quot;class inheritance&quot; from traditional class-oriented languages, the key distinction is that in JavaScript, no copies are made. Rather, objects end up linked to each other via an internal <code>[[Prototype]]</code> chain.</p>
<p>For a variety of reasons, not the least of which is terminology precedent, &quot;inheritance&quot; (and &quot;prototypal inheritance&quot;) and all the other OO terms just do not make sense when considering how JavaScript <em>actually</em> works (not just applied to our forced mental models).</p>
<p>Instead, &quot;delegation&quot; is a more appropriate term, because these relationships are not <em>copies</em> but delegation <strong>links</strong>.</p>
<h1 id="you-dont-know-js-this-object-prototypes-5">You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>
<h1 id="appendix-a-es6-class">Appendix A: ES6 <code>class</code></h1>
<p>If there's any take-away message from the second half of this book (Chapters 4-6), it's that classes are an optional design pattern for code (not a necessary given), and that furthermore they are often quite awkward to implement in a <code>[[Prototype]]</code> language like JavaScript.</p>
<p>This awkwardness is <em>not</em> just about syntax, although that's a big part of it. Chapters 4 and 5 examined quite a bit of syntactic ugliness, from verbosity of <code>.prototype</code> references cluttering the code, to <em>explicit pseudo-polymorphism</em> (see Chapter 4) when you give methods the same name at different levels of the chain and try to implement a polymorphic reference from a lower-level method to a higher-level method. <code>.constructor</code> being wrongly interpreted as &quot;was constructed by&quot; and yet being unreliable for that definition is yet another syntactic ugly.</p>
<p>But the problems with class design are much deeper. Chapter 4 points out that classes in traditional class-oriented languages actually produce a <em>copy</em> action from parent to child to instance, whereas in <code>[[Prototype]]</code>, the action is <strong>not</strong> a copy, but rather the opposite -- a delegation link.</p>
<p>When compared to the simplicity of OLOO-style code and behavior delegation (see Chapter 6), which embrace <code>[[Prototype]]</code> rather than hide from it, classes stand out as a sore thumb in JS.</p>
<h2 id="class-1"><code>class</code></h2>
<p>But we <em>don't</em> need to re-argue that case again. I re-mention those issues briefly only so that you keep them fresh in your mind now that we turn our attention to the ES6 <code>class</code> mechanism. We'll demonstrate here how it works, and look at whether or not <code>class</code> does anything substantial to address any of those &quot;class&quot; concerns.</p>
<p>Let's revisit the <code>Widget</code> / <code>Button</code> example from Chapter 6:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> Widget <span class="op">{</span>
    <span class="at">constructor</span>(width<span class="op">,</span>height) <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">width</span> <span class="op">=</span> width <span class="op">||</span> <span class="dv">50</span><span class="op">;</span>
        <span class="kw">this</span>.<span class="at">height</span> <span class="op">=</span> height <span class="op">||</span> <span class="dv">50</span><span class="op">;</span>
        <span class="kw">this</span>.<span class="at">$elem</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="at">render</span>($where)<span class="op">{</span>
        <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">$elem</span>) <span class="op">{</span>
            <span class="kw">this</span>.<span class="va">$elem</span>.<span class="at">css</span>( <span class="op">{</span>
                <span class="dt">width</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">width</span> <span class="op">+</span> <span class="st">&quot;px&quot;</span><span class="op">,</span>
                <span class="dt">height</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">height</span> <span class="op">+</span> <span class="st">&quot;px&quot;</span>
            <span class="op">}</span> ).<span class="at">appendTo</span>( $where )<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">class</span> Button <span class="kw">extends</span> Widget <span class="op">{</span>
    <span class="at">constructor</span>(width<span class="op">,</span>height<span class="op">,</span>label) <span class="op">{</span>
        <span class="kw">super</span>( width<span class="op">,</span> height )<span class="op">;</span>
        <span class="kw">this</span>.<span class="at">label</span> <span class="op">=</span> label <span class="op">||</span> <span class="st">&quot;Default&quot;</span><span class="op">;</span>
        <span class="kw">this</span>.<span class="at">$elem</span> <span class="op">=</span> <span class="at">$</span>( <span class="st">&quot;&lt;button&gt;&quot;</span> ).<span class="at">text</span>( <span class="kw">this</span>.<span class="at">label</span> )<span class="op">;</span>
    <span class="op">}</span>
    <span class="at">render</span>($where) <span class="op">{</span>
        <span class="kw">super</span>.<span class="at">render</span>( $where )<span class="op">;</span>
        <span class="kw">this</span>.<span class="va">$elem</span>.<span class="at">click</span>( <span class="kw">this</span>.<span class="va">onClick</span>.<span class="at">bind</span>( <span class="kw">this</span> ) )<span class="op">;</span>
    <span class="op">}</span>
    <span class="at">onClick</span>(evt) <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Button &#39;&quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">label</span> <span class="op">+</span> <span class="st">&quot;&#39; clicked!&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Beyond this syntax <em>looking</em> nicer, what problems does ES6 solve?</p>
<ol type="1">
<li>There's no more (well, sorta, see below!) references to <code>.prototype</code> cluttering the code.</li>
<li><code>Button</code> is declared directly to &quot;inherit from&quot; (aka <code>extends</code>) <code>Widget</code>, instead of needing to use <code>Object.create(..)</code> to replace a <code>.prototype</code> object that's linked, or having to set with <code>.__proto__</code> or <code>Object.setPrototypeOf(..)</code>.</li>
<li><code>super(..)</code> now gives us a very helpful <strong>relative polymorphism</strong> capability, so that any method at one level of the chain can refer relatively one level up the chain to a method of the same name. This includes a solution to the note from Chapter 4 about the weirdness of constructors not belonging to their class, and so being unrelated -- <code>super()</code> works inside constructors exactly as you'd expect.</li>
<li><code>class</code> literal syntax has no affordance for specifying properties (only methods). This might seem limiting to some, but it's expected that the vast majority of cases where a property (state) exists elsewhere but the end-chain &quot;instances&quot;, this is usually a mistake and surprising (as it's state that's implicitly &quot;shared&quot; among all &quot;instances&quot;). So, one <em>could</em> say the <code>class</code> syntax is protecting you from mistakes.</li>
<li><code>extends</code> lets you extend even built-in object (sub)types, like <code>Array</code> or <code>RegExp</code>, in a very natural way. Doing so without <code>class .. extends</code> has long been an exceedingly complex and frustrating task, one that only the most adept of framework authors have ever been able to accurately tackle. Now, it will be rather trivial!</li>
</ol>
<p>In all fairness, those are some substantial solutions to many of the most obvious (syntactic) issues and surprises people have with classical prototype-style code.</p>
<h2 id="class-gotchas"><code>class</code> Gotchas</h2>
<p>It's not all bubblegum and roses, though. There are still some deep and profoundly troubling issues with using &quot;classes&quot; as a design pattern in JS.</p>
<p>Firstly, the <code>class</code> syntax may convince you a new &quot;class&quot; mechanism exists in JS as of ES6. <strong>Not so.</strong> <code>class</code> is, mostly, just syntactic sugar on top of the existing <code>[[Prototype]]</code> (delegation!) mechanism.</p>
<p>That means <code>class</code> is not actually copying definitions statically at declaration time the way it does in traditional class-oriented languages. If you change/replace a method (on purpose or by accident) on the parent &quot;class&quot;, the child &quot;class&quot; and/or instances will still be &quot;affected&quot;, in that they didn't get copies at declaration time, they are all still using the live-delegation model based on <code>[[Prototype]]</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> C <span class="op">{</span>
    <span class="at">constructor</span>() <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">num</span> <span class="op">=</span> <span class="va">Math</span>.<span class="at">random</span>()<span class="op">;</span>
    <span class="op">}</span>
    <span class="at">rand</span>() <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Random: &quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">num</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">var</span> c1 <span class="op">=</span> <span class="kw">new</span> <span class="at">C</span>()<span class="op">;</span>
<span class="va">c1</span>.<span class="at">rand</span>()<span class="op">;</span> <span class="co">// &quot;Random: 0.4324299...&quot;</span>

<span class="va">C</span>.<span class="va">prototype</span>.<span class="at">rand</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Random: &quot;</span> <span class="op">+</span> <span class="va">Math</span>.<span class="at">round</span>( <span class="kw">this</span>.<span class="at">num</span> <span class="op">*</span> <span class="dv">1000</span> ))<span class="op">;</span>
<span class="op">};</span>

<span class="kw">var</span> c2 <span class="op">=</span> <span class="kw">new</span> <span class="at">C</span>()<span class="op">;</span>
<span class="va">c2</span>.<span class="at">rand</span>()<span class="op">;</span> <span class="co">// &quot;Random: 867&quot;</span>

<span class="va">c1</span>.<span class="at">rand</span>()<span class="op">;</span> <span class="co">// &quot;Random: 432&quot; -- oops!!!</span></code></pre></div>
<p>This only seems like reasonable behavior <em>if you already know</em> about the delegation nature of things, rather than expecting <em>copies</em> from &quot;real classes&quot;. So the question to ask yourself is, why are you choosing <code>class</code> syntax for something fundamentally different from classes?</p>
<p>Doesn't the ES6 <code>class</code> syntax <strong>just make it harder</strong> to see and understand the difference between traditional classes and delegated objects?</p>
<p><code>class</code> syntax <em>does not</em> provide a way to declare class member properties (only methods). So if you need to do that to track shared state among instances, then you end up going back to the ugly <code>.prototype</code> syntax, like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> C <span class="op">{</span>
    <span class="at">constructor</span>() <span class="op">{</span>
        <span class="co">// make sure to modify the shared state,</span>
        <span class="co">// not set a shadowed property on the</span>
        <span class="co">// instances!</span>
        <span class="va">C</span>.<span class="va">prototype</span>.<span class="at">count</span><span class="op">++;</span>

        <span class="co">// here, `this.count` works as expected</span>
        <span class="co">// via delegation</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Hello: &quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">count</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="co">// add a property for shared state directly to</span>
<span class="co">// prototype object</span>
<span class="va">C</span>.<span class="va">prototype</span>.<span class="at">count</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>

<span class="kw">var</span> c1 <span class="op">=</span> <span class="kw">new</span> <span class="at">C</span>()<span class="op">;</span>
<span class="co">// Hello: 1</span>

<span class="kw">var</span> c2 <span class="op">=</span> <span class="kw">new</span> <span class="at">C</span>()<span class="op">;</span>
<span class="co">// Hello: 2</span>

<span class="va">c1</span>.<span class="at">count</span> <span class="op">===</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// true</span>
<span class="va">c1</span>.<span class="at">count</span> <span class="op">===</span> <span class="va">c2</span>.<span class="at">count</span><span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>The biggest problem here is that it betrays the <code>class</code> syntax by exposing (leakage!) <code>.prototype</code> as an implementation detail.</p>
<p>But, we also still have the surprise gotcha that <code>this.count++</code> would implicitly create a separate shadowed <code>.count</code> property on both <code>c1</code> and <code>c2</code> objects, rather than updating the shared state. <code>class</code> offers us no consolation from that issue, except (presumably) to imply by lack of syntactic support that you shouldn't be doing that <em>at all</em>.</p>
<p>Moreover, accidental shadowing is still a hazard:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> C <span class="op">{</span>
    <span class="at">constructor</span>(id) <span class="op">{</span>
        <span class="co">// oops, gotcha, we&#39;re shadowing `id()` method</span>
        <span class="co">// with a property value on the instance</span>
        <span class="kw">this</span>.<span class="at">id</span> <span class="op">=</span> id<span class="op">;</span>
    <span class="op">}</span>
    <span class="at">id</span>() <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Id: &quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">id</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">var</span> c1 <span class="op">=</span> <span class="kw">new</span> <span class="at">C</span>( <span class="st">&quot;c1&quot;</span> )<span class="op">;</span>
<span class="va">c1</span>.<span class="at">id</span>()<span class="op">;</span> <span class="co">// TypeError -- `c1.id` is now the string &quot;c1&quot;</span></code></pre></div>
<p>There's also some very subtle nuanced issues with how <code>super</code> works. You might assume that <code>super</code> would be bound in an analogous way to how <code>this</code> gets bound (see Chapter 2), which is that <code>super</code> would always be bound to one level higher than whatever the current method's position in the <code>[[Prototype]]</code> chain is.</p>
<p>However, for performance reasons (<code>this</code> binding is already expensive), <code>super</code> is not bound dynamically. It's bound sort of &quot;statically&quot;, as declaration time. No big deal, right?</p>
<p>Ehh... maybe, maybe not. If you, like most JS devs, start assigning functions around to different objects (which came from <code>class</code> definitions), in various different ways, you probably won't be very aware that in all those cases, the <code>super</code> mechanism under the covers is having to be re-bound each time.</p>
<p>And depending on what sorts of syntactic approaches you take to these assignments, there may very well be cases where the <code>super</code> can't be properly bound (at least, not where you suspect), so you may (at time of writing, TC39 discussion is ongoing on the topic) have to manually bind <code>super</code> with <code>toMethod(..)</code> (kinda like you have to do <code>bind(..)</code> for <code>this</code> -- see Chapter 2).</p>
<p>You're used to being able to assign around methods to different objects to <em>automatically</em> take advantage of the dynamism of <code>this</code> via the <em>implicit binding</em> rule (see Chapter 2). But the same will likely not be true with methods that use <code>super</code>.</p>
<p>Consider what <code>super</code> should do here (against <code>D</code> and <code>E</code>):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> P <span class="op">{</span>
    <span class="at">foo</span>() <span class="op">{</span> <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;P.foo&quot;</span> )<span class="op">;</span> <span class="op">}</span>
<span class="op">}</span>

<span class="kw">class</span> C <span class="kw">extends</span> P <span class="op">{</span>
    <span class="at">foo</span>() <span class="op">{</span>
        <span class="kw">super</span>()<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">var</span> c1 <span class="op">=</span> <span class="kw">new</span> <span class="at">C</span>()<span class="op">;</span>
<span class="va">c1</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// &quot;P.foo&quot;</span>

<span class="kw">var</span> D <span class="op">=</span> <span class="op">{</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span> <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;D.foo&quot;</span> )<span class="op">;</span> <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> E <span class="op">=</span> <span class="op">{</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="va">C</span>.<span class="va">prototype</span>.<span class="at">foo</span>
<span class="op">};</span>

<span class="co">// Link E to D for delegation</span>
<span class="va">Object</span>.<span class="at">setPrototypeOf</span>( E<span class="op">,</span> D )<span class="op">;</span>

<span class="va">E</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// &quot;P.foo&quot;</span></code></pre></div>
<p>If you were thinking (quite reasonably!) that <code>super</code> would be bound dynamically at call-time, you might expect that <code>super()</code> would automatically recognize that <code>E</code> delegates to <code>D</code>, so <code>E.foo()</code> using <code>super()</code> should call to <code>D.foo()</code>.</p>
<p><strong>Not so.</strong> For performance pragmatism reasons, <code>super</code> is not <em>late bound</em> (aka, dynamically bound) like <code>this</code> is. Instead it's derived at call-time from <code>[[HomeObject]].[[Prototype]]</code>, where <code>[[HomeObject]]</code> is statically bound at creation time.</p>
<p>In this particular case, <code>super()</code> is still resolving to <code>P.foo()</code>, since the method's <code>[[HomeObject]]</code> is still <code>C</code> and <code>C.[[Prototype]]</code> is <code>P</code>.</p>
<p>There will <em>probably</em> be ways to manually address such gotchas. Using <code>toMethod(..)</code> to bind/rebind a method's <code>[[HomeObject]]</code> (along with setting the <code>[[Prototype]]</code> of that object!) appears to work in this scenario:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> D <span class="op">=</span> <span class="op">{</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span> <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;D.foo&quot;</span> )<span class="op">;</span> <span class="op">}</span>
<span class="op">};</span>

<span class="co">// Link E to D for delegation</span>
<span class="kw">var</span> E <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( D )<span class="op">;</span>

<span class="co">// manually bind `foo`s `[[HomeObject]]` as</span>
<span class="co">// `E`, and `E.[[Prototype]]` is `D`, so thus</span>
<span class="co">// `super()` is `D.foo()`</span>
<span class="va">E</span>.<span class="at">foo</span> <span class="op">=</span> <span class="va">C</span>.<span class="va">prototype</span>.<span class="va">foo</span>.<span class="at">toMethod</span>( E<span class="op">,</span> <span class="st">&quot;foo&quot;</span> )<span class="op">;</span>

<span class="va">E</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// &quot;D.foo&quot;</span></code></pre></div>
<p><strong>Note:</strong> <code>toMethod(..)</code> clones the method, and takes <code>homeObject</code> as its first parameter (which is why we pass <code>E</code>), and the second parameter (optionally) sets a <code>name</code> for the new method (which keep at &quot;foo&quot;).</p>
<p>It remains to be seen if there are other corner case gotchas that devs will run into beyond this scenario. Regardless, you will have to be diligent and stay aware of which places the engine automatically figures out <code>super</code> for you, and which places you have to manually take care of it. <strong>Ugh!</strong></p>
<h1 id="static-dynamic">Static &gt; Dynamic?</h1>
<p>But the biggest problem of all about ES6 <code>class</code> is that all these various gotchas mean <code>class</code> sorta opts you into a syntax which seems to imply (like traditional classes) that once you declare a <code>class</code>, it's a static definition of a (future instantiated) thing. You completely lose sight of the fact that <code>C</code> is an object, a concrete thing, which you can directly interact with.</p>
<p>In traditional class-oriented languages, you never adjust the definition of a class later, so the class design pattern doesn't suggest such capabilities. But <strong>one of the most powerful parts</strong> of JS is that it <em>is</em> dynamic, and the definition of any object is (unless you make it immutable) a fluid and mutable <em>thing</em>.</p>
<p><code>class</code> seems to imply you shouldn't do such things, by forcing you into the uglier <code>.prototype</code> syntax to do so, or forcing you to think about <code>super</code> gotchas, etc. It also offers <em>very little</em> support for any of the pitfalls that this dynamism can bring.</p>
<p>In other words, it's as if <code>class</code> is telling you: &quot;dynamic is too hard, so it's probably not a good idea. Here's a static-looking syntax, so code your stuff statically.&quot;</p>
<p>What a sad commentary on JavaScript: <strong>dynamic is too hard, let's pretend to be (but not actually be!) static</strong>.</p>
<p>These are the reasons why ES6 <code>class</code> is masquerading as a nice solution to syntactic headaches, but it's actually muddying the waters further and making things worse for JS and for clear and concise understanding.</p>
<p><strong>Note:</strong> If you use the <code>.bind(..)</code> utility to make a hard-bound function (see Chapter 2), the function created is not subclassable with ES6 <code>extend</code> like normal functions are.</p>
<h2 id="review-tldr-5">Review (TL;DR)</h2>
<p><code>class</code> does a very good job of pretending to fix the problems with the class/inheritance design pattern in JS. But it actually does the opposite: <strong>it hides many of the problems, and introduces other subtle but dangerous ones</strong>.</p>
<p><code>class</code> contributes to the ongoing confusion of &quot;class&quot; in JavaScript which has plagued the language for nearly two decades. In some respects, it asks more questions than it answers, and it feels in totality like a very unnatural fit on top of the elegant simplicity of the <code>[[Prototype]]</code> mechanism.</p>
<p>Bottom line: if ES6 <code>class</code> makes it harder to robustly leverage <code>[[Prototype]]</code>, and hides the most important nature of the JS object mechanism -- <strong>the live delegation links between objects</strong> -- shouldn't we see <code>class</code> as creating more troubles than it solves, and just relegate it to an anti-pattern?</p>
<p>I can't really answer that question for you. But I hope this book has fully explored the issue at a deeper level than you've ever gone before, and has given you the information you need <em>to answer it yourself</em>.</p>
<h1 id="you-dont-know-js-this-object-prototypes-6">You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>
<h1 id="appendix-b-acknowledgments">Appendix B: Acknowledgments</h1>
<p>I have many people to thank for making this book title and the overall series happen.</p>
<p>First, I must thank my wife Christen Simpson, and my two kids Ethan and Emily, for putting up with Dad always pecking away at the computer. Even when not writing books, my obsession with JavaScript glues my eyes to the screen far more than it should. That time I borrow from my family is the reason these books can so deeply and completely explain JavaScript to you, the reader. I owe my family everything.</p>
<p>I'd like to thank my editors at O'Reilly, namely Simon St.Laurent and Brian MacDonald, as well as the rest of the editorial and marketing staff. They are fantastic to work with, and have been especially accommodating during this experiment into &quot;open source&quot; book writing, editing, and production.</p>
<p>Thank you to the many folks who have participated in making this book series better by providing editorial suggestions and corrections, including Shelley Powers, Tim Ferro, Evan Borden, Forrest L. Norvell, Jennifer Davis, Jesse Harlin, and many others. A big thank you to Nick Berardi for writing the Foreword for this title.</p>
<p>Thank you to the countless folks in the community, including members of the TC39 committee, who have shared so much knowledge with the rest of us, and especially tolerated my incessant questions and explorations with patience and detail. John-David Dalton, Juriy &quot;kangax&quot; Zaytsev, Mathias Bynens, Axel Rauschmayer, Nicholas Zakas, Angus Croll, Reginald Braithwaite, Dave Herman, Brendan Eich, Allen Wirfs-Brock, Bradley Meck, Domenic Denicola, David Walsh, Tim Disney, Peter van der Zee, Andrea Giammarchi, Kit Cambridge, Eric Elliott, and so many others, I can't even scratch the surface.</p>
<p>The <em>You Don't Know JS</em> book series was born on Kickstarter, so I also wish to thank all my (nearly) 500 generous backers, without whom this book series could not have happened:</p>
<blockquote>
<p>Jan Szpila, nokiko, Murali Krishnamoorthy, Ryan Joy, Craig Patchett, pdqtrader, Dale Fukami, ray hatfield, R0drigo Perez [Mx], Dan Petitt, Jack Franklin, Andrew Berry, Brian Grinstead, Rob Sutherland, Sergi Meseguer, Phillip Gourley, Mark Watson, Jeff Carouth, Alfredo Sumaran, Martin Sachse, Marcio Barrios, Dan, AimelyneM, Matt Sullivan, Delnatte Pierre-Antoine, Jake Smith, Eugen Tudorancea, Iris, David Trinh, simonstl, Ray Daly, Uros Gruber, Justin Myers, Shai Zonis, Mom &amp; Dad, Devin Clark, Dennis Palmer, Brian Panahi Johnson, Josh Marshall, Marshall, Dennis Kerr, Matt Steele, Erik Slagter, Sacah, Justin Rainbow, Christian Nilsson, Delapouite, D.Pereira, Nicolas Hoizey, George V. Reilly, Dan Reeves, Bruno Laturner, Chad Jennings, Shane King, Jeremiah Lee Cohick, od3n, Stan Yamane, Marko Vucinic, Jim B, Stephen Collins, Ægir Þorsteinsson, Eric Pederson, Owain, Nathan Smith, Jeanetteurphy, Alexandre ELISÉ, Chris Peterson, Rik Watson, Luke Matthews, Justin Lowery, Morten Nielsen, Vernon Kesner, Chetan Shenoy, Paul Tregoing, Marc Grabanski, Dion Almaer, Andrew Sullivan, Keith Elsass, Tom Burke, Brian Ashenfelter, David Stuart, Karl Swedberg, Graeme, Brandon Hays, John Christopher, Gior, manoj reddy, Chad Smith, Jared Harbour, Minoru TODA, Chris Wigley, Daniel Mee, Mike, Handyface, Alex Jahraus, Carl Furrow, Rob Foulkrod, Max Shishkin, Leigh Penny Jr., Robert Ferguson, Mike van Hoenselaar, Hasse Schougaard, rajan venkataguru, Jeff Adams, Trae Robbins, Rolf Langenhuijzen, Jorge Antunes, Alex Koloskov, Hugh Greenish, Tim Jones, Jose Ochoa, Michael Brennan-White, Naga Harish Muvva, Barkóczi Dávid, Kitt Hodsden, Paul McGraw, Sascha Goldhofer, Andrew Metcalf, Markus Krogh, Michael Mathews, Matt Jared, Juanfran, Georgie Kirschner, Kenny Lee, Ted Zhang, Amit Pahwa, Inbal Sinai, Dan Raine, Schabse Laks, Michael Tervoort, Alexandre Abreu, Alan Joseph Williams, NicolasD, Cindy Wong, Reg Braithwaite, LocalPCGuy, Jon Friskics, Chris Merriman, John Pena, Jacob Katz, Sue Lockwood, Magnus Johansson, Jeremy Crapsey, Grzegorz Pawłowski, nico nuzzaci, Christine Wilks, Hans Bergren, charles montgomery, Ariel בר-לבב Fogel, Ivan Kolev, Daniel Campos, Hugh Wood, Christian Bradford, Frédéric Harper, Ionuţ Dan Popa, Jeff Trimble, Rupert Wood, Trey Carrico, Pancho Lopez, Joël kuijten, Tom A Marra, Jeff Jewiss, Jacob Rios, Paolo Di Stefano, Soledad Penades, Chris Gerber, Andrey Dolganov, Wil Moore III, Thomas Martineau, Kareem, Ben Thouret, Udi Nir, Morgan Laupies, jory carson-burson, Nathan L Smith, Eric Damon Walters, Derry Lozano-Hoyland, Geoffrey Wiseman, mkeehner, KatieK, Scott MacFarlane, Brian LaShomb, Adrien Mas, christopher ross, Ian Littman, Dan Atkinson, Elliot Jobe, Nick Dozier, Peter Wooley, John Hoover, dan, Martin A. Jackson, Héctor Fernando Hurtado, andy ennamorato, Paul Seltmann, Melissa Gore, Dave Pollard, Jack Smith, Philip Da Silva, Guy Israeli, <span class="citation" data-cites="megalithic">@megalithic</span>, Damian Crawford, Felix Gliesche, April Carter Grant, Heidi, jim tierney, Andrea Giammarchi, Nico Vignola, Don Jones, Chris Hartjes, Alex Howes, john gibbon, David J. Groom, BBox, Yu 'Dilys' Sun, Nate Steiner, Brandon Satrom, Brian Wyant, Wesley Hales, Ian Pouncey, Timothy Kevin Oxley, George Terezakis, sanjay raj, Jordan Harband, Marko McLion, Wolfgang Kaufmann, Pascal Peuckert, Dave Nugent, Markus Liebelt, Welling Guzman, Nick Cooley, Daniel Mesquita, Robert Syvarth, Chris Coyier, Rémy Bach, Adam Dougal, Alistair Duggin, David Loidolt, Ed Richer, Brian Chenault, GoldFire Studios, Carles Andrés, Carlos Cabo, Yuya Saito, roberto ricardo, Barnett Klane, Mike Moore, Kevin Marx, Justin Love, Joe Taylor, Paul Dijou, Michael Kohler, Rob Cassie, Mike Tierney, Cody Leroy Lindley, tofuji, Shimon Schwartz, Raymond, Luc De Brouwer, David Hayes, Rhys Brett-Bowen, Dmitry, Aziz Khoury, Dean, Scott Tolinski - Level Up, Clement Boirie, Djordje Lukic, Anton Kotenko, Rafael Corral, Philip Hurwitz, Jonathan Pidgeon, Jason Campbell, Joseph C., SwiftOne, Jan Hohner, Derick Bailey, getify, Daniel Cousineau, Chris Charlton, Eric Turner, David Turner, Joël Galeran, Dharma Vagabond, adam, Dirk van Bergen, dave ♥♫★ furf, Vedran Zakanj, Ryan McAllen, Natalie Patrice Tucker, Eric J. Bivona, Adam Spooner, Aaron Cavano, Kelly Packer, Eric J, Martin Drenovac, Emilis, Michael Pelikan, Scott F. Walter, Josh Freeman, Brandon Hudgeons, vijay chennupati, Bill Glennon, Robin R., Troy Forster, otaku_coder, Brad, Scott, Frederick Ostrander, Adam Brill, Seb Flippence, Michael Anderson, Jacob, Adam Randlett, Standard, Joshua Clanton, Sebastian Kouba, Chris Deck, SwordFire, Hannes Papenberg, Richard Woeber, hnzz, Rob Crowther, Jedidiah Broadbent, Sergey Chernyshev, Jay-Ar Jamon, Ben Combee, luciano bonachela, Mark Tomlinson, Kit Cambridge, Michael Melgares, Jacob Adams, Adrian Bruinhout, Bev Wieber, Scott Puleo, Thomas Herzog, April Leone, Daniel Mizieliński, Kees van Ginkel, Jon Abrams, Erwin Heiser, Avi Laviad, David newell, Jean-Francois Turcot, Niko Roberts, Erik Dana, Charles Neill, Aaron Holmes, Grzegorz Ziółkowski, Nathan Youngman, Timothy, Jacob Mather, Michael Allan, Mohit Seth, Ryan Ewing, Benjamin Van Treese, Marcelo Santos, Denis Wolf, Phil Keys, Chris Yung, Timo Tijhof, Martin Lekvall, Agendine, Greg Whitworth, Helen Humphrey, Dougal Campbell, Johannes Harth, Bruno Girin, Brian Hough, Darren Newton, Craig McPheat, Olivier Tille, Dennis Roethig, Mathias Bynens, Brendan Stromberger, sundeep, John Meyer, Ron Male, John F Croston III, gigante, Carl Bergenhem, B.J. May, Rebekah Tyler, Ted Foxberry, Jordan Reese, Terry Suitor, afeliz, Tom Kiefer, Darragh Duffy, Kevin Vanderbeken, Andy Pearson, Simon Mac Donald, Abid Din, Chris Joel, Tomas Theunissen, David Dick, Paul Grock, Brandon Wood, John Weis, dgrebb, Nick Jenkins, Chuck Lane, Johnny Megahan, marzsman, Tatu Tamminen, Geoffrey Knauth, Alexander Tarmolov, Jeremy Tymes, Chad Auld, Sean Parmelee, Rob Staenke, Dan Bender, Yannick derwa, Joshua Jones, Geert Plaisier, Tom LeZotte, Christen Simpson, Stefan Bruvik, Justin Falcone, Carlos Santana, Michael Weiss, Pablo Villoslada, Peter deHaan, Dimitris Iliopoulos, seyDoggy, Adam Jordens, Noah Kantrowitz, Amol M, Matthew Winnard, Dirk Ginader, Phinam Bui, David Rapson, Andrew Baxter, Florian Bougel, Michael George, Alban Escalier, Daniel Sellers, Sasha Rudan, John Green, Robert Kowalski, David I. Teixeira (<span class="citation" data-cites="ditma">@ditma</span>, Charles Carpenter, Justin Yost, Sam S, Denis Ciccale, Kevin Sheurs, Yannick Croissant, Pau Fracés, Stephen McGowan, Shawn Searcy, Chris Ruppel, Kevin Lamping, Jessica Campbell, Christopher Schmitt, Sablons, Jonathan Reisdorf, Bunni Gek, Teddy Huff, Michael Mullany, Michael Fürstenberg, Carl Henderson, Rick Yoesting, Scott Nichols, Hernán Ciudad, Andrew Maier, Mike Stapp, Jesse Shawl, Sérgio Lopes, jsulak, Shawn Price, Joel Clermont, Chris Ridmann, Sean Timm, Jason Finch, Aiden Montgomery, Elijah Manor, Derek Gathright, Jesse Harlin, Dillon Curry, Courtney Myers, Diego Cadenas, Arne de Bree, João Paulo Dubas, James Taylor, Philipp Kraeutli, Mihai Păun, Sam Gharegozlou, joshjs, Matt Murchison, Eric Windham, Timo Behrmann, Andrew Hall, joshua price, Théophile Villard</p>
</blockquote>
<p>This book series is being produced in an open source fashion, including editing and production. We owe GitHub a debt of gratitude for making that sort of thing possible for the community!</p>
<p>Thank you again to all the countless folks I didn't name but who I nonetheless owe thanks. May this book series be &quot;owned&quot; by all of us and serve to contribute to increasing awareness and understanding of the JavaScript language, to the benefit of all current and future community contributors.</p>
</body>
</html>
