<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#you-dont-know-js-types-grammar">You Don't Know JS: Types &amp; Grammar</a></li>
<li><a href="#foreword">Foreword</a></li>
<li><a href="#you-dont-know-js-types-grammar-1">You Don't Know JS: Types &amp; Grammar</a></li>
<li><a href="#chapter-1-types">Chapter 1: Types</a></li>
<li><a href="#a-type-by-any-other-name...">A Type By Any Other Name...</a><ul>
<li><a href="#built-in-types">Built-in Types</a></li>
<li><a href="#values-as-types">Values as Types</a></li>
<li><a href="#review">Review</a></li>
</ul></li>
<li><a href="#you-dont-know-js-types-grammar-2">You Don't Know JS: Types &amp; Grammar</a></li>
<li><a href="#chapter-2-values">Chapter 2: Values</a><ul>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#numbers">Numbers</a></li>
<li><a href="#special-values">Special Values</a></li>
<li><a href="#value-vs.-reference">Value vs. Reference</a></li>
<li><a href="#review-1">Review</a></li>
</ul></li>
<li><a href="#you-dont-know-js-types-grammar-3">You Don't Know JS: Types &amp; Grammar</a></li>
<li><a href="#chapter-3-natives">Chapter 3: Natives</a><ul>
<li><a href="#internal-class">Internal <code>[[Class]]</code></a></li>
<li><a href="#boxing-wrappers">Boxing Wrappers</a></li>
<li><a href="#unboxing">Unboxing</a></li>
<li><a href="#natives-as-constructors">Natives as Constructors</a></li>
<li><a href="#review-2">Review</a></li>
</ul></li>
<li><a href="#you-dont-know-js-types-grammar-4">You Don't Know JS: Types &amp; Grammar</a></li>
<li><a href="#chapter-4-coercion">Chapter 4: Coercion</a><ul>
<li><a href="#converting-values">Converting Values</a></li>
<li><a href="#abstract-value-operations">Abstract Value Operations</a></li>
<li><a href="#explicit-coercion">Explicit Coercion</a></li>
<li><a href="#implicit-coercion">Implicit Coercion</a></li>
<li><a href="#loose-equals-vs.-strict-equals">Loose Equals vs. Strict Equals</a></li>
<li><a href="#abstract-relational-comparison">Abstract Relational Comparison</a></li>
<li><a href="#review-3">Review</a></li>
</ul></li>
<li><a href="#you-dont-know-js-types-grammar-5">You Don't Know JS: Types &amp; Grammar</a></li>
<li><a href="#chapter-5-grammar">Chapter 5: Grammar</a><ul>
<li><a href="#statements-expressions">Statements &amp; Expressions</a></li>
<li><a href="#operator-precedence">Operator Precedence</a></li>
<li><a href="#automatic-semicolons">Automatic Semicolons</a></li>
<li><a href="#errors">Errors</a></li>
<li><a href="#function-arguments">Function Arguments</a></li>
<li><a href="#try..finally"><code>try..finally</code></a></li>
<li><a href="#switch"><code>switch</code></a></li>
<li><a href="#review-4">Review</a></li>
</ul></li>
<li><a href="#you-dont-know-js-types-grammar-6">You Don't Know JS: Types &amp; Grammar</a></li>
<li><a href="#appendix-a-mixed-environment-javascript">Appendix A: Mixed Environment JavaScript</a><ul>
<li><a href="#annex-b-ecmascript">Annex B (ECMAScript)</a></li>
<li><a href="#host-objects">Host Objects</a></li>
<li><a href="#global-dom-variables">Global DOM Variables</a></li>
<li><a href="#native-prototypes-1">Native Prototypes</a></li>
<li><a href="#scripts"><code>&lt;script&gt;</code>s</a></li>
<li><a href="#reserved-words">Reserved Words</a></li>
<li><a href="#implementation-limits">Implementation Limits</a></li>
<li><a href="#review-5">Review</a></li>
</ul></li>
<li><a href="#you-dont-know-js-types-grammar-7">You Don't Know JS: Types &amp; Grammar</a></li>
<li><a href="#appendix-b-acknowledgments">Appendix B: Acknowledgments</a></li>
</ul>
</nav>
<h1 id="you-dont-know-js-types-grammar">You Don't Know JS: Types &amp; Grammar</h1>
<h1 id="foreword">Foreword</h1>
<p>It was once said, &quot;JavaScript is the only language developers don't learn to use before using it.&quot;</p>
<p>I laugh each time I hear that quote because it was true for me and I suspect it was for many other developers. JavaScript, and maybe even CSS and HTML, were not a core computer science language taught at college in the Internet's early days, so personal development was very much based on the budding developer's search and &quot;view source&quot; abilities to piece together these basic web languages.</p>
<p>I still remember my first high school website project. The task was to create any type of web store, and me being a James Bond fan, I decided to create a Goldeneye store. It had everything: the Goldeneye midi theme song playing in the background, a JavaScript-powered crosshairs following the mouse around the screen, and a gunshot sound that played upon every click. Q would have been proud of this masterpiece of a website.</p>
<p>I tell that story because I did back then what many developers are doing today: I copied and pasted chunks of JavaScript code into my project without having a clue what's actually happening. The widespread use of JavaScript toolkits like jQuery have, in their own small way, perpetuated this pattern of nonlearning of core JavaScript.</p>
<p>I'm not disparaging JavaScript toolkit use; after all, I'm a member of the MooTools JavaScript team! But the reason JavaScript toolkits are as powerful as they are is because their developers know the fundamentals, and their &quot;gotchas,&quot; and apply them magnificently. As useful as these toolkits are, it's still incredibly important to know the basics of the language, and with books like Kyle Simpson's <em>You Don't Know JS</em> series, there's no excuse not to learn them.</p>
<p><em>Types and Grammar</em>, the third installment of the series, is an excellent look at the core JavaScript fundamentals that copy and paste and JavaScript toolkits don't and could never teach you. Coercion and its pitfalls, natives as constructors, and the whole gamut of JavaScript basics are thoroughly explained with focused code examples. Like the other books in this series, Kyle cuts straight to the point: no fluff and word-smithing -- exactly the type of tech book I love.</p>
<p>Enjoy Types and Grammar and don't let it get too far away from your desk!</p>
<p>David Walsh<br/> <a href="http://davidwalsh.name" class="uri">http://davidwalsh.name</a>, <span class="citation" data-cites="davidwalshblog">[@davidwalshblog]</span>(http://twitter.com/davidwalshblog)<br/> Senior Web Developer, Mozilla</p>
<h1 id="you-dont-know-js-types-grammar-1">You Don't Know JS: Types &amp; Grammar</h1>
<h1 id="chapter-1-types">Chapter 1: Types</h1>
<p>Most developers would say that a dynamic language (like JS) does not have <em>types</em>. Let's see what the ES5.1 specification (http://www.ecma-international.org/ecma-262/5.1/) has to say on the topic:</p>
<blockquote>
<p>Algorithms within this specification manipulate values each of which has an associated type. The possible value types are exactly those defined in this clause. Types are further sub classified into ECMAScript language types and specification types.</p>
<p>An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.</p>
</blockquote>
<p>Now, if you're a fan of strongly typed (statically typed) languages, you may object to this usage of the word &quot;type.&quot; In those languages, &quot;type&quot; means a whole lot <em>more</em> than it does here in JS.</p>
<p>Some people say JS shouldn't claim to have &quot;types,&quot; and they should instead be called &quot;tags&quot; or perhaps &quot;subtypes&quot;.</p>
<p>Bah! We're going to use this rough definition (the same one that seems to drive the wording of the spec): a <em>type</em> is an intrinsic, built-in set of characteristics that uniquely identifies the behavior of a particular value and distinguishes it from other values, both to the engine <strong>and to the developer</strong>.</p>
<p>In other words, if both the engine and the developer treat value <code>42</code> (the number) differently than they treat value <code>&quot;42&quot;</code> (the string), then those two values have different <em>types</em> -- <code>number</code> and <code>string</code>, respectively. When you use <code>42</code>, you are <em>intending</em> to do something numeric, like math. But when you use <code>&quot;42&quot;</code>, you are <em>intending</em> to do something string'ish, like outputting to the page, etc. <strong>These two values have different types.</strong></p>
<p>That's by no means a perfect definition. But it's good enough for this discussion. And it's consistent with how JS describes itself.</p>
<h1 id="a-type-by-any-other-name...">A Type By Any Other Name...</h1>
<p>Beyond academic definition disagreements, why does it matter if JavaScript has <em>types</em> or not?</p>
<p>Having a proper understanding of each <em>type</em> and its intrinsic behavior is absolutely essential to understanding how to properly and accurately convert values to different types (see Coercion, Chapter 4). Nearly every JS program ever written will need to handle value coercion in some shape or form, so it's important you do so responsibly and with confidence.</p>
<p>If you have the <code>number</code> value <code>42</code>, but you want to treat it like a <code>string</code>, such as pulling out the <code>&quot;2&quot;</code> as a character in position <code>1</code>, you obviously must first convert (coerce) the value from <code>number</code> to <code>string</code>.</p>
<p>That seems simple enough.</p>
<p>But there are many different ways that such coercion can happen. Some of these ways are explicit, easy to reason about, and reliable. But if you're not careful, coercion can happen in very strange and surprising ways.</p>
<p>Coercion confusion is perhaps one of the most profound frustrations for JavaScript developers. It has often been criticized as being so <em>dangerous</em> as to be considered a flaw in the design of the language, to be shunned and avoided.</p>
<p>Armed with a full understanding of JavaScript types, we're aiming to illustrate why coercion's <em>bad reputation</em> is largely overhyped and somewhat undeserved -- to flip your perspective, to seeing coercion's power and usefulness. But first, we have to get a much better grip on values and types.</p>
<h2 id="built-in-types">Built-in Types</h2>
<p>JavaScript defines seven built-in types:</p>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>boolean</code></li>
<li><code>number</code></li>
<li><code>string</code></li>
<li><code>object</code></li>
<li><code>symbol</code> -- added in ES6!</li>
</ul>
<p><strong>Note:</strong> All of these types except <code>object</code> are called &quot;primitives&quot;.</p>
<p>The <code>typeof</code> operator inspects the type of the given value, and always returns one of seven string values -- surprisingly, there's not an exact 1-to-1 match with the seven built-in types we just listed.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">typeof</span> <span class="kw">undefined</span>     <span class="op">===</span> <span class="st">&quot;undefined&quot;</span><span class="op">;</span> <span class="co">// true</span>
<span class="kw">typeof</span> <span class="kw">true</span>          <span class="op">===</span> <span class="st">&quot;boolean&quot;</span><span class="op">;</span>   <span class="co">// true</span>
<span class="kw">typeof</span> <span class="dv">42</span>            <span class="op">===</span> <span class="st">&quot;number&quot;</span><span class="op">;</span>    <span class="co">// true</span>
<span class="kw">typeof</span> <span class="st">&quot;42&quot;</span>          <span class="op">===</span> <span class="st">&quot;string&quot;</span><span class="op">;</span>    <span class="co">// true</span>
<span class="kw">typeof</span> <span class="op">{</span> <span class="dt">life</span><span class="op">:</span> <span class="dv">42</span> <span class="op">}</span>  <span class="op">===</span> <span class="st">&quot;object&quot;</span><span class="op">;</span>    <span class="co">// true</span>

<span class="co">// added in ES6!</span>
<span class="kw">typeof</span> <span class="at">Symbol</span>()      <span class="op">===</span> <span class="st">&quot;symbol&quot;</span><span class="op">;</span>    <span class="co">// true</span></code></pre></div>
<p>These six listed types have values of the corresponding type and return a string value of the same name, as shown. <code>Symbol</code> is a new data type as of ES6, and will be covered in Chapter 3.</p>
<p>As you may have noticed, I excluded <code>null</code> from the above listing. It's <em>special</em> -- special in the sense that it's buggy when combined with the <code>typeof</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">typeof</span> <span class="kw">null</span> <span class="op">===</span> <span class="st">&quot;object&quot;</span><span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>It would have been nice (and correct!) if it returned <code>&quot;null&quot;</code>, but this original bug in JS has persisted for nearly two decades, and will likely never be fixed because there's too much existing web content that relies on its buggy behavior that &quot;fixing&quot; the bug would <em>create</em> more &quot;bugs&quot; and break a lot of web software.</p>
<p>If you want to test for a <code>null</code> value using its type, you need a compound condition:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>

(<span class="op">!</span>a <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> a <span class="op">===</span> <span class="st">&quot;object&quot;</span>)<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p><code>null</code> is the only primitive value that is &quot;falsy&quot; (aka false-like; see Chapter 4) but that also returns <code>&quot;object&quot;</code> from the <code>typeof</code> check.</p>
<p>So what's the seventh string value that <code>typeof</code> can return?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">typeof</span> <span class="kw">function</span> <span class="at">a</span>()<span class="op">{</span> <span class="co">/* .. */</span> <span class="op">}</span> <span class="op">===</span> <span class="st">&quot;function&quot;</span><span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>It's easy to think that <code>function</code> would be a top-level built-in type in JS, especially given this behavior of the <code>typeof</code> operator. However, if you read the spec, you'll see it's actually a &quot;subtype&quot; of object. Specifically, a function is referred to as a &quot;callable object&quot; -- an object that has an internal <code>[[Call]]</code> property that allows it to be invoked.</p>
<p>The fact that functions are actually objects is quite useful. Most importantly, they can have properties. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">a</span>(b<span class="op">,</span>c) <span class="op">{</span>
    <span class="co">/* .. */</span>
<span class="op">}</span></code></pre></div>
<p>The function object has a <code>length</code> property set to the number of formal parameters it is declared with.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">a</span>.<span class="at">length</span><span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>Since you declared the function with two formal named parameters (<code>b</code> and <code>c</code>), the &quot;length of the function&quot; is <code>2</code>.</p>
<p>What about arrays? They're native to JS, so are they a special type?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">typeof</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>] <span class="op">===</span> <span class="st">&quot;object&quot;</span><span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>Nope, just objects. It's most appropriate to think of them also as a &quot;subtype&quot; of object (see Chapter 3), in this case with the additional characteristics of being numerically indexed (as opposed to just being string-keyed like plain objects) and maintaining an automatically updated <code>.length</code> property.</p>
<h2 id="values-as-types">Values as Types</h2>
<p>In JavaScript, variables don't have types -- <strong>values have types</strong>. Variables can hold any value, at any time.</p>
<p>Another way to think about JS types is that JS doesn't have &quot;type enforcement,&quot; in that the engine doesn't insist that a <em>variable</em> always holds values of the <em>same initial type</em> that it starts out with. A variable can, in one assignment statement, hold a <code>string</code>, and in the next hold a <code>number</code>, and so on.</p>
<p>The <em>value</em> <code>42</code> has an intrinsic type of <code>number</code>, and its <em>type</em> cannot be changed. Another value, like <code>&quot;42&quot;</code> with the <code>string</code> type, can be created <em>from</em> the <code>number</code> value <code>42</code> through a process called <strong>coercion</strong> (see Chapter 4).</p>
<p>If you use <code>typeof</code> against a variable, it's not asking &quot;what's the type of the variable?&quot; as it may seem, since JS variables have no types. Instead, it's asking &quot;what's the type of the value <em>in</em> the variable?&quot;</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">typeof</span> a<span class="op">;</span> <span class="co">// &quot;number&quot;</span>

a <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
<span class="kw">typeof</span> a<span class="op">;</span> <span class="co">// &quot;boolean&quot;</span></code></pre></div>
<p>The <code>typeof</code> operator always returns a string. So:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">typeof</span> <span class="kw">typeof</span> <span class="dv">42</span><span class="op">;</span> <span class="co">// &quot;string&quot;</span></code></pre></div>
<p>The first <code>typeof 42</code> returns <code>&quot;number&quot;</code>, and <code>typeof &quot;number&quot;</code> is <code>&quot;string&quot;</code>.</p>
<h3 id="undefined-vs-undeclared"><code>undefined</code> vs &quot;undeclared&quot;</h3>
<p>Variables that have no value <em>currently</em>, actually have the <code>undefined</code> value. Calling <code>typeof</code> against such variables will return <code>&quot;undefined&quot;</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a<span class="op">;</span>

<span class="kw">typeof</span> a<span class="op">;</span> <span class="co">// &quot;undefined&quot;</span>

<span class="kw">var</span> b <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> c<span class="op">;</span>

<span class="co">// later</span>
b <span class="op">=</span> c<span class="op">;</span>

<span class="kw">typeof</span> b<span class="op">;</span> <span class="co">// &quot;undefined&quot;</span>
<span class="kw">typeof</span> c<span class="op">;</span> <span class="co">// &quot;undefined&quot;</span></code></pre></div>
<p>It's tempting for most developers to think of the word &quot;undefined&quot; and think of it as a synonym for &quot;undeclared.&quot; However, in JS, these two concepts are quite different.</p>
<p>An &quot;undefined&quot; variable is one that has been declared in the accessible scope, but <em>at the moment</em> has no other value in it. By contrast, an &quot;undeclared&quot; variable is one that has not been formally declared in the accessible scope.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a<span class="op">;</span>

a<span class="op">;</span> <span class="co">// undefined</span>
b<span class="op">;</span> <span class="co">// ReferenceError: b is not defined</span></code></pre></div>
<p>An annoying confusion is the error message that browsers assign to this condition. As you can see, the message is &quot;b is not defined,&quot; which is of course very easy and reasonable to confuse with &quot;b is undefined.&quot; Yet again, &quot;undefined&quot; and &quot;is not defined&quot; are very different things. It'd be nice if the browsers said something like &quot;b is not found&quot; or &quot;b is not declared,&quot; to reduce the confusion!</p>
<p>There's also a special behavior associated with <code>typeof</code> as it relates to undeclared variables that even further reinforces the confusion. Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a<span class="op">;</span>

<span class="kw">typeof</span> a<span class="op">;</span> <span class="co">// &quot;undefined&quot;</span>

<span class="kw">typeof</span> b<span class="op">;</span> <span class="co">// &quot;undefined&quot;</span></code></pre></div>
<p>The <code>typeof</code> operator returns <code>&quot;undefined&quot;</code> even for &quot;undeclared&quot; (or &quot;not defined&quot;) variables. Notice that there was no error thrown when we executed <code>typeof b</code>, even though <code>b</code> is an undeclared variable. This is a special safety guard in the behavior of <code>typeof</code>.</p>
<p>Similar to above, it would have been nice if <code>typeof</code> used with an undeclared variable returned &quot;undeclared&quot; instead of conflating the result value with the different &quot;undefined&quot; case.</p>
<h3 id="typeof-undeclared"><code>typeof</code> Undeclared</h3>
<p>Nevertheless, this safety guard is a useful feature when dealing with JavaScript in the browser, where multiple script files can load variables into the shared global namespace.</p>
<p><strong>Note:</strong> Many developers believe there should never be any variables in the global namespace, and that everything should be contained in modules and private/separate namespaces. This is great in theory but nearly impossible in practicality; still it's a good goal to strive toward! Fortunately, ES6 added first-class support for modules, which will eventually make that much more practical.</p>
<p>As a simple example, imagine having a &quot;debug mode&quot; in your program that is controlled by a global variable (flag) called <code>DEBUG</code>. You'd want to check if that variable was declared before performing a debug task like logging a message to the console. A top-level global <code>var DEBUG = true</code> declaration would only be included in a &quot;debug.js&quot; file, which you only load into the browser when you're in development/testing, but not in production.</p>
<p>However, you have to take care in how you check for the global <code>DEBUG</code> variable in the rest of your application code, so that you don't throw a <code>ReferenceError</code>. The safety guard on <code>typeof</code> is our friend in this case.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// oops, this would throw an error!</span>
<span class="cf">if</span> (DEBUG) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Debugging is starting&quot;</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="co">// this is a safe existence check</span>
<span class="cf">if</span> (<span class="kw">typeof</span> DEBUG <span class="op">!==</span> <span class="st">&quot;undefined&quot;</span>) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Debugging is starting&quot;</span> )<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>This sort of check is useful even if you're not dealing with user-defined variables (like <code>DEBUG</code>). If you are doing a feature check for a built-in API, you may also find it helpful to check without throwing an error:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="kw">typeof</span> atob <span class="op">===</span> <span class="st">&quot;undefined&quot;</span>) <span class="op">{</span>
    atob <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span> <span class="co">/*..*/</span> <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p><strong>Note:</strong> If you're defining a &quot;polyfill&quot; for a feature if it doesn't already exist, you probably want to avoid using <code>var</code> to make the <code>atob</code> declaration. If you declare <code>var atob</code> inside the <code>if</code> statement, this declaration is hoisted (see the <em>Scope &amp; Closures</em> title of this series) to the top of the scope, even if the <code>if</code> condition doesn't pass (because the global <code>atob</code> already exists!). In some browsers and for some special types of global built-in variables (often called &quot;host objects&quot;), this duplicate declaration may throw an error. Omitting the <code>var</code> prevents this hoisted declaration.</p>
<p>Another way of doing these checks against global variables but without the safety guard feature of <code>typeof</code> is to observe that all global variables are also properties of the global object, which in the browser is basically the <code>window</code> object. So, the above checks could have been done (quite safely) as:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="va">window</span>.<span class="at">DEBUG</span>) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span>

<span class="cf">if</span> (<span class="op">!</span><span class="va">window</span>.<span class="at">atob</span>) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>Unlike referencing undeclared variables, there is no <code>ReferenceError</code> thrown if you try to access an object property (even on the global <code>window</code> object) that doesn't exist.</p>
<p>On the other hand, manually referencing the global variable with a <code>window</code> reference is something some developers prefer to avoid, especially if your code needs to run in multiple JS environments (not just browsers, but server-side node.js, for instance), where the global object may not always be called <code>window</code>.</p>
<p>Technically, this safety guard on <code>typeof</code> is useful even if you're not using global variables, though these circumstances are less common, and some developers may find this design approach less desirable. Imagine a utility function that you want others to copy-and-paste into their programs or modules, in which you want to check to see if the including program has defined a certain variable (so that you can use it) or not:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">doSomethingCool</span>() <span class="op">{</span>
    <span class="kw">var</span> helper <span class="op">=</span>
        (<span class="kw">typeof</span> FeatureXYZ <span class="op">!==</span> <span class="st">&quot;undefined&quot;</span>) <span class="op">?</span>
        FeatureXYZ :
        <span class="kw">function</span>() <span class="op">{</span> <span class="co">/*.. default feature ..*/</span> <span class="op">};</span>

    <span class="kw">var</span> val <span class="op">=</span> <span class="at">helper</span>()<span class="op">;</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p><code>doSomethingCool()</code> tests for a variable called <code>FeatureXYZ</code>, and if found, uses it, but if not, uses its own. Now, if someone includes this utility in their module/program, it safely checks if they've defined <code>FeatureXYZ</code> or not:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// an IIFE (see &quot;Immediately Invoked Function Expressions&quot;</span>
<span class="co">// discussion in the *Scope &amp; Closures* title of this series)</span>
(<span class="kw">function</span>()<span class="op">{</span>
    <span class="kw">function</span> <span class="at">FeatureXYZ</span>() <span class="op">{</span> <span class="co">/*.. my XYZ feature ..*/</span> <span class="op">}</span>

    <span class="co">// include `doSomethingCool(..)`</span>
    <span class="kw">function</span> <span class="at">doSomethingCool</span>() <span class="op">{</span>
        <span class="kw">var</span> helper <span class="op">=</span>
            (<span class="kw">typeof</span> FeatureXYZ <span class="op">!==</span> <span class="st">&quot;undefined&quot;</span>) <span class="op">?</span>
            FeatureXYZ :
            <span class="kw">function</span>() <span class="op">{</span> <span class="co">/*.. default feature ..*/</span> <span class="op">};</span>

        <span class="kw">var</span> val <span class="op">=</span> <span class="at">helper</span>()<span class="op">;</span>
        <span class="co">// ..</span>
    <span class="op">}</span>

    <span class="at">doSomethingCool</span>()<span class="op">;</span>
<span class="op">}</span>)()<span class="op">;</span></code></pre></div>
<p>Here, <code>FeatureXYZ</code> is not at all a global variable, but we're still using the safety guard of <code>typeof</code> to make it safe to check for. And importantly, here there is <em>no</em> object we can use (like we did for global variables with <code>window.___</code>) to make the check, so <code>typeof</code> is quite helpful.</p>
<p>Other developers would prefer a design pattern called &quot;dependency injection,&quot; where instead of <code>doSomethingCool()</code> inspecting implicitly for <code>FeatureXYZ</code> to be defined outside/around it, it would need to have the dependency explicitly passed in, like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">doSomethingCool</span>(FeatureXYZ) <span class="op">{</span>
    <span class="kw">var</span> helper <span class="op">=</span> FeatureXYZ <span class="op">||</span>
        <span class="kw">function</span>() <span class="op">{</span> <span class="co">/*.. default feature ..*/</span> <span class="op">};</span>

    <span class="kw">var</span> val <span class="op">=</span> <span class="at">helper</span>()<span class="op">;</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>There are lots of options when designing such functionality. No one pattern here is &quot;correct&quot; or &quot;wrong&quot; -- there are various tradeoffs to each approach. But overall, it's nice that the <code>typeof</code> undeclared safety guard gives us more options.</p>
<h2 id="review">Review</h2>
<p>JavaScript has seven built-in <em>types</em>: <code>null</code>, <code>undefined</code>, <code>boolean</code>, <code>number</code>, <code>string</code>, <code>object</code>, <code>symbol</code>. They can be identified by the <code>typeof</code> operator.</p>
<p>Variables don't have types, but the values in them do. These types define intrinsic behavior of the values.</p>
<p>Many developers will assume &quot;undefined&quot; and &quot;undeclared&quot; are roughly the same thing, but in JavaScript, they're quite different. <code>undefined</code> is a value that a declared variable can hold. &quot;Undeclared&quot; means a variable has never been declared.</p>
<p>JavaScript unfortunately kind of conflates these two terms, not only in its error messages (&quot;ReferenceError: a is not defined&quot;) but also in the return values of <code>typeof</code>, which is <code>&quot;undefined&quot;</code> for both cases.</p>
<p>However, the safety guard (preventing an error) on <code>typeof</code> when used against an undeclared variable can be helpful in certain cases.</p>
<h1 id="you-dont-know-js-types-grammar-2">You Don't Know JS: Types &amp; Grammar</h1>
<h1 id="chapter-2-values">Chapter 2: Values</h1>
<p><code>array</code>s, <code>string</code>s, and <code>number</code>s are the most basic building-blocks of any program, but JavaScript has some unique characteristics with these types that may either delight or confound you.</p>
<p>Let's look at several of the built-in value types in JS, and explore how we can more fully understand and correctly leverage their behaviors.</p>
<h2 id="arrays">Arrays</h2>
<p>As compared to other type-enforced languages, JavaScript <code>array</code>s are just containers for any type of value, from <code>string</code> to <code>number</code> to <code>object</code> to even another <code>array</code> (which is how you get multidimensional <code>array</code>s).</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [ <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> [<span class="dv">3</span>] ]<span class="op">;</span>

<span class="va">a</span>.<span class="at">length</span><span class="op">;</span>       <span class="co">// 3</span>
a[<span class="dv">0</span>] <span class="op">===</span> <span class="dv">1</span><span class="op">;</span>     <span class="co">// true</span>
a[<span class="dv">2</span>][<span class="dv">0</span>] <span class="op">===</span> <span class="dv">3</span><span class="op">;</span>  <span class="co">// true</span></code></pre></div>
<p>You don't need to presize your <code>array</code>s (see &quot;Arrays&quot; in Chapter 3), you can just declare them and add values as you see fit:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [ ]<span class="op">;</span>

<span class="va">a</span>.<span class="at">length</span><span class="op">;</span>   <span class="co">// 0</span>

a[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
a[<span class="dv">1</span>] <span class="op">=</span> <span class="st">&quot;2&quot;</span><span class="op">;</span>
a[<span class="dv">2</span>] <span class="op">=</span> [ <span class="dv">3</span> ]<span class="op">;</span>

<span class="va">a</span>.<span class="at">length</span><span class="op">;</span>   <span class="co">// 3</span></code></pre></div>
<p><strong>Warning:</strong> Using <code>delete</code> on an <code>array</code> value will remove that slot from the <code>array</code>, but even if you remove the final element, it does <strong>not</strong> update the <code>length</code> property, so be careful! We'll cover the <code>delete</code> operator itself in more detail in Chapter 5.</p>
<p>Be careful about creating &quot;sparse&quot; <code>array</code>s (leaving or creating empty/missing slots):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [ ]<span class="op">;</span>

a[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
<span class="co">// no `a[1]` slot set here</span>
a[<span class="dv">2</span>] <span class="op">=</span> [ <span class="dv">3</span> ]<span class="op">;</span>

a[<span class="dv">1</span>]<span class="op">;</span>       <span class="co">// undefined</span>

<span class="va">a</span>.<span class="at">length</span><span class="op">;</span>   <span class="co">// 3</span></code></pre></div>
<p>While that works, it can lead to some confusing behavior with the &quot;empty slots&quot; you leave in between. While the slot appears to have the <code>undefined</code> value in it, it will not behave the same as if the slot is explicitly set (<code>a[1] = undefined</code>). See &quot;Arrays&quot; in Chapter 3 for more information.</p>
<p><code>array</code>s are numerically indexed (as you'd expect), but the tricky thing is that they also are objects that can have <code>string</code> keys/properties added to them (but which don't count toward the <code>length</code> of the <code>array</code>):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [ ]<span class="op">;</span>

a[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
a[<span class="st">&quot;foobar&quot;</span>] <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>

<span class="va">a</span>.<span class="at">length</span><span class="op">;</span>       <span class="co">// 1</span>
a[<span class="st">&quot;foobar&quot;</span>]<span class="op">;</span>    <span class="co">// 2</span>
<span class="va">a</span>.<span class="at">foobar</span><span class="op">;</span>       <span class="co">// 2</span></code></pre></div>
<p>However, a gotcha to be aware of is that if a <code>string</code> value intended as a key can be coerced to a standard base-10 <code>number</code>, then it is assumed that you wanted to use it as a <code>number</code> index rather than as a <code>string</code> key!</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [ ]<span class="op">;</span>

a[<span class="st">&quot;13&quot;</span>] <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>

<span class="va">a</span>.<span class="at">length</span><span class="op">;</span> <span class="co">// 14</span></code></pre></div>
<p>Generally, it's not a great idea to add <code>string</code> keys/properties to <code>array</code>s. Use <code>object</code>s for holding values in keys/properties, and save <code>array</code>s for strictly numerically indexed values.</p>
<h3 id="array-likes">Array-Likes</h3>
<p>There will be occasions where you need to convert an <code>array</code>-like value (a numerically indexed collection of values) into a true <code>array</code>, usually so you can call array utilities (like <code>indexOf(..)</code>, <code>concat(..)</code>, <code>forEach(..)</code>, etc.) against the collection of values.</p>
<p>For example, various DOM query operations return lists of DOM elements that are not true <code>array</code>s but are <code>array</code>-like enough for our conversion purposes. Another common example is when functions expose the <code>arguments</code> (<code>array</code>-like) object (as of ES6, deprecated) to access the arguments as a list.</p>
<p>One very common way to make such a conversion is to borrow the <code>slice(..)</code> utility against the value:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="kw">var</span> arr <span class="op">=</span> <span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">slice</span>.<span class="at">call</span>( arguments )<span class="op">;</span>
    <span class="va">arr</span>.<span class="at">push</span>( <span class="st">&quot;bam&quot;</span> )<span class="op">;</span>
    <span class="va">console</span>.<span class="at">log</span>( arr )<span class="op">;</span>
<span class="op">}</span>

<span class="at">foo</span>( <span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="st">&quot;baz&quot;</span> )<span class="op">;</span> <span class="co">// [&quot;bar&quot;,&quot;baz&quot;,&quot;bam&quot;]</span></code></pre></div>
<p>If <code>slice()</code> is called without any other parameters, as it effectively is in the above snippet, the default values for its parameters have the effect of duplicating the <code>array</code> (or, in this case, <code>array</code>-like).</p>
<p>As of ES6, there's also a built-in utility called <code>Array.from(..)</code> that can do the same task:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">...
<span class="kw">var</span> arr <span class="op">=</span> <span class="va">Array</span>.<span class="at">from</span>( arguments )<span class="op">;</span>
...</code></pre></div>
<p><strong>Note:</strong> <code>Array.from(..)</code> has several powerful capabilities, and will be covered in detail in the <em>ES6 &amp; Beyond</em> title of this series.</p>
<h2 id="strings">Strings</h2>
<p>It's a very common belief that <code>string</code>s are essentially just <code>array</code>s of characters. While the implementation under the covers may or may not use <code>array</code>s, it's important to realize that JavaScript <code>string</code>s are really not the same as <code>array</code>s of characters. The similarity is mostly just skin-deep.</p>
<p>For example, let's consider these two values:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> [<span class="st">&quot;f&quot;</span><span class="op">,</span><span class="st">&quot;o&quot;</span><span class="op">,</span><span class="st">&quot;o&quot;</span>]<span class="op">;</span></code></pre></div>
<p>Strings do have a shallow resemblance to <code>array</code>s -- <code>array</code>-likes, as above -- for instance, both of them having a <code>length</code> property, an <code>indexOf(..)</code> method (<code>array</code> version only as of ES5), and a <code>concat(..)</code> method:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">a</span>.<span class="at">length</span><span class="op">;</span>                           <span class="co">// 3</span>
<span class="va">b</span>.<span class="at">length</span><span class="op">;</span>                           <span class="co">// 3</span>

<span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;o&quot;</span> )<span class="op">;</span>                   <span class="co">// 1</span>
<span class="va">b</span>.<span class="at">indexOf</span>( <span class="st">&quot;o&quot;</span> )<span class="op">;</span>                   <span class="co">// 1</span>

<span class="kw">var</span> c <span class="op">=</span> <span class="va">a</span>.<span class="at">concat</span>( <span class="st">&quot;bar&quot;</span> )<span class="op">;</span>          <span class="co">// &quot;foobar&quot;</span>
<span class="kw">var</span> d <span class="op">=</span> <span class="va">b</span>.<span class="at">concat</span>( [<span class="st">&quot;b&quot;</span><span class="op">,</span><span class="st">&quot;a&quot;</span><span class="op">,</span><span class="st">&quot;r&quot;</span>] )<span class="op">;</span>  <span class="co">// [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;,&quot;b&quot;,&quot;a&quot;,&quot;r&quot;]</span>

a <span class="op">===</span> c<span class="op">;</span>                            <span class="co">// false</span>
b <span class="op">===</span> d<span class="op">;</span>                            <span class="co">// false</span>

a<span class="op">;</span>                                  <span class="co">// &quot;foo&quot;</span>
b<span class="op">;</span>                                  <span class="co">// [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;]</span></code></pre></div>
<p>So, they're both basically just &quot;arrays of characters&quot;, right? <strong>Not exactly</strong>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">a[<span class="dv">1</span>] <span class="op">=</span> <span class="st">&quot;O&quot;</span><span class="op">;</span>
b[<span class="dv">1</span>] <span class="op">=</span> <span class="st">&quot;O&quot;</span><span class="op">;</span>

a<span class="op">;</span> <span class="co">// &quot;foo&quot;</span>
b<span class="op">;</span> <span class="co">// [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;]</span></code></pre></div>
<p>JavaScript <code>string</code>s are immutable, while <code>array</code>s are quite mutable. Moreover, the <code>a[1]</code> character position access form was not always widely valid JavaScript. Older versions of IE did not allow that syntax (but now they do). Instead, the <em>correct</em> approach has been <code>a.charAt(1)</code>.</p>
<p>A further consequence of immutable <code>string</code>s is that none of the <code>string</code> methods that alter its contents can modify in-place, but rather must create and return new <code>string</code>s. By contrast, many of the methods that change <code>array</code> contents actually <em>do</em> modify in-place.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">c <span class="op">=</span> <span class="va">a</span>.<span class="at">toUpperCase</span>()<span class="op">;</span>
a <span class="op">===</span> c<span class="op">;</span>    <span class="co">// false</span>
a<span class="op">;</span>          <span class="co">// &quot;foo&quot;</span>
c<span class="op">;</span>          <span class="co">// &quot;FOO&quot;</span>

<span class="va">b</span>.<span class="at">push</span>( <span class="st">&quot;!&quot;</span> )<span class="op">;</span>
b<span class="op">;</span>          <span class="co">// [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;,&quot;!&quot;]</span></code></pre></div>
<p>Also, many of the <code>array</code> methods that could be helpful when dealing with <code>string</code>s are not actually available for them, but we can &quot;borrow&quot; non-mutation <code>array</code> methods against our <code>string</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">a</span>.<span class="at">join</span><span class="op">;</span>         <span class="co">// undefined</span>
<span class="va">a</span>.<span class="at">map</span><span class="op">;</span>          <span class="co">// undefined</span>

<span class="kw">var</span> c <span class="op">=</span> <span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">join</span>.<span class="at">call</span>( a<span class="op">,</span> <span class="st">&quot;-&quot;</span> )<span class="op">;</span>
<span class="kw">var</span> d <span class="op">=</span> <span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">map</span>.<span class="at">call</span>( a<span class="op">,</span> <span class="kw">function</span>(v)<span class="op">{</span>
    <span class="cf">return</span> <span class="va">v</span>.<span class="at">toUpperCase</span>() <span class="op">+</span> <span class="st">&quot;.&quot;</span><span class="op">;</span>
<span class="op">}</span> ).<span class="at">join</span>( <span class="st">&quot;&quot;</span> )<span class="op">;</span>

c<span class="op">;</span>              <span class="co">// &quot;f-o-o&quot;</span>
d<span class="op">;</span>              <span class="co">// &quot;F.O.O.&quot;</span></code></pre></div>
<p>Let's take another example: reversing a <code>string</code> (incidentally, a common JavaScript interview trivia question!). <code>array</code>s have a <code>reverse()</code> in-place mutator method, but <code>string</code>s do not:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">a</span>.<span class="at">reverse</span><span class="op">;</span>      <span class="co">// undefined</span>

<span class="va">b</span>.<span class="at">reverse</span>()<span class="op">;</span>    <span class="co">// [&quot;!&quot;,&quot;o&quot;,&quot;O&quot;,&quot;f&quot;]</span>
b<span class="op">;</span>              <span class="co">// [&quot;!&quot;,&quot;o&quot;,&quot;O&quot;,&quot;f&quot;]</span></code></pre></div>
<p>Unfortunately, this &quot;borrowing&quot; doesn't work with <code>array</code> mutators, because <code>string</code>s are immutable and thus can't be modified in place:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">reverse</span>.<span class="at">call</span>( a )<span class="op">;</span>
<span class="co">// still returns a String object wrapper (see Chapter 3)</span>
<span class="co">// for &quot;foo&quot; :(</span></code></pre></div>
<p>Another workaround (aka hack) is to convert the <code>string</code> into an <code>array</code>, perform the desired operation, then convert it back to a <code>string</code>.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> c <span class="op">=</span> a
    <span class="co">// split `a` into an array of characters</span>
    .<span class="at">split</span>( <span class="st">&quot;&quot;</span> )
    <span class="co">// reverse the array of characters</span>
    .<span class="at">reverse</span>()
    <span class="co">// join the array of characters back to a string</span>
    .<span class="at">join</span>( <span class="st">&quot;&quot;</span> )<span class="op">;</span>

c<span class="op">;</span> <span class="co">// &quot;oof&quot;</span></code></pre></div>
<p>If that feels ugly, it is. Nevertheless, <em>it works</em> for simple <code>string</code>s, so if you need something quick-n-dirty, often such an approach gets the job done.</p>
<p><strong>Warning:</strong> Be careful! This approach <strong>doesn't work</strong> for <code>string</code>s with complex (unicode) characters in them (astral symbols, multibyte characters, etc.). You need more sophisticated library utilities that are unicode-aware for such operations to be handled accurately. Consult Mathias Bynens' work on the subject: <em>Esrever</em> (https://github.com/mathiasbynens/esrever).</p>
<p>The other way to look at this is: if you are more commonly doing tasks on your &quot;strings&quot; that treat them as basically <em>arrays of characters</em>, perhaps it's better to just actually store them as <code>array</code>s rather than as <code>string</code>s. You'll probably save yourself a lot of hassle of converting from <code>string</code> to <code>array</code> each time. You can always call <code>join(&quot;&quot;)</code> on the <code>array</code> <em>of characters</em> whenever you actually need the <code>string</code> representation.</p>
<h2 id="numbers">Numbers</h2>
<p>JavaScript has just one numeric type: <code>number</code>. This type includes both &quot;integer&quot; values and fractional decimal numbers. I say &quot;integer&quot; in quotes because it's long been a criticism of JS that there are not true integers, as there are in other languages. That may change at some point in the future, but for now, we just have <code>number</code>s for everything.</p>
<p>So, in JS, an &quot;integer&quot; is just a value that has no fractional decimal value. That is, <code>42.0</code> is as much an &quot;integer&quot; as <code>42</code>.</p>
<p>Like most modern languages, including practically all scripting languages, the implementation of JavaScript's <code>number</code>s is based on the &quot;IEEE 754&quot; standard, often called &quot;floating-point.&quot; JavaScript specifically uses the &quot;double precision&quot; format (aka &quot;64-bit binary&quot;) of the standard.</p>
<p>There are many great write-ups on the Web about the nitty-gritty details of how binary floating-point numbers are stored in memory, and the implications of those choices. Because understanding bit patterns in memory is not strictly necessary to understand how to correctly use <code>number</code>s in JS, we'll leave it as an exercise for the interested reader if you'd like to dig further into IEEE 754 details.</p>
<h3 id="numeric-syntax">Numeric Syntax</h3>
<p>Number literals are expressed in JavaScript generally as base-10 decimal literals. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="fl">42.3</span><span class="op">;</span></code></pre></div>
<p>The leading portion of a decimal value, if <code>0</code>, is optional:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="fl">0.42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> .<span class="dv">42</span><span class="op">;</span></code></pre></div>
<p>Similarly, the trailing portion (the fractional) of a decimal value after the <code>.</code>, if <code>0</code>, is optional:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="fl">42.0</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="dv">42</span>.<span class="op">;</span></code></pre></div>
<p><strong>Warning:</strong> <code>42.</code> is pretty uncommon, and probably not a great idea if you're trying to avoid confusion when other people read your code. But it is, nevertheless, valid.</p>
<p>By default, most <code>number</code>s will be outputted as base-10 decimals, with trailing fractional <code>0</code>s removed. So:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="fl">42.300</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="fl">42.0</span><span class="op">;</span>

a<span class="op">;</span> <span class="co">// 42.3</span>
b<span class="op">;</span> <span class="co">// 42</span></code></pre></div>
<p>Very large or very small <code>number</code>s will by default be outputted in exponent form, the same as the output of the <code>toExponential()</code> method, like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="fl">5E10</span><span class="op">;</span>
a<span class="op">;</span>                  <span class="co">// 50000000000</span>
<span class="va">a</span>.<span class="at">toExponential</span>()<span class="op">;</span>  <span class="co">// &quot;5e+10&quot;</span>

<span class="kw">var</span> b <span class="op">=</span> a <span class="op">*</span> a<span class="op">;</span>
b<span class="op">;</span>                  <span class="co">// 2.5e+21</span>

<span class="kw">var</span> c <span class="op">=</span> <span class="dv">1</span> / a<span class="op">;</span>
c<span class="op">;</span>                  <span class="co">// 2e-11</span></code></pre></div>
<p>Because <code>number</code> values can be boxed with the <code>Number</code> object wrapper (see Chapter 3), <code>number</code> values can access methods that are built into the <code>Number.prototype</code> (see Chapter 3). For example, the <code>toFixed(..)</code> method allows you to specify how many fractional decimal places you'd like the value to be represented with:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="fl">42.59</span><span class="op">;</span>

<span class="va">a</span>.<span class="at">toFixed</span>( <span class="dv">0</span> )<span class="op">;</span> <span class="co">// &quot;43&quot;</span>
<span class="va">a</span>.<span class="at">toFixed</span>( <span class="dv">1</span> )<span class="op">;</span> <span class="co">// &quot;42.6&quot;</span>
<span class="va">a</span>.<span class="at">toFixed</span>( <span class="dv">2</span> )<span class="op">;</span> <span class="co">// &quot;42.59&quot;</span>
<span class="va">a</span>.<span class="at">toFixed</span>( <span class="dv">3</span> )<span class="op">;</span> <span class="co">// &quot;42.590&quot;</span>
<span class="va">a</span>.<span class="at">toFixed</span>( <span class="dv">4</span> )<span class="op">;</span> <span class="co">// &quot;42.5900&quot;</span></code></pre></div>
<p>Notice that the output is actually a <code>string</code> representation of the <code>number</code>, and that the value is <code>0</code>-padded on the right-hand side if you ask for more decimals than the value holds.</p>
<p><code>toPrecision(..)</code> is similar, but specifies how many <em>significant digits</em> should be used to represent the value:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="fl">42.59</span><span class="op">;</span>

<span class="va">a</span>.<span class="at">toPrecision</span>( <span class="dv">1</span> )<span class="op">;</span> <span class="co">// &quot;4e+1&quot;</span>
<span class="va">a</span>.<span class="at">toPrecision</span>( <span class="dv">2</span> )<span class="op">;</span> <span class="co">// &quot;43&quot;</span>
<span class="va">a</span>.<span class="at">toPrecision</span>( <span class="dv">3</span> )<span class="op">;</span> <span class="co">// &quot;42.6&quot;</span>
<span class="va">a</span>.<span class="at">toPrecision</span>( <span class="dv">4</span> )<span class="op">;</span> <span class="co">// &quot;42.59&quot;</span>
<span class="va">a</span>.<span class="at">toPrecision</span>( <span class="dv">5</span> )<span class="op">;</span> <span class="co">// &quot;42.590&quot;</span>
<span class="va">a</span>.<span class="at">toPrecision</span>( <span class="dv">6</span> )<span class="op">;</span> <span class="co">// &quot;42.5900&quot;</span></code></pre></div>
<p>You don't have to use a variable with the value in it to access these methods; you can access these methods directly on <code>number</code> literals. But you have to be careful with the <code>.</code> operator. Since <code>.</code> is a valid numeric character, it will first be interpreted as part of the <code>number</code> literal, if possible, instead of being interpreted as a property accessor.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// invalid syntax:</span>
<span class="fl">42.</span><span class="at">toFixed</span>( <span class="dv">3</span> )<span class="op">;</span>    <span class="co">// SyntaxError</span>

<span class="co">// these are all valid:</span>
(<span class="dv">42</span>).<span class="at">toFixed</span>( <span class="dv">3</span> )<span class="op">;</span>  <span class="co">// &quot;42.000&quot;</span>
<span class="fl">0.42</span>.<span class="at">toFixed</span>( <span class="dv">3</span> )<span class="op">;</span>  <span class="co">// &quot;0.420&quot;</span>
<span class="dv">42</span>..<span class="at">toFixed</span>( <span class="dv">3</span> )<span class="op">;</span>   <span class="co">// &quot;42.000&quot;</span></code></pre></div>
<p><code>42.toFixed(3)</code> is invalid syntax, because the <code>.</code> is swallowed up as part of the <code>42.</code> literal (which is valid -- see above!), and so then there's no <code>.</code> property operator present to make the <code>.toFixed</code> access.</p>
<p><code>42..toFixed(3)</code> works because the first <code>.</code> is part of the <code>number</code> and the second <code>.</code> is the property operator. But it probably looks strange, and indeed it's very rare to see something like that in actual JavaScript code. In fact, it's pretty uncommon to access methods directly on any of the primitive values. Uncommon doesn't mean <em>bad</em> or <em>wrong</em>.</p>
<p><strong>Note:</strong> There are libraries that extend the built-in <code>Number.prototype</code> (see Chapter 3) to provide extra operations on/with <code>number</code>s, and so in those cases, it's perfectly valid to use something like <code>10..makeItRain()</code> to set off a 10-second money raining animation, or something else silly like that.</p>
<p>This is also technically valid (notice the space):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="dv">42</span> .<span class="at">toFixed</span>(<span class="dv">3</span>)<span class="op">;</span> <span class="co">// &quot;42.000&quot;</span></code></pre></div>
<p>However, with the <code>number</code> literal specifically, <strong>this is particularly confusing coding style</strong> and will serve no other purpose but to confuse other developers (and your future self). Avoid it.</p>
<p><code>number</code>s can also be specified in exponent form, which is common when representing larger <code>number</code>s, such as:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> onethousand <span class="op">=</span> <span class="fl">1E3</span><span class="op">;</span>                      <span class="co">// means 1 * 10^3</span>
<span class="kw">var</span> onemilliononehundredthousand <span class="op">=</span> <span class="fl">1.1E6</span><span class="op">;</span>   <span class="co">// means 1.1 * 10^6</span></code></pre></div>
<p><code>number</code> literals can also be expressed in other bases, like binary, octal, and hexadecimal.</p>
<p>These formats work in current versions of JavaScript:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="bn">0xf3</span><span class="op">;</span> <span class="co">// hexadecimal for: 243</span>
<span class="bn">0Xf3</span><span class="op">;</span> <span class="co">// ditto</span>

<span class="dv">0363</span><span class="op">;</span> <span class="co">// octal for: 243</span></code></pre></div>
<p><strong>Note:</strong> Starting with ES6 + <code>strict</code> mode, the <code>0363</code> form of octal literals is no longer allowed (see below for the new form). The <code>0363</code> form is still allowed in non-<code>strict</code> mode, but you should stop using it anyway, to be future-friendly (and because you should be using <code>strict</code> mode by now!).</p>
<p>As of ES6, the following new forms are also valid:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="bn">0o363</span><span class="op">;</span>      <span class="co">// octal for: 243</span>
<span class="bn">0O363</span><span class="op">;</span>      <span class="co">// ditto</span>

0b11110011<span class="op">;</span> <span class="co">// binary for: 243</span>
0B11110011<span class="op">;</span> <span class="co">// ditto</span></code></pre></div>
<p>Please do your fellow developers a favor: never use the <code>0O363</code> form. <code>0</code> next to capital <code>O</code> is just asking for confusion. Always use the lowercase predicates <code>0x</code>, <code>0b</code>, and <code>0o</code>.</p>
<h3 id="small-decimal-values">Small Decimal Values</h3>
<p>The most (in)famous side effect of using binary floating-point numbers (which, remember, is true of <strong>all</strong> languages that use IEEE 754 -- not <em>just</em> JavaScript as many assume/pretend) is:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="fl">0.1</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">===</span> <span class="fl">0.3</span><span class="op">;</span> <span class="co">// false</span></code></pre></div>
<p>Mathematically, we know that statement should be <code>true</code>. Why is it <code>false</code>?</p>
<p>Simply put, the representations for <code>0.1</code> and <code>0.2</code> in binary floating-point are not exact, so when they are added, the result is not exactly <code>0.3</code>. It's <strong>really</strong> close: <code>0.30000000000000004</code>, but if your comparison fails, &quot;close&quot; is irrelevant.</p>
<p><strong>Note:</strong> Should JavaScript switch to a different <code>number</code> implementation that has exact representations for all values? Some think so. There have been many alternatives presented over the years. None of them have been accepted yet, and perhaps never will. As easy as it may seem to just wave a hand and say, &quot;fix that bug already!&quot;, it's not nearly that easy. If it were, it most definitely would have been changed a long time ago.</p>
<p>Now, the question is, if some <code>number</code>s can't be <em>trusted</em> to be exact, does that mean we can't use <code>number</code>s at all? <strong>Of course not.</strong></p>
<p>There are some applications where you need to be more careful, especially when dealing with fractional decimal values. There are also plenty of (maybe most?) applications that only deal with whole numbers (&quot;integers&quot;), and moreover, only deal with numbers in the millions or trillions at maximum. These applications have been, and always will be, <strong>perfectly safe</strong> to use numeric operations in JS.</p>
<p>What if we <em>did</em> need to compare two <code>number</code>s, like <code>0.1 + 0.2</code> to <code>0.3</code>, knowing that the simple equality test fails?</p>
<p>The most commonly accepted practice is to use a tiny &quot;rounding error&quot; value as the <em>tolerance</em> for comparison. This tiny value is often called &quot;machine epsilon,&quot; which is commonly <code>2^-52</code> (<code>2.220446049250313e-16</code>) for the kind of <code>number</code>s in JavaScript.</p>
<p>As of ES6, <code>Number.EPSILON</code> is predefined with this tolerance value, so you'd want to use it, but you can safely polyfill the definition for pre-ES6:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Number</span>.<span class="at">EPSILON</span>) <span class="op">{</span>
    <span class="va">Number</span>.<span class="at">EPSILON</span> <span class="op">=</span> <span class="va">Math</span>.<span class="at">pow</span>(<span class="dv">2</span><span class="op">,-</span><span class="dv">52</span>)<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>We can use this <code>Number.EPSILON</code> to compare two <code>number</code>s for &quot;equality&quot; (within the rounding error tolerance):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">numbersCloseEnoughToEqual</span>(n1<span class="op">,</span>n2) <span class="op">{</span>
    <span class="cf">return</span> <span class="va">Math</span>.<span class="at">abs</span>( n1 <span class="op">-</span> n2 ) <span class="op">&lt;</span> <span class="va">Number</span>.<span class="at">EPSILON</span><span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="fl">0.1</span> <span class="op">+</span> <span class="fl">0.2</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="fl">0.3</span><span class="op">;</span>

<span class="at">numbersCloseEnoughToEqual</span>( a<span class="op">,</span> b )<span class="op">;</span>                  <span class="co">// true</span>
<span class="at">numbersCloseEnoughToEqual</span>( <span class="fl">0.0000001</span><span class="op">,</span> <span class="fl">0.0000002</span> )<span class="op">;</span>  <span class="co">// false</span></code></pre></div>
<p>The maximum floating-point value that can be represented is roughly <code>1.798e+308</code> (which is really, really, really huge!), predefined for you as <code>Number.MAX_VALUE</code>. On the small end, <code>Number.MIN_VALUE</code> is roughly <code>5e-324</code>, which isn't negative but is really close to zero!</p>
<h3 id="safe-integer-ranges">Safe Integer Ranges</h3>
<p>Because of how <code>number</code>s are represented, there is a range of &quot;safe&quot; values for the whole <code>number</code> &quot;integers&quot;, and it's significantly less than <code>Number.MAX_VALUE</code>.</p>
<p>The maximum integer that can &quot;safely&quot; be represented (that is, there's a guarantee that the requested value is actually representable unambiguously) is <code>2^53 - 1</code>, which is <code>9007199254740991</code>. If you insert your commas, you'll see that this is just over 9 quadrillion. So that's pretty darn big for <code>number</code>s to range up to.</p>
<p>This value is actually automatically predefined in ES6, as <code>Number.MAX_SAFE_INTEGER</code>. Unsurprisingly, there's a minimum value, <code>-9007199254740991</code>, and it's defined in ES6 as <code>Number.MIN_SAFE_INTEGER</code>.</p>
<p>The main way that JS programs are confronted with dealing with such large numbers is when dealing with 64-bit IDs from databases, etc. 64-bit numbers cannot be represented accurately with the <code>number</code> type, so must be stored in (and transmitted to/from) JavaScript using <code>string</code> representation.</p>
<p>Numeric operations on such large ID <code>number</code> values (besides comparison, which will be fine with <code>string</code>s) aren't all that common, thankfully. But if you <em>do</em> need to perform math on these very large values, for now you'll need to use a <em>big number</em> utility. Big numbers may get official support in a future version of JavaScript.</p>
<h3 id="testing-for-integers">Testing for Integers</h3>
<p>To test if a value is an integer, you can use the ES6-specified <code>Number.isInteger(..)</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Number</span>.<span class="at">isInteger</span>( <span class="dv">42</span> )<span class="op">;</span>     <span class="co">// true</span>
<span class="va">Number</span>.<span class="at">isInteger</span>( <span class="fl">42.000</span> )<span class="op">;</span> <span class="co">// true</span>
<span class="va">Number</span>.<span class="at">isInteger</span>( <span class="fl">42.3</span> )<span class="op">;</span>   <span class="co">// false</span></code></pre></div>
<p>To polyfill <code>Number.isInteger(..)</code> for pre-ES6:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Number</span>.<span class="at">isInteger</span>) <span class="op">{</span>
    <span class="va">Number</span>.<span class="at">isInteger</span> <span class="op">=</span> <span class="kw">function</span>(num) <span class="op">{</span>
        <span class="cf">return</span> <span class="kw">typeof</span> num <span class="op">==</span> <span class="st">&quot;number&quot;</span> <span class="op">&amp;&amp;</span> num <span class="op">%</span> <span class="dv">1</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p>To test if a value is a <em>safe integer</em>, use the ES6-specified <code>Number.isSafeInteger(..)</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Number</span>.<span class="at">isSafeInteger</span>( <span class="va">Number</span>.<span class="at">MAX_SAFE_INTEGER</span> )<span class="op">;</span>    <span class="co">// true</span>
<span class="va">Number</span>.<span class="at">isSafeInteger</span>( <span class="va">Math</span>.<span class="at">pow</span>( <span class="dv">2</span><span class="op">,</span> <span class="dv">53</span> ) )<span class="op">;</span>          <span class="co">// false</span>
<span class="va">Number</span>.<span class="at">isSafeInteger</span>( <span class="va">Math</span>.<span class="at">pow</span>( <span class="dv">2</span><span class="op">,</span> <span class="dv">53</span> ) <span class="op">-</span> <span class="dv">1</span> )<span class="op">;</span>      <span class="co">// true</span></code></pre></div>
<p>To polyfill <code>Number.isSafeInteger(..)</code> in pre-ES6 browsers:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Number</span>.<span class="at">isSafeInteger</span>) <span class="op">{</span>
    <span class="va">Number</span>.<span class="at">isSafeInteger</span> <span class="op">=</span> <span class="kw">function</span>(num) <span class="op">{</span>
        <span class="cf">return</span> <span class="va">Number</span>.<span class="at">isInteger</span>( num ) <span class="op">&amp;&amp;</span>
            <span class="va">Math</span>.<span class="at">abs</span>( num ) <span class="op">&lt;=</span> <span class="va">Number</span>.<span class="at">MAX_SAFE_INTEGER</span><span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<h3 id="bit-signed-integers">32-bit (Signed) Integers</h3>
<p>While integers can range up to roughly 9 quadrillion safely (53 bits), there are some numeric operations (like the bitwise operators) that are only defined for 32-bit <code>number</code>s, so the &quot;safe range&quot; for <code>number</code>s used in that way must be much smaller.</p>
<p>The range then is <code>Math.pow(-2,31)</code> (<code>-2147483648</code>, about -2.1 billion) up to <code>Math.pow(2,31)-1</code> (<code>2147483647</code>, about +2.1 billion).</p>
<p>To force a <code>number</code> value in <code>a</code> to a 32-bit signed integer value, use <code>a | 0</code>. This works because the <code>|</code> bitwise operator only works for 32-bit integer values (meaning it can only pay attention to 32 bits and any other bits will be lost). Then, &quot;or'ing&quot; with zero is essentially a no-op bitwise speaking.</p>
<p><strong>Note:</strong> Certain special values (which we will cover in the next section) such as <code>NaN</code> and <code>Infinity</code> are not &quot;32-bit safe,&quot; in that those values when passed to a bitwise operator will pass through the abstract operation <code>ToInt32</code> (see Chapter 4) and become simply the <code>+0</code> value for the purpose of that bitwise operation.</p>
<h2 id="special-values">Special Values</h2>
<p>There are several special values spread across the various types that the <em>alert</em> JS developer needs to be aware of, and use properly.</p>
<h3 id="the-non-value-values">The Non-value Values</h3>
<p>For the <code>undefined</code> type, there is one and only one value: <code>undefined</code>. For the <code>null</code> type, there is one and only one value: <code>null</code>. So for both of them, the label is both its type and its value.</p>
<p>Both <code>undefined</code> and <code>null</code> are often taken to be interchangeable as either &quot;empty&quot; values or &quot;non&quot; values. Other developers prefer to distinguish between them with nuance. For example:</p>
<ul>
<li><code>null</code> is an empty value</li>
<li><code>undefined</code> is a missing value</li>
</ul>
<p>Or:</p>
<ul>
<li><code>undefined</code> hasn't had a value yet</li>
<li><code>null</code> had a value and doesn't anymore</li>
</ul>
<p>Regardless of how you choose to &quot;define&quot; and use these two values, <code>null</code> is a special keyword, not an identifier, and thus you cannot treat it as a variable to assign to (why would you!?). However, <code>undefined</code> <em>is</em> (unfortunately) an identifier. Uh oh.</p>
<h3 id="undefined">Undefined</h3>
<p>In non-<code>strict</code> mode, it's actually possible (though incredibly ill-advised!) to assign a value to the globally provided <code>undefined</code> identifier:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="kw">undefined</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// really bad idea!</span>
<span class="op">}</span>

<span class="at">foo</span>()<span class="op">;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="st">&quot;use strict&quot;</span><span class="op">;</span>
    <span class="kw">undefined</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// TypeError!</span>
<span class="op">}</span>

<span class="at">foo</span>()<span class="op">;</span></code></pre></div>
<p>In both non-<code>strict</code> mode and <code>strict</code> mode, however, you can create a local variable of the name <code>undefined</code>. But again, this is a terrible idea!</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="st">&quot;use strict&quot;</span><span class="op">;</span>
    <span class="kw">var</span> <span class="kw">undefined</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">undefined</span> )<span class="op">;</span> <span class="co">// 2</span>
<span class="op">}</span>

<span class="at">foo</span>()<span class="op">;</span></code></pre></div>
<p><strong>Friends don't let friends override <code>undefined</code>.</strong> Ever.</p>
<h4 id="void-operator"><code>void</code> Operator</h4>
<p>While <code>undefined</code> is a built-in identifier that holds (unless modified -- see above!) the built-in <code>undefined</code> value, another way to get this value is the <code>void</code> operator.</p>
<p>The expression <code>void ___</code> &quot;voids&quot; out any value, so that the result of the expression is always the <code>undefined</code> value. It doesn't modify the existing value; it just ensures that no value comes back from the operator expression.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>

<span class="va">console</span>.<span class="at">log</span>( <span class="kw">void</span> a<span class="op">,</span> a )<span class="op">;</span> <span class="co">// undefined 42</span></code></pre></div>
<p>By convention (mostly from C-language programming), to represent the <code>undefined</code> value stand-alone by using <code>void</code>, you'd use <code>void 0</code> (though clearly even <code>void true</code> or any other <code>void</code> expression does the same thing). There's no practical difference between <code>void 0</code>, <code>void 1</code>, and <code>undefined</code>.</p>
<p>But the <code>void</code> operator can be useful in a few other circumstances, if you need to ensure that an expression has no result value (even if it has side effects).</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span>
    <span class="co">// note: `APP.ready` is provided by our application</span>
    <span class="cf">if</span> (<span class="op">!</span><span class="va">APP</span>.<span class="at">ready</span>) <span class="op">{</span>
        <span class="co">// try again later</span>
        <span class="cf">return</span> <span class="kw">void</span> <span class="at">setTimeout</span>( doSomething<span class="op">,</span> <span class="dv">100</span> )<span class="op">;</span>
    <span class="op">}</span>

    <span class="kw">var</span> result<span class="op">;</span>

    <span class="co">// do some other stuff</span>
    <span class="cf">return</span> result<span class="op">;</span>
<span class="op">}</span>

<span class="co">// were we able to do it right away?</span>
<span class="cf">if</span> (<span class="at">doSomething</span>()) <span class="op">{</span>
    <span class="co">// handle next tasks right away</span>
<span class="op">}</span></code></pre></div>
<p>Here, the <code>setTimeout(..)</code> function returns a numeric value (the unique identifier of the timer interval, if you wanted to cancel it), but we want to <code>void</code> that out so that the return value of our function doesn't give a false-positive with the <code>if</code> statement.</p>
<p>Many devs prefer to just do these actions separately, which works the same but doesn't use the <code>void</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">APP</span>.<span class="at">ready</span>) <span class="op">{</span>
    <span class="co">// try again later</span>
    <span class="at">setTimeout</span>( doSomething<span class="op">,</span> <span class="dv">100</span> )<span class="op">;</span>
    <span class="cf">return</span><span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>In general, if there's ever a place where a value exists (from some expression) and you'd find it useful for the value to be <code>undefined</code> instead, use the <code>void</code> operator. That probably won't be terribly common in your programs, but in the rare cases you do need it, it can be quite helpful.</p>
<h3 id="special-numbers">Special Numbers</h3>
<p>The <code>number</code> type includes several special values. We'll take a look at each in detail.</p>
<h4 id="the-not-number-number">The Not Number, Number</h4>
<p>Any mathematic operation you perform without both operands being <code>number</code>s (or values that can be interpreted as regular <code>number</code>s in base 10 or base 16) will result in the operation failing to produce a valid <code>number</code>, in which case you will get the <code>NaN</code> value.</p>
<p><code>NaN</code> literally stands for &quot;not a <code>number</code>&quot;, though this label/description is very poor and misleading, as we'll see shortly. It would be much more accurate to think of <code>NaN</code> as being &quot;invalid number,&quot; &quot;failed number,&quot; or even &quot;bad number,&quot; than to think of it as &quot;not a number.&quot;</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span> / <span class="st">&quot;foo&quot;</span><span class="op">;</span>      <span class="co">// NaN</span>

<span class="kw">typeof</span> a <span class="op">===</span> <span class="st">&quot;number&quot;</span><span class="op">;</span>  <span class="co">// true</span></code></pre></div>
<p>In other words: &quot;the type of not-a-number is 'number'!&quot; Hooray for confusing names and semantics.</p>
<p><code>NaN</code> is a kind of &quot;sentinel value&quot; (an otherwise normal value that's assigned a special meaning) that represents a special kind of error condition within the <code>number</code> set. The error condition is, in essence: &quot;I tried to perform a mathematic operation but failed, so here's the failed <code>number</code> result instead.&quot;</p>
<p>So, if you have a value in some variable and want to test to see if it's this special failed-number <code>NaN</code>, you might think you could directly compare to <code>NaN</code> itself, as you can with any other value, like <code>null</code> or <code>undefined</code>. Nope.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span> / <span class="st">&quot;foo&quot;</span><span class="op">;</span>

a <span class="op">==</span> <span class="kw">NaN</span><span class="op">;</span>   <span class="co">// false</span>
a <span class="op">===</span> <span class="kw">NaN</span><span class="op">;</span>  <span class="co">// false</span></code></pre></div>
<p><code>NaN</code> is a very special value in that it's never equal to another <code>NaN</code> value (i.e., it's never equal to itself). It's the only value, in fact, that is not reflexive (without the Identity characteristic <code>x === x</code>). So, <code>NaN !== NaN</code>. A bit strange, huh?</p>
<p>So how <em>do</em> we test for it, if we can't compare to <code>NaN</code> (since that comparison would always fail)?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span> / <span class="st">&quot;foo&quot;</span><span class="op">;</span>

<span class="at">isNaN</span>( a )<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>Easy enough, right? We use the built-in global utility called <code>isNaN(..)</code> and it tells us if the value is <code>NaN</code> or not. Problem solved!</p>
<p>Not so fast.</p>
<p>The <code>isNaN(..)</code> utility has a fatal flaw. It appears it tried to take the meaning of <code>NaN</code> (&quot;Not a Number&quot;) too literally -- that its job is basically: &quot;test if the thing passed in is either not a <code>number</code> or is a <code>number</code>.&quot; But that's not quite accurate.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span> / <span class="st">&quot;foo&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>

a<span class="op">;</span> <span class="co">// NaN</span>
b<span class="op">;</span> <span class="co">// &quot;foo&quot;</span>

<span class="va">window</span>.<span class="at">isNaN</span>( a )<span class="op">;</span> <span class="co">// true</span>
<span class="va">window</span>.<span class="at">isNaN</span>( b )<span class="op">;</span> <span class="co">// true -- ouch!</span></code></pre></div>
<p>Clearly, <code>&quot;foo&quot;</code> is literally <em>not a <code>number</code></em>, but it's definitely not the <code>NaN</code> value either! This bug has been in JS since the very beginning (over 19 years of <em>ouch</em>).</p>
<p>As of ES6, finally a replacement utility has been provided: <code>Number.isNaN(..)</code>. A simple polyfill for it so that you can safely check <code>NaN</code> values <em>now</em> even in pre-ES6 browsers is:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Number</span>.<span class="at">isNaN</span>) <span class="op">{</span>
    <span class="va">Number</span>.<span class="at">isNaN</span> <span class="op">=</span> <span class="kw">function</span>(n) <span class="op">{</span>
        <span class="cf">return</span> (
            <span class="kw">typeof</span> n <span class="op">===</span> <span class="st">&quot;number&quot;</span> <span class="op">&amp;&amp;</span>
            <span class="va">window</span>.<span class="at">isNaN</span>( n )
        )<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span> / <span class="st">&quot;foo&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>

<span class="va">Number</span>.<span class="at">isNaN</span>( a )<span class="op">;</span> <span class="co">// true</span>
<span class="va">Number</span>.<span class="at">isNaN</span>( b )<span class="op">;</span> <span class="co">// false -- phew!</span></code></pre></div>
<p>Actually, we can implement a <code>Number.isNaN(..)</code> polyfill even easier, by taking advantage of that peculiar fact that <code>NaN</code> isn't equal to itself. <code>NaN</code> is the <em>only</em> value in the whole language where that's true; every other value is always <strong>equal to itself</strong>.</p>
<p>So:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Number</span>.<span class="at">isNaN</span>) <span class="op">{</span>
    <span class="va">Number</span>.<span class="at">isNaN</span> <span class="op">=</span> <span class="kw">function</span>(n) <span class="op">{</span>
        <span class="cf">return</span> n <span class="op">!==</span> n<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p>Weird, huh? But it works!</p>
<p><code>NaN</code>s are probably a reality in a lot of real-world JS programs, either on purpose or by accident. It's a really good idea to use a reliable test, like <code>Number.isNaN(..)</code> as provided (or polyfilled), to recognize them properly.</p>
<p>If you're currently using just <code>isNaN(..)</code> in a program, the sad reality is your program <em>has a bug</em>, even if you haven't been bitten by it yet!</p>
<h4 id="infinities">Infinities</h4>
<p>Developers from traditional compiled languages like C are probably used to seeing either a compiler error or runtime exception, like &quot;Divide by zero,&quot; for an operation like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">1</span> / <span class="dv">0</span><span class="op">;</span></code></pre></div>
<p>However, in JS, this operation is well-defined and results in the value <code>Infinity</code> (aka <code>Number.POSITIVE_INFINITY</code>). Unsurprisingly:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">1</span> / <span class="dv">0</span><span class="op">;</span>  <span class="co">// Infinity</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> / <span class="dv">0</span><span class="op">;</span> <span class="co">// -Infinity</span></code></pre></div>
<p>As you can see, <code>-Infinity</code> (aka <code>Number.NEGATIVE_INFINITY</code>) results from a divide-by-zero where either (but not both!) of the divide operands is negative.</p>
<p>JS uses finite numeric representations (IEEE 754 floating-point, which we covered earlier), so contrary to pure mathematics, it seems it <em>is</em> possible to overflow even with an operation like addition or subtraction, in which case you'd get <code>Infinity</code> or <code>-Infinity</code>.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="va">Number</span>.<span class="at">MAX_VALUE</span><span class="op">;</span>   <span class="co">// 1.7976931348623157e+308</span>
a <span class="op">+</span> a<span class="op">;</span>                      <span class="co">// Infinity</span>
a <span class="op">+</span> <span class="va">Math</span>.<span class="at">pow</span>( <span class="dv">2</span><span class="op">,</span> <span class="dv">970</span> )<span class="op">;</span>     <span class="co">// Infinity</span>
a <span class="op">+</span> <span class="va">Math</span>.<span class="at">pow</span>( <span class="dv">2</span><span class="op">,</span> <span class="dv">969</span> )<span class="op">;</span>     <span class="co">// 1.7976931348623157e+308</span></code></pre></div>
<p>According to the specification, if an operation like addition results in a value that's too big to represent, the IEEE 754 &quot;round-to-nearest&quot; mode specifies what the result should be. So, in a crude sense, <code>Number.MAX_VALUE + Math.pow( 2, 969 )</code> is closer to <code>Number.MAX_VALUE</code> than to <code>Infinity</code>, so it &quot;rounds down,&quot; whereas <code>Number.MAX_VALUE + Math.pow( 2, 970 )</code> is closer to <code>Infinity</code> so it &quot;rounds up&quot;.</p>
<p>If you think too much about that, it's going to make your head hurt. So don't. Seriously, stop!</p>
<p>Once you overflow to either one of the <em>infinities</em>, however, there's no going back. In other words, in an almost poetic sense, you can go from finite to infinite but not from infinite back to finite.</p>
<p>It's almost philosophical to ask: &quot;What is infinity divided by infinity&quot;. Our naive brains would likely say &quot;1&quot; or maybe &quot;infinity.&quot; Turns out neither is true. Both mathematically and in JavaScript, <code>Infinity / Infinity</code> is not a defined operation. In JS, this results in <code>NaN</code>.</p>
<p>But what about any positive finite <code>number</code> divided by <code>Infinity</code>? That's easy! <code>0</code>. And what about a negative finite <code>number</code> divided by <code>Infinity</code>? Keep reading!</p>
<h4 id="zeros">Zeros</h4>
<p>While it may confuse the mathematics-minded reader, JavaScript has both a normal zero <code>0</code> (otherwise known as a positive zero <code>+0</code>) <em>and</em> a negative zero <code>-0</code>. Before we explain why the <code>-0</code> exists, we should examine how JS handles it, because it can be quite confusing.</p>
<p>Besides being specified literally as <code>-0</code>, negative zero also results from certain mathematic operations. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">0</span> / <span class="op">-</span><span class="dv">3</span><span class="op">;</span> <span class="co">// -0</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="dv">0</span> <span class="op">*</span> <span class="op">-</span><span class="dv">3</span><span class="op">;</span> <span class="co">// -0</span></code></pre></div>
<p>Addition and subtraction cannot result in a negative zero.</p>
<p>A negative zero when examined in the developer console will usually reveal <code>-0</code>, though that was not the common case until fairly recently, so some older browsers you encounter may still report it as <code>0</code>.</p>
<p>However, if you try to stringify a negative zero value, it will always be reported as <code>&quot;0&quot;</code>, according to the spec.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">0</span> / <span class="op">-</span><span class="dv">3</span><span class="op">;</span>

<span class="co">// (some browser) consoles at least get it right</span>
a<span class="op">;</span>                          <span class="co">// -0</span>

<span class="co">// but the spec insists on lying to you!</span>
<span class="va">a</span>.<span class="at">toString</span>()<span class="op">;</span>               <span class="co">// &quot;0&quot;</span>
a <span class="op">+</span> <span class="st">&quot;&quot;</span><span class="op">;</span>                     <span class="co">// &quot;0&quot;</span>
<span class="at">String</span>( a )<span class="op">;</span>                <span class="co">// &quot;0&quot;</span>

<span class="co">// strangely, even JSON gets in on the deception</span>
<span class="va">JSON</span>.<span class="at">stringify</span>( a )<span class="op">;</span>        <span class="co">// &quot;0&quot;</span></code></pre></div>
<p>Interestingly, the reverse operations (going from <code>string</code> to <code>number</code>) don't lie:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">+</span><span class="st">&quot;-0&quot;</span><span class="op">;</span>              <span class="co">// -0</span>
<span class="at">Number</span>( <span class="st">&quot;-0&quot;</span> )<span class="op">;</span>     <span class="co">// -0</span>
<span class="va">JSON</span>.<span class="at">parse</span>( <span class="st">&quot;-0&quot;</span> )<span class="op">;</span> <span class="co">// -0</span></code></pre></div>
<p><strong>Warning:</strong> The <code>JSON.stringify( -0 )</code> behavior of <code>&quot;0&quot;</code> is particularly strange when you observe that it's inconsistent with the reverse: <code>JSON.parse( &quot;-0&quot; )</code> reports <code>-0</code> as you'd correctly expect.</p>
<p>In addition to stringification of negative zero being deceptive to hide its true value, the comparison operators are also (intentionally) configured to <em>lie</em>.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="dv">0</span> / <span class="op">-</span><span class="dv">3</span><span class="op">;</span>

a <span class="op">==</span> b<span class="op">;</span>     <span class="co">// true</span>
<span class="op">-</span><span class="dv">0</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>    <span class="co">// true</span>

a <span class="op">===</span> b<span class="op">;</span>    <span class="co">// true</span>
<span class="op">-</span><span class="dv">0</span> <span class="op">===</span> <span class="dv">0</span><span class="op">;</span>   <span class="co">// true</span>

<span class="dv">0</span> <span class="op">&gt;</span> <span class="op">-</span><span class="dv">0</span><span class="op">;</span>     <span class="co">// false</span>
a <span class="op">&gt;</span> b<span class="op">;</span>      <span class="co">// false</span></code></pre></div>
<p>Clearly, if you want to distinguish a <code>-0</code> from a <code>0</code> in your code, you can't just rely on what the developer console outputs, so you're going to have to be a bit more clever:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">isNegZero</span>(n) <span class="op">{</span>
    n <span class="op">=</span> <span class="at">Number</span>( n )<span class="op">;</span>
    <span class="cf">return</span> (n <span class="op">===</span> <span class="dv">0</span>) <span class="op">&amp;&amp;</span> (<span class="dv">1</span> / n <span class="op">===</span> <span class="op">-</span><span class="kw">Infinity</span>)<span class="op">;</span>
<span class="op">}</span>

<span class="at">isNegZero</span>( <span class="op">-</span><span class="dv">0</span> )<span class="op">;</span>        <span class="co">// true</span>
<span class="at">isNegZero</span>( <span class="dv">0</span> / <span class="op">-</span><span class="dv">3</span> )<span class="op">;</span>    <span class="co">// true</span>
<span class="at">isNegZero</span>( <span class="dv">0</span> )<span class="op">;</span>         <span class="co">// false</span></code></pre></div>
<p>Now, why do we need a negative zero, besides academic trivia?</p>
<p>There are certain applications where developers use the magnitude of a value to represent one piece of information (like speed of movement per animation frame) and the sign of that <code>number</code> to represent another piece of information (like the direction of that movement).</p>
<p>In those applications, as one example, if a variable arrives at zero and it loses its sign, then you would lose the information of what direction it was moving in before it arrived at zero. Preserving the sign of the zero prevents potentially unwanted information loss.</p>
<h3 id="special-equality">Special Equality</h3>
<p>As we saw above, the <code>NaN</code> value and the <code>-0</code> value have special behavior when it comes to equality comparison. <code>NaN</code> is never equal to itself, so you have to use ES6's <code>Number.isNaN(..)</code> (or a polyfill). Similarly, <code>-0</code> lies and pretends that it's equal (even <code>===</code> strict equal -- see Chapter 4) to regular positive <code>0</code>, so you have to use the somewhat hackish <code>isNegZero(..)</code> utility we suggested above.</p>
<p>As of ES6, there's a new utility that can be used to test two values for absolute equality, without any of these exceptions. It's called <code>Object.is(..)</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span> / <span class="st">&quot;foo&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="op">-</span><span class="dv">3</span> <span class="op">*</span> <span class="dv">0</span><span class="op">;</span>

<span class="va">Object</span>.<span class="at">is</span>( a<span class="op">,</span> <span class="kw">NaN</span> )<span class="op">;</span>    <span class="co">// true</span>
<span class="va">Object</span>.<span class="at">is</span>( b<span class="op">,</span> <span class="op">-</span><span class="dv">0</span> )<span class="op">;</span>     <span class="co">// true</span>

<span class="va">Object</span>.<span class="at">is</span>( b<span class="op">,</span> <span class="dv">0</span> )<span class="op">;</span>      <span class="co">// false</span></code></pre></div>
<p>There's a pretty simple polyfill for <code>Object.is(..)</code> for pre-ES6 environments:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Object</span>.<span class="at">is</span>) <span class="op">{</span>
    <span class="va">Object</span>.<span class="at">is</span> <span class="op">=</span> <span class="kw">function</span>(v1<span class="op">,</span> v2) <span class="op">{</span>
        <span class="co">// test for `-0`</span>
        <span class="cf">if</span> (v1 <span class="op">===</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> v2 <span class="op">===</span> <span class="dv">0</span>) <span class="op">{</span>
            <span class="cf">return</span> <span class="dv">1</span> / v1 <span class="op">===</span> <span class="dv">1</span> / v2<span class="op">;</span>
        <span class="op">}</span>
        <span class="co">// test for `NaN`</span>
        <span class="cf">if</span> (v1 <span class="op">!==</span> v1) <span class="op">{</span>
            <span class="cf">return</span> v2 <span class="op">!==</span> v2<span class="op">;</span>
        <span class="op">}</span>
        <span class="co">// everything else</span>
        <span class="cf">return</span> v1 <span class="op">===</span> v2<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p><code>Object.is(..)</code> probably shouldn't be used in cases where <code>==</code> or <code>===</code> are known to be <em>safe</em> (see Chapter 4 &quot;Coercion&quot;), as the operators are likely much more efficient and certainly are more idiomatic/common. <code>Object.is(..)</code> is mostly for these special cases of equality.</p>
<h2 id="value-vs.-reference">Value vs. Reference</h2>
<p>In many other languages, values can either be assigned/passed by value-copy or by reference-copy depending on the syntax you use.</p>
<p>For example, in C++ if you want to pass a <code>number</code> variable into a function and have that variable's value updated, you can declare the function parameter like <code>int&amp; myNum</code>, and when you pass in a variable like <code>x</code>, <code>myNum</code> will be a <strong>reference to <code>x</code></strong>; references are like a special form of pointers, where you obtain a pointer to another variable (like an <em>alias</em>). If you don't declare a reference parameter, the value passed in will <em>always</em> be copied, even if it's a complex object.</p>
<p>In JavaScript, there are no pointers, and references work a bit differently. You cannot have a reference from one JS variable to another variable. That's just not possible.</p>
<p>A reference in JS points at a (shared) <strong>value</strong>, so if you have 10 different references, they are all always distinct references to a single shared value; <strong>none of them are references/pointers to each other.</strong></p>
<p>Moreover, in JavaScript, there are no syntactic hints that control value vs. reference assignment/passing. Instead, the <em>type</em> of the value <em>solely</em> controls whether that value will be assigned by value-copy or by reference-copy.</p>
<p>Let's illustrate:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> a<span class="op">;</span> <span class="co">// `b` is always a copy of the value in `a`</span>
b<span class="op">++;</span>
a<span class="op">;</span> <span class="co">// 2</span>
b<span class="op">;</span> <span class="co">// 3</span>

<span class="kw">var</span> c <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span>
<span class="kw">var</span> d <span class="op">=</span> c<span class="op">;</span> <span class="co">// `d` is a reference to the shared `[1,2,3]` value</span>
<span class="va">d</span>.<span class="at">push</span>( <span class="dv">4</span> )<span class="op">;</span>
c<span class="op">;</span> <span class="co">// [1,2,3,4]</span>
d<span class="op">;</span> <span class="co">// [1,2,3,4]</span></code></pre></div>
<p>Simple values (aka scalar primitives) are <em>always</em> assigned/passed by value-copy: <code>null</code>, <code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code>, and ES6's <code>symbol</code>.</p>
<p>Compound values -- <code>object</code>s (including <code>array</code>s, and all boxed object wrappers -- see Chapter 3) and <code>function</code>s -- <em>always</em> create a copy of the reference on assignment or passing.</p>
<p>In the above snippet, because <code>2</code> is a scalar primitive, <code>a</code> holds one initial copy of that value, and <code>b</code> is assigned another <em>copy</em> of the value. When changing <code>b</code>, you are in no way changing the value in <code>a</code>.</p>
<p>But <strong>both <code>c</code> and <code>d</code></strong> are separate references to the same shared value <code>[1,2,3]</code>, which is a compound value. It's important to note that neither <code>c</code> nor <code>d</code> more &quot;owns&quot; the <code>[1,2,3]</code> value -- both are just equal peer references to the value. So, when using either reference to modify (<code>.push(4)</code>) the actual shared <code>array</code> value itself, it's affecting just the one shared value, and both references will reference the newly modified value <code>[1,2,3,4]</code>.</p>
<p>Since references point to the values themselves and not to the variables, you cannot use one reference to change where another reference is pointed:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> a<span class="op">;</span>
a<span class="op">;</span> <span class="co">// [1,2,3]</span>
b<span class="op">;</span> <span class="co">// [1,2,3]</span>

<span class="co">// later</span>
b <span class="op">=</span> [<span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span>]<span class="op">;</span>
a<span class="op">;</span> <span class="co">// [1,2,3]</span>
b<span class="op">;</span> <span class="co">// [4,5,6]</span></code></pre></div>
<p>When we make the assignment <code>b = [4,5,6]</code>, we are doing absolutely nothing to affect <em>where</em> <code>a</code> is still referencing (<code>[1,2,3]</code>). To do that, <code>b</code> would have to be a pointer to <code>a</code> rather than a reference to the <code>array</code> -- but no such capability exists in JS!</p>
<p>The most common way such confusion happens is with function parameters:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(x) <span class="op">{</span>
    <span class="va">x</span>.<span class="at">push</span>( <span class="dv">4</span> )<span class="op">;</span>
    x<span class="op">;</span> <span class="co">// [1,2,3,4]</span>

    <span class="co">// later</span>
    x <span class="op">=</span> [<span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span>]<span class="op">;</span>
    <span class="va">x</span>.<span class="at">push</span>( <span class="dv">7</span> )<span class="op">;</span>
    x<span class="op">;</span> <span class="co">// [4,5,6,7]</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span>

<span class="at">foo</span>( a )<span class="op">;</span>

a<span class="op">;</span> <span class="co">// [1,2,3,4]  not  [4,5,6,7]</span></code></pre></div>
<p>When we pass in the argument <code>a</code>, it assigns a copy of the <code>a</code> reference to <code>x</code>. <code>x</code> and <code>a</code> are separate references pointing at the same <code>[1,2,3]</code> value. Now, inside the function, we can use that reference to mutate the value itself (<code>push(4)</code>). But when we make the assignment <code>x = [4,5,6]</code>, this is in no way affecting where the initial reference <code>a</code> is pointing -- still points at the (now modified) <code>[1,2,3,4]</code> value.</p>
<p>There is no way to use the <code>x</code> reference to change where <code>a</code> is pointing. We could only modify the contents of the shared value that both <code>a</code> and <code>x</code> are pointing to.</p>
<p>To accomplish changing <code>a</code> to have the <code>[4,5,6,7]</code> value contents, you can't create a new <code>array</code> and assign -- you must modify the existing <code>array</code> value:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(x) <span class="op">{</span>
    <span class="va">x</span>.<span class="at">push</span>( <span class="dv">4</span> )<span class="op">;</span>
    x<span class="op">;</span> <span class="co">// [1,2,3,4]</span>

    <span class="co">// later</span>
    <span class="va">x</span>.<span class="at">length</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// empty existing array in-place</span>
    <span class="va">x</span>.<span class="at">push</span>( <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span> )<span class="op">;</span>
    x<span class="op">;</span> <span class="co">// [4,5,6,7]</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span>

<span class="at">foo</span>( a )<span class="op">;</span>

a<span class="op">;</span> <span class="co">// [4,5,6,7]  not  [1,2,3,4]</span></code></pre></div>
<p>As you can see, <code>x.length = 0</code> and <code>x.push(4,5,6,7)</code> were not creating a new <code>array</code>, but modifying the existing shared <code>array</code>. So of course, <code>a</code> references the new <code>[4,5,6,7]</code> contents.</p>
<p>Remember: you cannot directly control/override value-copy vs. reference -- those semantics are controlled entirely by the type of the underlying value.</p>
<p>To effectively pass a compound value (like an <code>array</code>) by value-copy, you need to manually make a copy of it, so that the reference passed doesn't still point to the original. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="at">foo</span>( <span class="va">a</span>.<span class="at">slice</span>() )<span class="op">;</span></code></pre></div>
<p><code>slice(..)</code> with no parameters by default makes an entirely new (shallow) copy of the <code>array</code>. So, we pass in a reference only to the copied <code>array</code>, and thus <code>foo(..)</code> cannot affect the contents of <code>a</code>.</p>
<p>To do the reverse -- pass a scalar primitive value in a way where its value updates can be seen, kinda like a reference -- you have to wrap the value in another compound value (<code>object</code>, <code>array</code>, etc) that <em>can</em> be passed by reference-copy:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(wrapper) <span class="op">{</span>
    <span class="va">wrapper</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">};</span>

<span class="at">foo</span>( obj )<span class="op">;</span>

<span class="va">obj</span>.<span class="at">a</span><span class="op">;</span> <span class="co">// 42</span></code></pre></div>
<p>Here, <code>obj</code> acts as a wrapper for the scalar primitive property <code>a</code>. When passed to <code>foo(..)</code>, a copy of the <code>obj</code> reference is passed in and set to the <code>wrapper</code> parameter. We now can use the <code>wrapper</code> reference to access the shared object, and update its property. After the function finishes, <code>obj.a</code> will see the updated value <code>42</code>.</p>
<p>It may occur to you that if you wanted to pass in a reference to a scalar primitive value like <code>2</code>, you could just box the value in its <code>Number</code> object wrapper (see Chapter 3).</p>
<p>It <em>is</em> true a copy of the reference to this <code>Number</code> object <em>will</em> be passed to the function, but unfortunately, having a reference to the shared object is not going to give you the ability to modify the shared primitive value, like you may expect:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(x) <span class="op">{</span>
    x <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>
    x<span class="op">;</span> <span class="co">// 3</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="kw">new</span> <span class="at">Number</span>( a )<span class="op">;</span> <span class="co">// or equivalently `Object(a)`</span>

<span class="at">foo</span>( b )<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>( b )<span class="op">;</span> <span class="co">// 2, not 3</span></code></pre></div>
<p>The problem is that the underlying scalar primitive value is <em>not mutable</em> (same goes for <code>String</code> and <code>Boolean</code>). If a <code>Number</code> object holds the scalar primitive value <code>2</code>, that exact <code>Number</code> object can never be changed to hold another value; you can only create a whole new <code>Number</code> object with a different value.</p>
<p>When <code>x</code> is used in the expression <code>x + 1</code>, the underlying scalar primitive value <code>2</code> is unboxed (extracted) from the <code>Number</code> object automatically, so the line <code>x = x + 1</code> very subtly changes <code>x</code> from being a shared reference to the <code>Number</code> object, to just holding the scalar primitive value <code>3</code> as a result of the addition operation <code>2 + 1</code>. Therefore, <code>b</code> on the outside still references the original unmodified/immutable <code>Number</code> object holding the value <code>2</code>.</p>
<p>You <em>can</em> add properties on top of the <code>Number</code> object (just not change its inner primitive value), so you could exchange information indirectly via those additional properties.</p>
<p>This is not all that common, however; it probably would not be considered a good practice by most developers.</p>
<p>Instead of using the wrapper object <code>Number</code> in this way, it's probably much better to use the manual object wrapper (<code>obj</code>) approach in the earlier snippet. That's not to say that there's no clever uses for the boxed object wrappers like <code>Number</code> -- just that you should probably prefer the scalar primitive value form in most cases.</p>
<p>References are quite powerful, but sometimes they get in your way, and sometimes you need them where they don't exist. The only control you have over reference vs. value-copy behavior is the type of the value itself, so you must indirectly influence the assignment/passing behavior by which value types you choose to use.</p>
<h2 id="review-1">Review</h2>
<p>In JavaScript, <code>array</code>s are simply numerically indexed collections of any value-type. <code>string</code>s are somewhat &quot;<code>array</code>-like&quot;, but they have distinct behaviors and care must be taken if you want to treat them as <code>array</code>s. Numbers in JavaScript include both &quot;integers&quot; and floating-point values.</p>
<p>Several special values are defined within the primitive types.</p>
<p>The <code>null</code> type has just one value: <code>null</code>, and likewise the <code>undefined</code> type has just the <code>undefined</code> value. <code>undefined</code> is basically the default value in any variable or property if no other value is present. The <code>void</code> operator lets you create the <code>undefined</code> value from any other value.</p>
<p><code>number</code>s include several special values, like <code>NaN</code> (supposedly &quot;Not a Number&quot;, but really more appropriately &quot;invalid number&quot;); <code>+Infinity</code> and <code>-Infinity</code>; and <code>-0</code>.</p>
<p>Simple scalar primitives (<code>string</code>s, <code>number</code>s, etc.) are assigned/passed by value-copy, but compound values (<code>object</code>s, etc.) are assigned/passed by reference-copy. References are not like references/pointers in other languages -- they're never pointed at other variables/references, only at the underlying values.</p>
<h1 id="you-dont-know-js-types-grammar-3">You Don't Know JS: Types &amp; Grammar</h1>
<h1 id="chapter-3-natives">Chapter 3: Natives</h1>
<p>Several times in Chapters 1 and 2, we alluded to various built-ins, usually called &quot;natives,&quot; like <code>String</code> and <code>Number</code>. Let's examine those in detail now.</p>
<p>Here's a list of the most commonly used natives:</p>
<ul>
<li><code>String()</code></li>
<li><code>Number()</code></li>
<li><code>Boolean()</code></li>
<li><code>Array()</code></li>
<li><code>Object()</code></li>
<li><code>Function()</code></li>
<li><code>RegExp()</code></li>
<li><code>Date()</code></li>
<li><code>Error()</code></li>
<li><code>Symbol()</code> -- added in ES6!</li>
</ul>
<p>As you can see, these natives are actually built-in functions.</p>
<p>If you're coming to JS from a language like Java, JavaScript's <code>String()</code> will look like the <code>String(..)</code> constructor you're used to for creating string values. So, you'll quickly observe that you can do things like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> s <span class="op">=</span> <span class="kw">new</span> <span class="at">String</span>( <span class="st">&quot;Hello World!&quot;</span> )<span class="op">;</span>

<span class="va">console</span>.<span class="at">log</span>( <span class="va">s</span>.<span class="at">toString</span>() )<span class="op">;</span> <span class="co">// &quot;Hello World!&quot;</span></code></pre></div>
<p>It <em>is</em> true that each of these natives can be used as a native constructor. But what's being constructed may be different than you think.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">String</span>( <span class="st">&quot;abc&quot;</span> )<span class="op">;</span>

<span class="kw">typeof</span> a<span class="op">;</span> <span class="co">// &quot;object&quot; ... not &quot;String&quot;</span>

a <span class="kw">instanceof</span> String<span class="op">;</span> <span class="co">// true</span>

<span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( a )<span class="op">;</span> <span class="co">// &quot;[object String]&quot;</span></code></pre></div>
<p>The result of the constructor form of value creation (<code>new String(&quot;abc&quot;)</code>) is an object wrapper around the primitive (<code>&quot;abc&quot;</code>) value.</p>
<p>Importantly, <code>typeof</code> shows that these objects are not their own special <em>types</em>, but more appropriately they are subtypes of the <code>object</code> type.</p>
<p>This object wrapper can further be observed with:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">console</span>.<span class="at">log</span>( a )<span class="op">;</span></code></pre></div>
<p>The output of that statement varies depending on your browser, as developer consoles are free to choose however they feel it's appropriate to serialize the object for developer inspection.</p>
<p><strong>Note:</strong> At the time of writing, the latest Chrome prints something like this: <code>String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}</code>. But older versions of Chrome used to just print this: <code>String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}</code>. The latest Firefox currently prints <code>String [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>, but used to print <code>&quot;abc&quot;</code> in italics, which was clickable to open the object inspector. Of course, these results are subject to rapid change and your experience may vary.</p>
<p>The point is, <code>new String(&quot;abc&quot;)</code> creates a string wrapper object around <code>&quot;abc&quot;</code>, not just the primitive <code>&quot;abc&quot;</code> value itself.</p>
<h2 id="internal-class">Internal <code>[[Class]]</code></h2>
<p>Values that are <code>typeof</code> <code>&quot;object&quot;</code> (such as an array) are additionally tagged with an internal <code>[[Class]]</code> property (think of this more as an internal <em>class</em>ification rather than related to classes from traditional class-oriented coding). This property cannot be accessed directly, but can generally be revealed indirectly by borrowing the default <code>Object.prototype.toString(..)</code> method called against the value. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>] )<span class="op">;</span>          <span class="co">// &quot;[object Array]&quot;</span>

<span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( <span class="ss">/regex-literal/i</span> )<span class="op">;</span> <span class="co">// &quot;[object RegExp]&quot;</span></code></pre></div>
<p>So, for the array in this example, the internal <code>[[Class]]</code> value is <code>&quot;Array&quot;</code>, and for the regular expression, it's <code>&quot;RegExp&quot;</code>. In most cases, this internal <code>[[Class]]</code> value corresponds to the built-in native constructor (see below) that's related to the value, but that's not always the case.</p>
<p>What about primitive values? First, <code>null</code> and <code>undefined</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( <span class="kw">null</span> )<span class="op">;</span>         <span class="co">// &quot;[object Null]&quot;</span>
<span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( <span class="kw">undefined</span> )<span class="op">;</span>    <span class="co">// &quot;[object Undefined]&quot;</span></code></pre></div>
<p>You'll note that there are no <code>Null()</code> or <code>Undefined()</code> native constructors, but nevertheless the <code>&quot;Null&quot;</code> and <code>&quot;Undefined&quot;</code> are the internal <code>[[Class]]</code> values exposed.</p>
<p>But for the other simple primitives like <code>string</code>, <code>number</code>, and <code>boolean</code>, another behavior actually kicks in, which is usually called &quot;boxing&quot; (see &quot;Boxing Wrappers&quot; section next):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( <span class="st">&quot;abc&quot;</span> )<span class="op">;</span>    <span class="co">// &quot;[object String]&quot;</span>
<span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( <span class="dv">42</span> )<span class="op">;</span>       <span class="co">// &quot;[object Number]&quot;</span>
<span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( <span class="kw">true</span> )<span class="op">;</span>     <span class="co">// &quot;[object Boolean]&quot;</span></code></pre></div>
<p>In this snippet, each of the simple primitives are automatically boxed by their respective object wrappers, which is why <code>&quot;String&quot;</code>, <code>&quot;Number&quot;</code>, and <code>&quot;Boolean&quot;</code> are revealed as the respective internal <code>[[Class]]</code> values.</p>
<p><strong>Note:</strong> The behavior of <code>toString()</code> and <code>[[Class]]</code> as illustrated here has changed a bit from ES5 to ES6, but we cover those details in the <em>ES6 &amp; Beyond</em> title of this series.</p>
<h2 id="boxing-wrappers">Boxing Wrappers</h2>
<p>These object wrappers serve a very important purpose. Primitive values don't have properties or methods, so to access <code>.length</code> or <code>.toString()</code> you need an object wrapper around the value. Thankfully, JS will automatically <em>box</em> (aka wrap) the primitive value to fulfill such accesses.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span>

<span class="va">a</span>.<span class="at">length</span><span class="op">;</span> <span class="co">// 3</span>
<span class="va">a</span>.<span class="at">toUpperCase</span>()<span class="op">;</span> <span class="co">// &quot;ABC&quot;</span></code></pre></div>
<p>So, if you're going to be accessing these properties/methods on your string values regularly, like a <code>i &lt; a.length</code> condition in a <code>for</code> loop for instance, it might seem to make sense to just have the object form of the value from the start, so the JS engine doesn't need to implicitly create it for you.</p>
<p>But it turns out that's a bad idea. Browsers long ago performance-optimized the common cases like <code>.length</code>, which means your program will <em>actually go slower</em> if you try to &quot;preoptimize&quot; by directly using the object form (which isn't on the optimized path).</p>
<p>In general, there's basically no reason to use the object form directly. It's better to just let the boxing happen implicitly where necessary. In other words, never do things like <code>new String(&quot;abc&quot;)</code>, <code>new Number(42)</code>, etc -- always prefer using the literal primitive values <code>&quot;abc&quot;</code> and <code>42</code>.</p>
<h3 id="object-wrapper-gotchas">Object Wrapper Gotchas</h3>
<p>There are some gotchas with using the object wrappers directly that you should be aware of if you <em>do</em> choose to ever use them.</p>
<p>For example, consider <code>Boolean</code> wrapped values:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Boolean</span>( <span class="kw">false</span> )<span class="op">;</span>

<span class="cf">if</span> (<span class="op">!</span>a) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Oops&quot;</span> )<span class="op">;</span> <span class="co">// never runs</span>
<span class="op">}</span></code></pre></div>
<p>The problem is that you've created an object wrapper around the <code>false</code> value, but objects themselves are &quot;truthy&quot; (see Chapter 4), so using the object behaves oppositely to using the underlying <code>false</code> value itself, which is quite contrary to normal expectation.</p>
<p>If you want to manually box a primitive value, you can use the <code>Object(..)</code> function (no <code>new</code> keyword):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="kw">new</span> <span class="at">String</span>( a )<span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="at">Object</span>( a )<span class="op">;</span>

<span class="kw">typeof</span> a<span class="op">;</span> <span class="co">// &quot;string&quot;</span>
<span class="kw">typeof</span> b<span class="op">;</span> <span class="co">// &quot;object&quot;</span>
<span class="kw">typeof</span> c<span class="op">;</span> <span class="co">// &quot;object&quot;</span>

b <span class="kw">instanceof</span> String<span class="op">;</span> <span class="co">// true</span>
c <span class="kw">instanceof</span> String<span class="op">;</span> <span class="co">// true</span>

<span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( b )<span class="op">;</span> <span class="co">// &quot;[object String]&quot;</span>
<span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( c )<span class="op">;</span> <span class="co">// &quot;[object String]&quot;</span></code></pre></div>
<p>Again, using the boxed object wrapper directly (like <code>b</code> and <code>c</code> above) is usually discouraged, but there may be some rare occasions you'll run into where they may be useful.</p>
<h2 id="unboxing">Unboxing</h2>
<p>If you have an object wrapper and you want to get the underlying primitive value out, you can use the <code>valueOf()</code> method:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">String</span>( <span class="st">&quot;abc&quot;</span> )<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="kw">new</span> <span class="at">Number</span>( <span class="dv">42</span> )<span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="kw">new</span> <span class="at">Boolean</span>( <span class="kw">true</span> )<span class="op">;</span>

<span class="va">a</span>.<span class="at">valueOf</span>()<span class="op">;</span> <span class="co">// &quot;abc&quot;</span>
<span class="va">b</span>.<span class="at">valueOf</span>()<span class="op">;</span> <span class="co">// 42</span>
<span class="va">c</span>.<span class="at">valueOf</span>()<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>Unboxing can also happen implicitly, when using an object wrapper value in a way that requires the primitive value. This process (coercion) will be covered in more detail in Chapter 4, but briefly:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">String</span>( <span class="st">&quot;abc&quot;</span> )<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> a <span class="op">+</span> <span class="st">&quot;&quot;</span><span class="op">;</span> <span class="co">// `b` has the unboxed primitive value &quot;abc&quot;</span>

<span class="kw">typeof</span> a<span class="op">;</span> <span class="co">// &quot;object&quot;</span>
<span class="kw">typeof</span> b<span class="op">;</span> <span class="co">// &quot;string&quot;</span></code></pre></div>
<h2 id="natives-as-constructors">Natives as Constructors</h2>
<p>For <code>array</code>, <code>object</code>, <code>function</code>, and regular-expression values, it's almost universally preferred that you use the literal form for creating the values, but the literal form creates the same sort of object as the constructor form does (that is, there is no nonwrapped value).</p>
<p>Just as we've seen above with the other natives, these constructor forms should generally be avoided, unless you really know you need them, mostly because they introduce exceptions and gotchas that you probably don't really <em>want</em> to deal with.</p>
<h3 id="array.."><code>Array(..)</code></h3>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Array</span>( <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> )<span class="op">;</span>
a<span class="op">;</span> <span class="co">// [1, 2, 3]</span>

<span class="kw">var</span> b <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span>
b<span class="op">;</span> <span class="co">// [1, 2, 3]</span></code></pre></div>
<p><strong>Note:</strong> The <code>Array(..)</code> constructor does not require the <code>new</code> keyword in front of it. If you omit it, it will behave as if you have used it anyway. So <code>Array(1,2,3)</code> is the same outcome as <code>new Array(1,2,3)</code>.</p>
<p>The <code>Array</code> constructor has a special form where if only one <code>number</code> argument is passed, instead of providing that value as <em>contents</em> of the array, it's taken as a length to &quot;presize the array&quot; (well, sorta).</p>
<p>This is a terrible idea. Firstly, you can trip over that form accidentally, as it's easy to forget.</p>
<p>But more importantly, there's no such thing as actually presizing the array. Instead, what you're creating is an otherwise empty array, but setting the <code>length</code> property of the array to the numeric value specified.</p>
<p>An array that has no explicit values in its slots, but has a <code>length</code> property that <em>implies</em> the slots exist, is a weird exotic type of data structure in JS with some very strange and confusing behavior. The capability to create such a value comes purely from old, deprecated, historical functionalities (&quot;array-like objects&quot; like the <code>arguments</code> object).</p>
<p><strong>Note:</strong> An array with at least one &quot;empty slot&quot; in it is often called a &quot;sparse array.&quot;</p>
<p>It doesn't help matters that this is yet another example where browser developer consoles vary on how they represent such an object, which breeds more confusion.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Array</span>( <span class="dv">3</span> )<span class="op">;</span>

<span class="va">a</span>.<span class="at">length</span><span class="op">;</span> <span class="co">// 3</span>
a<span class="op">;</span></code></pre></div>
<p>The serialization of <code>a</code> in Chrome is (at the time of writing): <code>[ undefined x 3 ]</code>. <strong>This is really unfortunate.</strong> It implies that there are three <code>undefined</code> values in the slots of this array, when in fact the slots do not exist (so-called &quot;empty slots&quot; -- also a bad name!).</p>
<p>To visualize the difference, try this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Array</span>( <span class="dv">3</span> )<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> [ <span class="kw">undefined</span><span class="op">,</span> <span class="kw">undefined</span><span class="op">,</span> <span class="kw">undefined</span> ]<span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> []<span class="op">;</span>
<span class="va">c</span>.<span class="at">length</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>

a<span class="op">;</span>
b<span class="op">;</span>
c<span class="op">;</span></code></pre></div>
<p><strong>Note:</strong> As you can see with <code>c</code> in this example, empty slots in an array can happen after creation of the array. Changing the <code>length</code> of an array to go beyond its number of actually-defined slot values, you implicitly introduce empty slots. In fact, you could even call <code>delete b[1]</code> in the above snippet, and it would introduce an empty slot into the middle of <code>b</code>.</p>
<p>For <code>b</code> (in Chrome, currently), you'll find <code>[ undefined, undefined, undefined ]</code> as the serialization, as opposed to <code>[ undefined x 3 ]</code> for <code>a</code> and <code>c</code>. Confused? Yeah, so is everyone else.</p>
<p>Worse than that, at the time of writing, Firefox reports <code>[ , , , ]</code> for <code>a</code> and <code>c</code>. Did you catch why that's so confusing? Look closely. Three commas implies four slots, not three slots like we'd expect.</p>
<p><strong>What!?</strong> Firefox puts an extra <code>,</code> on the end of their serialization here because as of ES5, trailing commas in lists (array values, property lists, etc.) are allowed (and thus dropped and ignored). So if you were to type in a <code>[ , , , ]</code> value into your program or the console, you'd actually get the underlying value that's like <code>[ , , ]</code> (that is, an array with three empty slots). This choice, while confusing if reading the developer console, is defended as instead making copy-n-paste behavior accurate.</p>
<p>If you're shaking your head or rolling your eyes about now, you're not alone! Shrugs.</p>
<p>Unfortunately, it gets worse. More than just confusing console output, <code>a</code> and <code>b</code> from the above code snippet actually behave the same in some cases <strong>but differently in others</strong>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">a</span>.<span class="at">join</span>( <span class="st">&quot;-&quot;</span> )<span class="op">;</span> <span class="co">// &quot;--&quot;</span>
<span class="va">b</span>.<span class="at">join</span>( <span class="st">&quot;-&quot;</span> )<span class="op">;</span> <span class="co">// &quot;--&quot;</span>

<span class="va">a</span>.<span class="at">map</span>(<span class="kw">function</span>(v<span class="op">,</span>i)<span class="op">{</span> <span class="cf">return</span> i<span class="op">;</span> <span class="op">}</span>)<span class="op">;</span> <span class="co">// [ undefined x 3 ]</span>
<span class="va">b</span>.<span class="at">map</span>(<span class="kw">function</span>(v<span class="op">,</span>i)<span class="op">{</span> <span class="cf">return</span> i<span class="op">;</span> <span class="op">}</span>)<span class="op">;</span> <span class="co">// [ 0, 1, 2 ]</span></code></pre></div>
<p><strong>Ugh.</strong></p>
<p>The <code>a.map(..)</code> call <em>fails</em> because the slots don't actually exist, so <code>map(..)</code> has nothing to iterate over. <code>join(..)</code> works differently. Basically, we can think of it implemented sort of like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">fakeJoin</span>(arr<span class="op">,</span>connector) <span class="op">{</span>
    <span class="kw">var</span> str <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span>
    <span class="cf">for</span> (<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
        <span class="cf">if</span> (i <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span>
            str <span class="op">+=</span> connector<span class="op">;</span>
        <span class="op">}</span>
        <span class="cf">if</span> (arr[i] <span class="op">!==</span> <span class="kw">undefined</span>) <span class="op">{</span>
            str <span class="op">+=</span> arr[i]<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>
    <span class="cf">return</span> str<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Array</span>( <span class="dv">3</span> )<span class="op">;</span>
<span class="at">fakeJoin</span>( a<span class="op">,</span> <span class="st">&quot;-&quot;</span> )<span class="op">;</span> <span class="co">// &quot;--&quot;</span></code></pre></div>
<p>As you can see, <code>join(..)</code> works by just <em>assuming</em> the slots exist and looping up to the <code>length</code> value. Whatever <code>map(..)</code> does internally, it (apparently) doesn't make such an assumption, so the result from the strange &quot;empty slots&quot; array is unexpected and likely to cause failure.</p>
<p>So, if you wanted to <em>actually</em> create an array of actual <code>undefined</code> values (not just &quot;empty slots&quot;), how could you do it (besides manually)?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="va">Array</span>.<span class="at">apply</span>( <span class="kw">null</span><span class="op">,</span> <span class="op">{</span> <span class="dt">length</span><span class="op">:</span> <span class="dv">3</span> <span class="op">}</span> )<span class="op">;</span>
a<span class="op">;</span> <span class="co">// [ undefined, undefined, undefined ]</span></code></pre></div>
<p>Confused? Yeah. Here's roughly how it works.</p>
<p><code>apply(..)</code> is a utility available to all functions, which calls the function it's used with but in a special way.</p>
<p>The first argument is a <code>this</code> object binding (covered in the <em>this &amp; Object Prototypes</em> title of this series), which we don't care about here, so we set it to <code>null</code>. The second argument is supposed to be an array (or something <em>like</em> an array -- aka an &quot;array-like object&quot;). The contents of this &quot;array&quot; are &quot;spread&quot; out as arguments to the function in question.</p>
<p>So, <code>Array.apply(..)</code> is calling the <code>Array(..)</code> function and spreading out the values (of the <code>{ length: 3 }</code> object value) as its arguments.</p>
<p>Inside of <code>apply(..)</code>, we can envision there's another <code>for</code> loop (kinda like <code>join(..)</code> from above) that goes from <code>0</code> up to, but not including, <code>length</code> (<code>3</code> in our case).</p>
<p>For each index, it retrieves that key from the object. So if the array-object parameter was named <code>arr</code> internally inside of the <code>apply(..)</code> function, the property access would effectively be <code>arr[0]</code>, <code>arr[1]</code>, and <code>arr[2]</code>. Of course, none of those properties exist on the <code>{ length: 3 }</code> object value, so all three of those property accesses would return the value <code>undefined</code>.</p>
<p>In other words, it ends up calling <code>Array(..)</code> basically like this: <code>Array(undefined,undefined,undefined)</code>, which is how we end up with an array filled with <code>undefined</code> values, and not just those (crazy) empty slots.</p>
<p>While <code>Array.apply( null, { length: 3 } )</code> is a strange and verbose way to create an array filled with <code>undefined</code> values, it's <strong>vastly</strong> better and more reliable than what you get with the footgun'ish <code>Array(3)</code> empty slots.</p>
<p>Bottom line: <strong>never ever, under any circumstances</strong>, should you intentionally create and use these exotic empty-slot arrays. Just don't do it. They're nuts.</p>
<h3 id="object..-function..-and-regexp.."><code>Object(..)</code>, <code>Function(..)</code>, and <code>RegExp(..)</code></h3>
<p>The <code>Object(..)</code>/<code>Function(..)</code>/<code>RegExp(..)</code> constructors are also generally optional (and thus should usually be avoided unless specifically called for):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> c <span class="op">=</span> <span class="kw">new</span> <span class="at">Object</span>()<span class="op">;</span>
<span class="va">c</span>.<span class="at">foo</span> <span class="op">=</span> <span class="st">&quot;bar&quot;</span><span class="op">;</span>
c<span class="op">;</span> <span class="co">// { foo: &quot;bar&quot; }</span>

<span class="kw">var</span> d <span class="op">=</span> <span class="op">{</span> <span class="dt">foo</span><span class="op">:</span> <span class="st">&quot;bar&quot;</span> <span class="op">};</span>
d<span class="op">;</span> <span class="co">// { foo: &quot;bar&quot; }</span>

<span class="kw">var</span> e <span class="op">=</span> <span class="kw">new</span> <span class="at">Function</span>( <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;return a * 2;&quot;</span> )<span class="op">;</span>
<span class="kw">var</span> f <span class="op">=</span> <span class="kw">function</span>(a) <span class="op">{</span> <span class="cf">return</span> a <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="op">};</span>
<span class="kw">function</span> <span class="at">g</span>(a) <span class="op">{</span> <span class="cf">return</span> a <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span>

<span class="kw">var</span> h <span class="op">=</span> <span class="kw">new</span> <span class="at">RegExp</span>( <span class="st">&quot;^a*b+&quot;</span><span class="op">,</span> <span class="st">&quot;g&quot;</span> )<span class="op">;</span>
<span class="kw">var</span> i <span class="op">=</span> <span class="ss">/</span><span class="sc">^</span><span class="ss">a</span><span class="sc">*</span><span class="ss">b</span><span class="sc">+</span><span class="ss">/g</span><span class="op">;</span></code></pre></div>
<p>There's practically no reason to ever use the <code>new Object()</code> constructor form, especially since it forces you to add properties one-by-one instead of many at once in the object literal form.</p>
<p>The <code>Function</code> constructor is helpful only in the rarest of cases, where you need to dynamically define a function's parameters and/or its function body. <strong>Do not just treat <code>Function(..)</code> as an alternate form of <code>eval(..)</code>.</strong> You will almost never need to dynamically define a function in this way.</p>
<p>Regular expressions defined in the literal form (<code>/^a*b+/g</code>) are strongly preferred, not just for ease of syntax but for performance reasons -- the JS engine precompiles and caches them before code execution. Unlike the other constructor forms we've seen so far, <code>RegExp(..)</code> has some reasonable utility: to dynamically define the pattern for a regular expression.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> name <span class="op">=</span> <span class="st">&quot;Kyle&quot;</span><span class="op">;</span>
<span class="kw">var</span> namePattern <span class="op">=</span> <span class="kw">new</span> <span class="at">RegExp</span>( <span class="st">&quot;</span><span class="sc">\\</span><span class="st">b(?:&quot;</span> <span class="op">+</span> name <span class="op">+</span> <span class="st">&quot;)+</span><span class="sc">\\</span><span class="st">b&quot;</span><span class="op">,</span> <span class="st">&quot;ig&quot;</span> )<span class="op">;</span>

<span class="kw">var</span> matches <span class="op">=</span> <span class="va">someText</span>.<span class="at">match</span>( namePattern )<span class="op">;</span></code></pre></div>
<p>This kind of scenario legitimately occurs in JS programs from time to time, so you'd need to use the <code>new RegExp(&quot;pattern&quot;,&quot;flags&quot;)</code> form.</p>
<h3 id="date..-and-error.."><code>Date(..)</code> and <code>Error(..)</code></h3>
<p>The <code>Date(..)</code> and <code>Error(..)</code> native constructors are much more useful than the other natives, because there is no literal form for either.</p>
<p>To create a date object value, you must use <code>new Date()</code>. The <code>Date(..)</code> constructor accepts optional arguments to specify the date/time to use, but if omitted, the current date/time is assumed.</p>
<p>By far the most common reason you construct a date object is to get the current timestamp value (a signed integer number of milliseconds since Jan 1, 1970). You can do this by calling <code>getTime()</code> on a date object instance.</p>
<p>But an even easier way is to just call the static helper function defined as of ES5: <code>Date.now()</code>. And to polyfill that for pre-ES5 is pretty easy:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Date</span>.<span class="at">now</span>) <span class="op">{</span>
    <span class="va">Date</span>.<span class="at">now</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">{</span>
        <span class="cf">return</span> (<span class="kw">new</span> <span class="at">Date</span>()).<span class="at">getTime</span>()<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p><strong>Note:</strong> If you call <code>Date()</code> without <code>new</code>, you'll get back a string representation of the date/time at that moment. The exact form of this representation is not specified in the language spec, though browsers tend to agree on something close to: <code>&quot;Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)&quot;</code>.</p>
<p>The <code>Error(..)</code> constructor (much like <code>Array()</code> above) behaves the same with the <code>new</code> keyword present or omitted.</p>
<p>The main reason you'd want to create an error object is that it captures the current execution stack context into the object (in most JS engines, revealed as a read-only <code>.stack</code> property once constructed). This stack context includes the function call-stack and the line-number where the error object was created, which makes debugging that error much easier.</p>
<p>You would typically use such an error object with the <code>throw</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(x) <span class="op">{</span>
    <span class="cf">if</span> (<span class="op">!</span>x) <span class="op">{</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>( <span class="st">&quot;x wasn&#39;t provided&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>Error object instances generally have at least a <code>message</code> property, and sometimes other properties (which you should treat as read-only), like <code>type</code>. However, other than inspecting the above-mentioned <code>stack</code> property, it's usually best to just call <code>toString()</code> on the error object (either explicitly, or implicitly through coercion -- see Chapter 4) to get a friendly-formatted error message.</p>
<p><strong>Tip:</strong> Technically, in addition to the general <code>Error(..)</code> native, there are several other specific-error-type natives: <code>EvalError(..)</code>, <code>RangeError(..)</code>, <code>ReferenceError(..)</code>, <code>SyntaxError(..)</code>, <code>TypeError(..)</code>, and <code>URIError(..)</code>. But it's very rare to manually use these specific error natives. They are automatically used if your program actually suffers from a real exception (such as referencing an undeclared variable and getting a <code>ReferenceError</code> error).</p>
<h3 id="symbol.."><code>Symbol(..)</code></h3>
<p>New as of ES6, an additional primitive value type has been added, called &quot;Symbol&quot;. Symbols are special &quot;unique&quot; (not strictly guaranteed!) values that can be used as properties on objects with little fear of any collision. They're primarily designed for special built-in behaviors of ES6 constructs, but you can also define your own symbols.</p>
<p>Symbols can be used as property names, but you cannot see or access the actual value of a symbol from your program, nor from the developer console. If you evaluate a symbol in the developer console, what's shown looks like <code>Symbol(Symbol.create)</code>, for example.</p>
<p>There are several predefined symbols in ES6, accessed as static properties of the <code>Symbol</code> function object, like <code>Symbol.create</code>, <code>Symbol.iterator</code>, etc. To use them, do something like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">obj[<span class="va">Symbol</span>.<span class="at">iterator</span>] <span class="op">=</span> <span class="kw">function</span>()<span class="op">{</span> <span class="co">/*..*/</span> <span class="op">};</span></code></pre></div>
<p>To define your own custom symbols, use the <code>Symbol(..)</code> native. The <code>Symbol(..)</code> native &quot;constructor&quot; is unique in that you're not allowed to use <code>new</code> with it, as doing so will throw an error.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> mysym <span class="op">=</span> <span class="at">Symbol</span>( <span class="st">&quot;my own symbol&quot;</span> )<span class="op">;</span>
mysym<span class="op">;</span>              <span class="co">// Symbol(my own symbol)</span>
<span class="va">mysym</span>.<span class="at">toString</span>()<span class="op">;</span>   <span class="co">// &quot;Symbol(my own symbol)&quot;</span>
<span class="kw">typeof</span> mysym<span class="op">;</span>       <span class="co">// &quot;symbol&quot;</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span> <span class="op">};</span>
a[mysym] <span class="op">=</span> <span class="st">&quot;foobar&quot;</span><span class="op">;</span>

<span class="va">Object</span>.<span class="at">getOwnPropertySymbols</span>( a )<span class="op">;</span>
<span class="co">// [ Symbol(my own symbol) ]</span></code></pre></div>
<p>While symbols are not actually private (<code>Object.getOwnPropertySymbols(..)</code> reflects on the object and reveals the symbols quite publicly), using them for private or special properties is likely their primary use-case. For most developers, they may take the place of property names with <code>_</code> underscore prefixes, which are almost always by convention signals to say, &quot;hey, this is a private/special/internal property, so leave it alone!&quot;</p>
<p><strong>Note:</strong> <code>Symbol</code>s are <em>not</em> <code>object</code>s, they are simple scalar primitives.</p>
<h3 id="native-prototypes">Native Prototypes</h3>
<p>Each of the built-in native constructors has its own <code>.prototype</code> object -- <code>Array.prototype</code>, <code>String.prototype</code>, etc.</p>
<p>These objects contain behavior unique to their particular object subtype.</p>
<p>For example, all string objects, and by extension (via boxing) <code>string</code> primitives, have access to default behavior as methods defined on the <code>String.prototype</code> object.</p>
<p><strong>Note:</strong> By documentation convention, <code>String.prototype.XYZ</code> is shortened to <code>String#XYZ</code>, and likewise for all the other <code>.prototype</code>s.</p>
<ul>
<li><code>String#indexOf(..)</code>: find the position in the string of another substring</li>
<li><code>String#charAt(..)</code>: access the character at a position in the string</li>
<li><code>String#substr(..)</code>, <code>String#substring(..)</code>, and <code>String#slice(..)</code>: extract a portion of the string as a new string</li>
<li><code>String#toUpperCase()</code> and <code>String#toLowerCase()</code>: create a new string that's converted to either uppercase or lowercase</li>
<li><code>String#trim()</code>: create a new string that's stripped of any trailing or leading whitespace</li>
</ul>
<p>None of the methods modify the string <em>in place</em>. Modifications (like case conversion or trimming) create a new value from the existing value.</p>
<p>By virtue of prototype delegation (see the <em>this &amp; Object Prototypes</em> title in this series), any string value can access these methods:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot; abc &quot;</span><span class="op">;</span>

<span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;c&quot;</span> )<span class="op">;</span> <span class="co">// 3</span>
<span class="va">a</span>.<span class="at">toUpperCase</span>()<span class="op">;</span> <span class="co">// &quot; ABC &quot;</span>
<span class="va">a</span>.<span class="at">trim</span>()<span class="op">;</span> <span class="co">// &quot;abc&quot;</span></code></pre></div>
<p>The other constructor prototypes contain behaviors appropriate to their types, such as <code>Number#toFixed(..)</code> (stringifying a number with a fixed number of decimal digits) and <code>Array#concat(..)</code> (merging arrays). All functions have access to <code>apply(..)</code>, <code>call(..)</code>, and <code>bind(..)</code> because <code>Function.prototype</code> defines them.</p>
<p>But, some of the native prototypes aren't <em>just</em> plain objects:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">typeof</span> <span class="va">Function</span>.<span class="at">prototype</span><span class="op">;</span>          <span class="co">// &quot;function&quot;</span>
<span class="va">Function</span>.<span class="at">prototype</span>()<span class="op">;</span>               <span class="co">// it&#39;s an empty function!</span>

<span class="va">RegExp</span>.<span class="va">prototype</span>.<span class="at">toString</span>()<span class="op">;</span>        <span class="co">// &quot;/(?:)/&quot; -- empty regex</span>
<span class="st">&quot;abc&quot;</span>.<span class="at">match</span>( <span class="va">RegExp</span>.<span class="at">prototype</span> )<span class="op">;</span>    <span class="co">// [&quot;&quot;]</span></code></pre></div>
<p>A particularly bad idea, you can even modify these native prototypes (not just adding properties as you're probably familiar with):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Array</span>.<span class="at">isArray</span>( <span class="va">Array</span>.<span class="at">prototype</span> )<span class="op">;</span>   <span class="co">// true</span>
<span class="va">Array</span>.<span class="va">prototype</span>.<span class="at">push</span>( <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> )<span class="op">;</span>    <span class="co">// 3</span>
<span class="va">Array</span>.<span class="at">prototype</span><span class="op">;</span>                    <span class="co">// [1,2,3]</span>

<span class="co">// don&#39;t leave it that way, though, or expect weirdness!</span>
<span class="co">// reset the `Array.prototype` to empty</span>
<span class="va">Array</span>.<span class="va">prototype</span>.<span class="at">length</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></code></pre></div>
<p>As you can see, <code>Function.prototype</code> is a function, <code>RegExp.prototype</code> is a regular expression, and <code>Array.prototype</code> is an array. Interesting and cool, huh?</p>
<h4 id="prototypes-as-defaults">Prototypes As Defaults</h4>
<p><code>Function.prototype</code> being an empty function, <code>RegExp.prototype</code> being an &quot;empty&quot; (e.g., non-matching) regex, and <code>Array.prototype</code> being an empty array, make them all nice &quot;default&quot; values to assign to variables if those variables wouldn't already have had a value of the proper type.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">isThisCool</span>(vals<span class="op">,</span>fn<span class="op">,</span>rx) <span class="op">{</span>
    vals <span class="op">=</span> vals <span class="op">||</span> <span class="va">Array</span>.<span class="at">prototype</span><span class="op">;</span>
    fn <span class="op">=</span> fn <span class="op">||</span> <span class="va">Function</span>.<span class="at">prototype</span><span class="op">;</span>
    rx <span class="op">=</span> rx <span class="op">||</span> <span class="va">RegExp</span>.<span class="at">prototype</span><span class="op">;</span>

    <span class="cf">return</span> <span class="va">rx</span>.<span class="at">test</span>(
        <span class="va">vals</span>.<span class="at">map</span>( fn ).<span class="at">join</span>( <span class="st">&quot;&quot;</span> )
    )<span class="op">;</span>
<span class="op">}</span>

<span class="at">isThisCool</span>()<span class="op">;</span>       <span class="co">// true</span>

<span class="at">isThisCool</span>(
    [<span class="st">&quot;a&quot;</span><span class="op">,</span><span class="st">&quot;b&quot;</span><span class="op">,</span><span class="st">&quot;c&quot;</span>]<span class="op">,</span>
    <span class="kw">function</span>(v)<span class="op">{</span> <span class="cf">return</span> <span class="va">v</span>.<span class="at">toUpperCase</span>()<span class="op">;</span> <span class="op">},</span>
    <span class="ss">/D/</span>
)<span class="op">;</span>                  <span class="co">// false</span></code></pre></div>
<p><strong>Note:</strong> As of ES6, we don't need to use the <code>vals = vals || ..</code> default value syntax trick (see Chapter 4) anymore, because default values can be set for parameters via native syntax in the function declaration (see Chapter 5).</p>
<p>One minor side-benefit of this approach is that the <code>.prototype</code>s are already created and built-in, thus created <em>only once</em>. By contrast, using <code>[]</code>, <code>function(){}</code>, and <code>/(?:)/</code> values themselves for those defaults would (likely, depending on engine implementations) be recreating those values (and probably garbage-collecting them later) for <em>each call</em> of <code>isThisCool(..)</code>. That could be memory/CPU wasteful.</p>
<p>Also, be very careful not to use <code>Array.prototype</code> as a default value <strong>that will subsequently be modified</strong>. In this example, <code>vals</code> is used read-only, but if you were to instead make in-place changes to <code>vals</code>, you would actually be modifying <code>Array.prototype</code> itself, which would lead to the gotchas mentioned earlier!</p>
<p><strong>Note:</strong> While we're pointing out these native prototypes and some usefulness, be cautious of relying on them and even more wary of modifying them in any way. See Appendix A &quot;Native Prototypes&quot; for more discussion.</p>
<h2 id="review-2">Review</h2>
<p>JavaScript provides object wrappers around primitive values, known as natives (<code>String</code>, <code>Number</code>, <code>Boolean</code>, etc). These object wrappers give the values access to behaviors appropriate for each object subtype (<code>String#trim()</code> and <code>Array#concat(..)</code>).</p>
<p>If you have a simple scalar primitive value like <code>&quot;abc&quot;</code> and you access its <code>length</code> property or some <code>String.prototype</code> method, JS automatically &quot;boxes&quot; the value (wraps it in its respective object wrapper) so that the property/method accesses can be fulfilled.</p>
<h1 id="you-dont-know-js-types-grammar-4">You Don't Know JS: Types &amp; Grammar</h1>
<h1 id="chapter-4-coercion">Chapter 4: Coercion</h1>
<p>Now that we much more fully understand JavaScript's types and values, we turn our attention to a very controversial topic: coercion.</p>
<p>As we mentioned in Chapter 1, the debates over whether coercion is a useful feature or a flaw in the design of the language (or somewhere in between!) have raged since day one. If you've read other popular books on JS, you know that the overwhelmingly prevalent <em>message</em> out there is that coercion is magical, evil, confusing, and just downright a bad idea.</p>
<p>In the same overall spirit of this book series, rather than running away from coercion because everyone else does, or because you get bitten by some quirk, I think you should run toward that which you don't understand and seek to <em>get it</em> more fully.</p>
<p>Our goal is to fully explore the pros and cons (yes, there <em>are</em> pros!) of coercion, so that you can make an informed decision on its appropriateness in your program.</p>
<h2 id="converting-values">Converting Values</h2>
<p>Converting a value from one type to another is often called &quot;type casting,&quot; when done explicitly, and &quot;coercion&quot; when done implicitly (forced by the rules of how a value is used).</p>
<p><strong>Note:</strong> It may not be obvious, but JavaScript coercions always result in one of the scalar primitive (see Chapter 2) values, like <code>string</code>, <code>number</code>, or <code>boolean</code>. There is no coercion that results in a complex value like <code>object</code> or <code>function</code>. Chapter 3 covers &quot;boxing,&quot; which wraps scalar primitive values in their <code>object</code> counterparts, but this is not really coercion in an accurate sense.</p>
<p>Another way these terms are often distinguished is as follows: &quot;type casting&quot; (or &quot;type conversion&quot;) occur in statically typed languages at compile time, while &quot;type coercion&quot; is a runtime conversion for dynamically typed languages.</p>
<p>However, in JavaScript, most people refer to all these types of conversions as <em>coercion</em>, so the way I prefer to distinguish is to say &quot;implicit coercion&quot; vs. &quot;explicit coercion.&quot;</p>
<p>The difference should be obvious: &quot;explicit coercion&quot; is when it is obvious from looking at the code that a type conversion is intentionally occurring, whereas &quot;implicit coercion&quot; is when the type conversion will occur as a less obvious side effect of some other intentional operation.</p>
<p>For example, consider these two approaches to coercion:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>

<span class="kw">var</span> b <span class="op">=</span> a <span class="op">+</span> <span class="st">&quot;&quot;</span><span class="op">;</span>         <span class="co">// implicit coercion</span>

<span class="kw">var</span> c <span class="op">=</span> <span class="at">String</span>( a )<span class="op">;</span>    <span class="co">// explicit coercion</span></code></pre></div>
<p>For <code>b</code>, the coercion that occurs happens implicitly, because the <code>+</code> operator combined with one of the operands being a <code>string</code> value (<code>&quot;&quot;</code>) will insist on the operation being a <code>string</code> concatenation (adding two strings together), which <em>as a (hidden) side effect</em> will force the <code>42</code> value in <code>a</code> to be coerced to its <code>string</code> equivalent: <code>&quot;42&quot;</code>.</p>
<p>By contrast, the <code>String(..)</code> function makes it pretty obvious that it's explicitly taking the value in <code>a</code> and coercing it to a <code>string</code> representation.</p>
<p>Both approaches accomplish the same effect: <code>&quot;42&quot;</code> comes from <code>42</code>. But it's the <em>how</em> that is at the heart of the heated debates over JavaScript coercion.</p>
<p><strong>Note:</strong> Technically, there's some nuanced behavioral difference here beyond the stylistic difference. We cover that in more detail later in the chapter, in the &quot;Implicitly: Strings &lt;--&gt; Numbers&quot; section.</p>
<p>The terms &quot;explicit&quot; and &quot;implicit,&quot; or &quot;obvious&quot; and &quot;hidden side effect,&quot; are <em>relative</em>.</p>
<p>If you know exactly what <code>a + &quot;&quot;</code> is doing and you're intentionally doing that to coerce to a <code>string</code>, you might feel the operation is sufficiently &quot;explicit.&quot; Conversely, if you've never seen the <code>String(..)</code> function used for <code>string</code> coercion, its behavior might seem hidden enough as to feel &quot;implicit&quot; to you.</p>
<p>But we're having this discussion of &quot;explicit&quot; vs. &quot;implicit&quot; based on the likely opinions of an <em>average, reasonably informed, but not expert or JS specification devotee</em> developer. To whatever extent you do or do not find yourself fitting neatly in that bucket, you will need to adjust your perspective on our observations here accordingly.</p>
<p>Just remember: it's often rare that we write our code and are the only ones who ever read it. Even if you're an expert on all the ins and outs of JS, consider how a less experienced teammate of yours will feel when they read your code. Will it be &quot;explicit&quot; or &quot;implicit&quot; to them in the same way it is for you?</p>
<h2 id="abstract-value-operations">Abstract Value Operations</h2>
<p>Before we can explore <em>explicit</em> vs <em>implicit</em> coercion, we need to learn the basic rules that govern how values <em>become</em> either a <code>string</code>, <code>number</code>, or <code>boolean</code>. The ES5 spec in section 9 defines several &quot;abstract operations&quot; (fancy spec-speak for &quot;internal-only operation&quot;) with the rules of value conversion. We will specifically pay attention to: <code>ToString</code>, <code>ToNumber</code>, and <code>ToBoolean</code>, and to a lesser extent, <code>ToPrimitive</code>.</p>
<h3 id="tostring"><code>ToString</code></h3>
<p>When any non-<code>string</code> value is coerced to a <code>string</code> representation, the conversion is handled by the <code>ToString</code> abstract operation in section 9.8 of the specification.</p>
<p>Built-in primitive values have natural stringification: <code>null</code> becomes <code>&quot;null&quot;</code>, <code>undefined</code> becomes <code>&quot;undefined&quot;</code> and <code>true</code> becomes <code>&quot;true&quot;</code>. <code>number</code>s are generally expressed in the natural way you'd expect, but as we discussed in Chapter 2, very small or very large <code>numbers</code> are represented in exponent form:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// multiplying `1.07` by `1000`, seven times over</span>
<span class="kw">var</span> a <span class="op">=</span> <span class="fl">1.07</span> <span class="op">*</span> <span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span><span class="op">;</span>

<span class="co">// seven times three digits =&gt; 21 digits</span>
<span class="va">a</span>.<span class="at">toString</span>()<span class="op">;</span> <span class="co">// &quot;1.07e21&quot;</span></code></pre></div>
<p>For regular objects, unless you specify your own, the default <code>toString()</code> (located in <code>Object.prototype.toString()</code>) will return the <em>internal <code>[[Class]]</code></em> (see Chapter 3), like for instance <code>&quot;[object Object]&quot;</code>.</p>
<p>But as shown earlier, if an object has its own <code>toString()</code> method on it, and you use that object in a <code>string</code>-like way, its <code>toString()</code> will automatically be called, and the <code>string</code> result of that call will be used instead.</p>
<p><strong>Note:</strong> The way an object is coerced to a <code>string</code> technically goes through the <code>ToPrimitive</code> abstract operation (ES5 spec, section 9.1), but those nuanced details are covered in more detail in the <code>ToNumber</code> section later in this chapter, so we will skip over them here.</p>
<p>Arrays have an overridden default <code>toString()</code> that stringifies as the (string) concatenation of all its values (each stringified themselves), with <code>&quot;,&quot;</code> in between each value:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span>

<span class="va">a</span>.<span class="at">toString</span>()<span class="op">;</span> <span class="co">// &quot;1,2,3&quot;</span></code></pre></div>
<p>Again, <code>toString()</code> can either be called explicitly, or it will automatically be called if a non-<code>string</code> is used in a <code>string</code> context.</p>
<h4 id="json-stringification">JSON Stringification</h4>
<p>Another task that seems awfully related to <code>ToString</code> is when you use the <code>JSON.stringify(..)</code> utility to serialize a value to a JSON-compatible <code>string</code> value.</p>
<p>It's important to note that this stringification is not exactly the same thing as coercion. But since it's related to the <code>ToString</code> rules above, we'll take a slight diversion to cover JSON stringification behaviors here.</p>
<p>For most simple values, JSON stringification behaves basically the same as <code>toString()</code> conversions, except that the serialization result is <em>always a <code>string</code></em>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">JSON</span>.<span class="at">stringify</span>( <span class="dv">42</span> )<span class="op">;</span>   <span class="co">// &quot;42&quot;</span>
<span class="va">JSON</span>.<span class="at">stringify</span>( <span class="st">&quot;42&quot;</span> )<span class="op">;</span> <span class="co">// &quot;&quot;42&quot;&quot; (a string with a quoted string value in it)</span>
<span class="va">JSON</span>.<span class="at">stringify</span>( <span class="kw">null</span> )<span class="op">;</span> <span class="co">// &quot;null&quot;</span>
<span class="va">JSON</span>.<span class="at">stringify</span>( <span class="kw">true</span> )<span class="op">;</span> <span class="co">// &quot;true&quot;</span></code></pre></div>
<p>Any <em>JSON-safe</em> value can be stringified by <code>JSON.stringify(..)</code>. But what is <em>JSON-safe</em>? Any value that can be represented validly in a JSON representation.</p>
<p>It may be easier to consider values that are <strong>not</strong> JSON-safe. Some examples: <code>undefined</code>s, <code>function</code>s, (ES6+) <code>symbol</code>s, and <code>object</code>s with circular references (where property references in an object structure create a never-ending cycle through each other). These are all illegal values for a standard JSON structure, mostly because they aren't portable to other languages that consume JSON values.</p>
<p>The <code>JSON.stringify(..)</code> utility will automatically omit <code>undefined</code>, <code>function</code>, and <code>symbol</code> values when it comes across them. If such a value is found in an <code>array</code>, that value is replaced by <code>null</code> (so that the array position information isn't altered). If found as a property of an <code>object</code>, that property will simply be excluded.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">JSON</span>.<span class="at">stringify</span>( <span class="kw">undefined</span> )<span class="op">;</span>                    <span class="co">// undefined</span>
<span class="va">JSON</span>.<span class="at">stringify</span>( <span class="kw">function</span>()<span class="op">{}</span> )<span class="op">;</span>                 <span class="co">// undefined</span>

<span class="va">JSON</span>.<span class="at">stringify</span>( [<span class="dv">1</span><span class="op">,</span><span class="kw">undefined</span><span class="op">,</span><span class="kw">function</span>()<span class="op">{},</span><span class="dv">4</span>] )<span class="op">;</span> <span class="co">// &quot;[1,null,null,4]&quot;</span>
<span class="va">JSON</span>.<span class="at">stringify</span>( <span class="op">{</span> <span class="dt">a</span><span class="op">:</span><span class="dv">2</span><span class="op">,</span> <span class="dt">b</span><span class="op">:</span><span class="kw">function</span>()<span class="op">{}</span> <span class="op">}</span> )<span class="op">;</span>      <span class="co">// &quot;{&quot;a&quot;:2}&quot;</span></code></pre></div>
<p>But if you try to <code>JSON.stringify(..)</code> an <code>object</code> with circular reference(s) in it, an error will be thrown.</p>
<p>JSON stringification has the special behavior that if an <code>object</code> value has a <code>toJSON()</code> method defined, this method will be called first to get a value to use for serialization.</p>
<p>If you intend to JSON stringify an object that may contain illegal JSON value(s), or if you just have values in the <code>object</code> that aren't appropriate for the serialization, you should define a <code>toJSON()</code> method for it that returns a <em>JSON-safe</em> version of the <code>object</code>.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> o <span class="op">=</span> <span class="op">{</span> <span class="op">};</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span>
    <span class="dt">b</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span>
    <span class="dt">c</span><span class="op">:</span> o<span class="op">,</span>
    <span class="dt">d</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">{}</span>
<span class="op">};</span>

<span class="co">// create a circular reference inside `a`</span>
<span class="va">o</span>.<span class="at">e</span> <span class="op">=</span> a<span class="op">;</span>

<span class="co">// would throw an error on the circular reference</span>
<span class="co">// JSON.stringify( a );</span>

<span class="co">// define a custom JSON value serialization</span>
<span class="va">a</span>.<span class="at">toJSON</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="co">// only include the `b` property for serialization</span>
    <span class="cf">return</span> <span class="op">{</span> <span class="dt">b</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">b</span> <span class="op">};</span>
<span class="op">};</span>

<span class="va">JSON</span>.<span class="at">stringify</span>( a )<span class="op">;</span> <span class="co">// &quot;{&quot;b&quot;:42}&quot;</span></code></pre></div>
<p>It's a very common misconception that <code>toJSON()</code> should return a JSON stringification representation. That's probably incorrect, unless you're wanting to actually stringify the <code>string</code> itself (usually not!). <code>toJSON()</code> should return the actual regular value (of whatever type) that's appropriate, and <code>JSON.stringify(..)</code> itself will handle the stringification.</p>
<p>In other words, <code>toJSON()</code> should be interpreted as &quot;to a JSON-safe value suitable for stringification,&quot; not &quot;to a JSON string&quot; as many developers mistakenly assume.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span>
    <span class="dt">val</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">,</span>

    <span class="co">// probably correct!</span>
    <span class="dt">toJSON</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">{</span>
        <span class="cf">return</span> <span class="kw">this</span>.<span class="va">val</span>.<span class="at">slice</span>( <span class="dv">1</span> )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> b <span class="op">=</span> <span class="op">{</span>
    <span class="dt">val</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">,</span>

    <span class="co">// probably incorrect!</span>
    <span class="dt">toJSON</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">{</span>
        <span class="cf">return</span> <span class="st">&quot;[&quot;</span> <span class="op">+</span>
            <span class="kw">this</span>.<span class="va">val</span>.<span class="at">slice</span>( <span class="dv">1</span> ).<span class="at">join</span>() <span class="op">+</span>
        <span class="st">&quot;]&quot;</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="va">JSON</span>.<span class="at">stringify</span>( a )<span class="op">;</span> <span class="co">// &quot;[2,3]&quot;</span>

<span class="va">JSON</span>.<span class="at">stringify</span>( b )<span class="op">;</span> <span class="co">// &quot;&quot;[2,3]&quot;&quot;</span></code></pre></div>
<p>In the second call, we stringified the returned <code>string</code> rather than the <code>array</code> itself, which was probably not what we wanted to do.</p>
<p>While we're talking about <code>JSON.stringify(..)</code>, let's discuss some lesser-known functionalities that can still be very useful.</p>
<p>An optional second argument can be passed to <code>JSON.stringify(..)</code> that is called <em>replacer</em>. This argument can either be an <code>array</code> or a <code>function</code>. It's used to customize the recursive serialization of an <code>object</code> by providing a filtering mechanism for which properties should and should not be included, in a similar way to how <code>toJSON()</code> can prepare a value for serialization.</p>
<p>If <em>replacer</em> is an <code>array</code>, it should be an <code>array</code> of <code>string</code>s, each of which will specify a property name that is allowed to be included in the serialization of the <code>object</code>. If a property exists that isn't in this list, it will be skipped.</p>
<p>If <em>replacer</em> is a <code>function</code>, it will be called once for the <code>object</code> itself, and then once for each property in the <code>object</code>, and each time is passed two arguments, <em>key</em> and <em>value</em>. To skip a <em>key</em> in the serialization, return <code>undefined</code>. Otherwise, return the <em>value</em> provided.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span>
    <span class="dt">b</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span>
    <span class="dt">c</span><span class="op">:</span> <span class="st">&quot;42&quot;</span><span class="op">,</span>
    <span class="dt">d</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]
<span class="op">};</span>

<span class="va">JSON</span>.<span class="at">stringify</span>( a<span class="op">,</span> [<span class="st">&quot;b&quot;</span><span class="op">,</span><span class="st">&quot;c&quot;</span>] )<span class="op">;</span> <span class="co">// &quot;{&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;}&quot;</span>

<span class="va">JSON</span>.<span class="at">stringify</span>( a<span class="op">,</span> <span class="kw">function</span>(k<span class="op">,</span>v)<span class="op">{</span>
    <span class="cf">if</span> (k <span class="op">!==</span> <span class="st">&quot;c&quot;</span>) <span class="cf">return</span> v<span class="op">;</span>
<span class="op">}</span> )<span class="op">;</span>
<span class="co">// &quot;{&quot;b&quot;:42,&quot;d&quot;:[1,2,3]}&quot;</span></code></pre></div>
<p><strong>Note:</strong> In the <code>function</code> <em>replacer</em> case, the key argument <code>k</code> is <code>undefined</code> for the first call (where the <code>a</code> object itself is being passed in). The <code>if</code> statement <strong>filters out</strong> the property named <code>&quot;c&quot;</code>. Stringification is recursive, so the <code>[1,2,3]</code> array has each of its values (<code>1</code>, <code>2</code>, and <code>3</code>) passed as <code>v</code> to <em>replacer</em>, with indexes (<code>0</code>, <code>1</code>, and <code>2</code>) as <code>k</code>.</p>
<p>A third optional argument can also be passed to <code>JSON.stringify(..)</code>, called <em>space</em>, which is used as indentation for prettier human-friendly output. <em>space</em> can be a positive integer to indicate how many space characters should be used at each indentation level. Or, <em>space</em> can be a <code>string</code>, in which case up to the first ten characters of its value will be used for each indentation level.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span>
    <span class="dt">b</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span>
    <span class="dt">c</span><span class="op">:</span> <span class="st">&quot;42&quot;</span><span class="op">,</span>
    <span class="dt">d</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]
<span class="op">};</span>

<span class="va">JSON</span>.<span class="at">stringify</span>( a<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="dv">3</span> )<span class="op">;</span>
<span class="co">// &quot;{</span>
<span class="co">//    &quot;b&quot;: 42,</span>
<span class="co">//    &quot;c&quot;: &quot;42&quot;,</span>
<span class="co">//    &quot;d&quot;: [</span>
<span class="co">//       1,</span>
<span class="co">//       2,</span>
<span class="co">//       3</span>
<span class="co">//    ]</span>
<span class="co">// }&quot;</span>

<span class="va">JSON</span>.<span class="at">stringify</span>( a<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="st">&quot;-----&quot;</span> )<span class="op">;</span>
<span class="co">// &quot;{</span>
<span class="co">// -----&quot;b&quot;: 42,</span>
<span class="co">// -----&quot;c&quot;: &quot;42&quot;,</span>
<span class="co">// -----&quot;d&quot;: [</span>
<span class="co">// ----------1,</span>
<span class="co">// ----------2,</span>
<span class="co">// ----------3</span>
<span class="co">// -----]</span>
<span class="co">// }&quot;</span></code></pre></div>
<p>Remember, <code>JSON.stringify(..)</code> is not directly a form of coercion. We covered it here, however, for two reasons that relate its behavior to <code>ToString</code> coercion:</p>
<ol type="1">
<li><code>string</code>, <code>number</code>, <code>boolean</code>, and <code>null</code> values all stringify for JSON basically the same as how they coerce to <code>string</code> values via the rules of the <code>ToString</code> abstract operation.</li>
<li>If you pass an <code>object</code> value to <code>JSON.stringify(..)</code>, and that <code>object</code> has a <code>toJSON()</code> method on it, <code>toJSON()</code> is automatically called to (sort of) &quot;coerce&quot; the value to be <em>JSON-safe</em> before stringification.</li>
</ol>
<h3 id="tonumber"><code>ToNumber</code></h3>
<p>If any non-<code>number</code> value is used in a way that requires it to be a <code>number</code>, such as a mathematical operation, the ES5 spec defines the <code>ToNumber</code> abstract operation in section 9.3.</p>
<p>For example, <code>true</code> becomes <code>1</code> and <code>false</code> becomes <code>0</code>. <code>undefined</code> becomes <code>NaN</code>, but (curiously) <code>null</code> becomes <code>0</code>.</p>
<p><code>ToNumber</code> for a <code>string</code> value essentially works for the most part like the rules/syntax for numeric literals (see Chapter 3). If it fails, the result is <code>NaN</code> (instead of a syntax error as with <code>number</code> literals). One example difference is that <code>0</code>-prefixed octal numbers are not handled as octals (just as normal base-10 decimals) in this operation, though such octals are valid as <code>number</code> literals (see Chapter 2).</p>
<p><strong>Note:</strong> The differences between <code>number</code> literal grammar and <code>ToNumber</code> on a <code>string</code> value are subtle and highly nuanced, and thus will not be covered further here. Consult section 9.3.1 of the ES5 spec for more information.</p>
<p>Objects (and arrays) will first be converted to their primitive value equivalent, and the resulting value (if a primitive but not already a <code>number</code>) is coerced to a <code>number</code> according to the <code>ToNumber</code> rules just mentioned.</p>
<p>To convert to this primitive value equivalent, the <code>ToPrimitive</code> abstract operation (ES5 spec, section 9.1) will consult the value (using the internal <code>DefaultValue</code> operation -- ES5 spec, section 8.12.8) in question to see if it has a <code>valueOf()</code> method. If <code>valueOf()</code> is available and it returns a primitive value, <em>that</em> value is used for the coercion. If not, but <code>toString()</code> is available, it will provide the value for the coercion.</p>
<p>If neither operation can provide a primitive value, a <code>TypeError</code> is thrown.</p>
<p>As of ES5, you can create such a noncoercible object -- one without <code>valueOf()</code> and <code>toString()</code> -- if it has a <code>null</code> value for its <code>[[Prototype]]</code>, typically created with <code>Object.create(null)</code>. See the <em>this &amp; Object Prototypes</em> title of this series for more information on <code>[[Prototype]]</code>s.</p>
<p><strong>Note:</strong> We cover how to coerce to <code>number</code>s later in this chapter in detail, but for this next code snippet, just assume the <code>Number(..)</code> function does so.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span>
    <span class="dt">valueOf</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">{</span>
        <span class="cf">return</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> b <span class="op">=</span> <span class="op">{</span>
    <span class="dt">toString</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">{</span>
        <span class="cf">return</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> c <span class="op">=</span> [<span class="dv">4</span><span class="op">,</span><span class="dv">2</span>]<span class="op">;</span>
<span class="va">c</span>.<span class="at">toString</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">{</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">join</span>( <span class="st">&quot;&quot;</span> )<span class="op">;</span> <span class="co">// &quot;42&quot;</span>
<span class="op">};</span>

<span class="at">Number</span>( a )<span class="op">;</span>            <span class="co">// 42</span>
<span class="at">Number</span>( b )<span class="op">;</span>            <span class="co">// 42</span>
<span class="at">Number</span>( c )<span class="op">;</span>            <span class="co">// 42</span>
<span class="at">Number</span>( <span class="st">&quot;&quot;</span> )<span class="op">;</span>           <span class="co">// 0</span>
<span class="at">Number</span>( [] )<span class="op">;</span>           <span class="co">// 0</span>
<span class="at">Number</span>( [ <span class="st">&quot;abc&quot;</span> ] )<span class="op">;</span>    <span class="co">// NaN</span></code></pre></div>
<h3 id="toboolean"><code>ToBoolean</code></h3>
<p>Next, let's have a little chat about how <code>boolean</code>s behave in JS. There's <strong>lots of confusion and misconception</strong> floating out there around this topic, so pay close attention!</p>
<p>First and foremost, JS has actual keywords <code>true</code> and <code>false</code>, and they behave exactly as you'd expect of <code>boolean</code> values. It's a common misconception that the values <code>1</code> and <code>0</code> are identical to <code>true</code>/<code>false</code>. While that may be true in other languages, in JS the <code>number</code>s are <code>number</code>s and the <code>boolean</code>s are <code>boolean</code>s. You can coerce <code>1</code> to <code>true</code> (and vice versa) or <code>0</code> to <code>false</code> (and vice versa). But they're not the same.</p>
<h4 id="falsy-values">Falsy Values</h4>
<p>But that's not the end of the story. We need to discuss how values other than the two <code>boolean</code>s behave whenever you coerce <em>to</em> their <code>boolean</code> equivalent.</p>
<p>All of JavaScript's values can be divided into two categories:</p>
<ol type="1">
<li>values that will become <code>false</code> if coerced to <code>boolean</code></li>
<li>everything else (which will obviously become <code>true</code>)</li>
</ol>
<p>I'm not just being facetious. The JS spec defines a specific, narrow list of values that will coerce to <code>false</code> when coerced to a <code>boolean</code> value.</p>
<p>How do we know what the list of values is? In the ES5 spec, section 9.2 defines a <code>ToBoolean</code> abstract operation, which says exactly what happens for all the possible values when you try to coerce them &quot;to boolean.&quot;</p>
<p>From that table, we get the following as the so-called &quot;falsy&quot; values list:</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>+0</code>, <code>-0</code>, and <code>NaN</code></li>
<li><code>&quot;&quot;</code></li>
</ul>
<p>That's it. If a value is on that list, it's a &quot;falsy&quot; value, and it will coerce to <code>false</code> if you force a <code>boolean</code> coercion on it.</p>
<p>By logical conclusion, if a value is <em>not</em> on that list, it must be on <em>another list</em>, which we call the &quot;truthy&quot; values list. But JS doesn't really define a &quot;truthy&quot; list per se. It gives some examples, such as saying explicitly that all objects are truthy, but mostly the spec just implies: <strong>anything not explicitly on the falsy list is therefore truthy.</strong></p>
<h4 id="falsy-objects">Falsy Objects</h4>
<p>Wait a minute, that section title even sounds contradictory. I literally <em>just said</em> the spec calls all objects truthy, right? There should be no such thing as a &quot;falsy object.&quot;</p>
<p>What could that possibly even mean?</p>
<p>You might be tempted to think it means an object wrapper (see Chapter 3) around a falsy value (such as <code>&quot;&quot;</code>, <code>0</code> or <code>false</code>). But don't fall into that <em>trap</em>.</p>
<p><strong>Note:</strong> That's a subtle specification joke some of you may get.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Boolean</span>( <span class="kw">false</span> )<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="kw">new</span> <span class="at">Number</span>( <span class="dv">0</span> )<span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="kw">new</span> <span class="at">String</span>( <span class="st">&quot;&quot;</span> )<span class="op">;</span></code></pre></div>
<p>We know all three values here are objects (see Chapter 3) wrapped around obviously falsy values. But do these objects behave as <code>true</code> or as <code>false</code>? That's easy to answer:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> d <span class="op">=</span> <span class="at">Boolean</span>( a <span class="op">&amp;&amp;</span> b <span class="op">&amp;&amp;</span> c )<span class="op">;</span>

d<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>So, all three behave as <code>true</code>, as that's the only way <code>d</code> could end up as <code>true</code>.</p>
<p><strong>Tip:</strong> Notice the <code>Boolean( .. )</code> wrapped around the <code>a &amp;&amp; b &amp;&amp; c</code> expression -- you might wonder why that's there. We'll come back to that later in this chapter, so make a mental note of it. For a sneak-peek (trivia-wise), try for yourself what <code>d</code> will be if you just do <code>d = a &amp;&amp; b &amp;&amp; c</code> without the <code>Boolean( .. )</code> call!</p>
<p>So, if &quot;falsy objects&quot; are <strong>not just objects wrapped around falsy values</strong>, what the heck are they?</p>
<p>The tricky part is that they can show up in your JS program, but they're not actually part of JavaScript itself.</p>
<p><strong>What!?</strong></p>
<p>There are certain cases where browsers have created their own sort of <em>exotic</em> values behavior, namely this idea of &quot;falsy objects,&quot; on top of regular JS semantics.</p>
<p>A &quot;falsy object&quot; is a value that looks and acts like a normal object (properties, etc.), but when you coerce it to a <code>boolean</code>, it coerces to a <code>false</code> value.</p>
<p><strong>Why!?</strong></p>
<p>The most well-known case is <code>document.all</code>: an array-like (object) provided to your JS program <em>by the DOM</em> (not the JS engine itself), which exposes elements in your page to your JS program. It <em>used</em> to behave like a normal object--it would act truthy. But not anymore.</p>
<p><code>document.all</code> itself was never really &quot;standard&quot; and has long since been deprecated/abandoned.</p>
<p>&quot;Can't they just remove it, then?&quot; Sorry, nice try. Wish they could. But there's far too many legacy JS code bases out there that rely on using it.</p>
<p>So, why make it act falsy? Because coercions of <code>document.all</code> to <code>boolean</code> (like in <code>if</code> statements) were almost always used as a means of detecting old, nonstandard IE.</p>
<p>IE has long since come up to standards compliance, and in many cases is pushing the web forward as much or more than any other browser. But all that old <code>if (document.all) { /* it's IE */ }</code> code is still out there, and much of it is probably never going away. All this legacy code is still assuming it's running in decade-old IE, which just leads to bad browsing experience for IE users.</p>
<p>So, we can't remove <code>document.all</code> completely, but IE doesn't want <code>if (document.all) { .. }</code> code to work anymore, so that users in modern IE get new, standards-compliant code logic.</p>
<p>&quot;What should we do?&quot; **&quot;I've got it! Let's bastardize the JS type system and pretend that <code>document.all</code> is falsy!&quot;</p>
<p>Ugh. That sucks. It's a crazy gotcha that most JS developers don't understand. But the alternative (doing nothing about the above no-win problems) sucks <em>just a little bit more</em>.</p>
<p>So... that's what we've got: crazy, nonstandard &quot;falsy objects&quot; added to JavaScript by the browsers. Yay!</p>
<h4 id="truthy-values">Truthy Values</h4>
<p>Back to the truthy list. What exactly are the truthy values? Remember: <strong>a value is truthy if it's not on the falsy list.</strong></p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;false&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;0&quot;</span><span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="st">&quot;&#39;&#39;&quot;</span><span class="op">;</span>

<span class="kw">var</span> d <span class="op">=</span> <span class="at">Boolean</span>( a <span class="op">&amp;&amp;</span> b <span class="op">&amp;&amp;</span> c )<span class="op">;</span>

d<span class="op">;</span></code></pre></div>
<p>What value do you expect <code>d</code> to have here? It's gotta be either <code>true</code> or <code>false</code>.</p>
<p>It's <code>true</code>. Why? Because despite the contents of those <code>string</code> values looking like falsy values, the <code>string</code> values themselves are all truthy, because <code>&quot;&quot;</code> is the only <code>string</code> value on the falsy list.</p>
<p>What about these?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> []<span class="op">;</span>             <span class="co">// empty array -- truthy or falsy?</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="op">{};</span>             <span class="co">// empty object -- truthy or falsy?</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="kw">function</span>()<span class="op">{};</span>   <span class="co">// empty function -- truthy or falsy?</span>

<span class="kw">var</span> d <span class="op">=</span> <span class="at">Boolean</span>( a <span class="op">&amp;&amp;</span> b <span class="op">&amp;&amp;</span> c )<span class="op">;</span>

d<span class="op">;</span></code></pre></div>
<p>Yep, you guessed it, <code>d</code> is still <code>true</code> here. Why? Same reason as before. Despite what it may seem like, <code>[]</code>, <code>{}</code>, and <code>function(){}</code> are <em>not</em> on the falsy list, and thus are truthy values.</p>
<p>In other words, the truthy list is infinitely long. It's impossible to make such a list. You can only make a finite falsy list and consult <em>it</em>.</p>
<p>Take five minutes, write the falsy list on a post-it note for your computer monitor, or memorize it if you prefer. Either way, you'll easily be able to construct a virtual truthy list whenever you need it by simply asking if it's on the falsy list or not.</p>
<p>The importance of truthy and falsy is in understanding how a value will behave if you coerce it (either explicitly or implicitly) to a <code>boolean</code> value. Now that you have those two lists in mind, we can dive into coercion examples themselves.</p>
<h2 id="explicit-coercion">Explicit Coercion</h2>
<p><em>Explicit</em> coercion refers to type conversions that are obvious and explicit. There's a wide range of type conversion usage that clearly falls under the <em>explicit</em> coercion category for most developers.</p>
<p>The goal here is to identify patterns in our code where we can make it clear and obvious that we're converting a value from one type to another, so as to not leave potholes for future developers to trip into. The more explicit we are, the more likely someone later will be able to read our code and understand without undue effort what our intent was.</p>
<p>It would be hard to find any salient disagreements with <em>explicit</em> coercion, as it most closely aligns with how the commonly accepted practice of type conversion works in statically typed languages. As such, we'll take for granted (for now) that <em>explicit</em> coercion can be agreed upon to not be evil or controversial. We'll revisit this later, though.</p>
<h3 id="explicitly-strings----numbers">Explicitly: Strings &lt;--&gt; Numbers</h3>
<p>We'll start with the simplest and perhaps most common coercion operation: coercing values between <code>string</code> and <code>number</code> representation.</p>
<p>To coerce between <code>string</code>s and <code>number</code>s, we use the built-in <code>String(..)</code> and <code>Number(..)</code> functions (which we referred to as &quot;native constructors&quot; in Chapter 3), but <strong>very importantly</strong>, we do not use the <code>new</code> keyword in front of them. As such, we're not creating object wrappers.</p>
<p>Instead, we're actually <em>explicitly coercing</em> between the two types:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="at">String</span>( a )<span class="op">;</span>

<span class="kw">var</span> c <span class="op">=</span> <span class="st">&quot;3.14&quot;</span><span class="op">;</span>
<span class="kw">var</span> d <span class="op">=</span> <span class="at">Number</span>( c )<span class="op">;</span>

b<span class="op">;</span> <span class="co">// &quot;42&quot;</span>
d<span class="op">;</span> <span class="co">// 3.14</span></code></pre></div>
<p><code>String(..)</code> coerces from any other value to a primitive <code>string</code> value, using the rules of the <code>ToString</code> operation discussed earlier. <code>Number(..)</code> coerces from any other value to a primitive <code>number</code> value, using the rules of the <code>ToNumber</code> operation discussed earlier.</p>
<p>I call this <em>explicit</em> coercion because in general, it's pretty obvious to most developers that the end result of these operations is the applicable type conversion.</p>
<p>In fact, this usage actually looks a lot like it does in some other statically typed languages.</p>
<p>For example, in C/C++, you can say either <code>(int)x</code> or <code>int(x)</code>, and both will convert the value in <code>x</code> to an integer. Both forms are valid, but many prefer the latter, which kinda looks like a function call. In JavaScript, when you say <code>Number(x)</code>, it looks awfully similar. Does it matter that it's <em>actually</em> a function call in JS? Not really.</p>
<p>Besides <code>String(..)</code> and <code>Number(..)</code>, there are other ways to &quot;explicitly&quot; convert these values between <code>string</code> and <code>number</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="va">a</span>.<span class="at">toString</span>()<span class="op">;</span>

<span class="kw">var</span> c <span class="op">=</span> <span class="st">&quot;3.14&quot;</span><span class="op">;</span>
<span class="kw">var</span> d <span class="op">=</span> <span class="op">+</span>c<span class="op">;</span>

b<span class="op">;</span> <span class="co">// &quot;42&quot;</span>
d<span class="op">;</span> <span class="co">// 3.14</span></code></pre></div>
<p>Calling <code>a.toString()</code> is ostensibly explicit (pretty clear that &quot;toString&quot; means &quot;to a string&quot;), but there's some hidden implicitness here. <code>toString()</code> cannot be called on a <em>primitive</em> value like <code>42</code>. So JS automatically &quot;boxes&quot; (see Chapter 3) <code>42</code> in an object wrapper, so that <code>toString()</code> can be called against the object. In other words, you might call it &quot;explicitly implicit.&quot;</p>
<p><code>+c</code> here is showing the <em>unary operator</em> form (operator with only one operand) of the <code>+</code> operator. Instead of performing mathematic addition (or string concatenation -- see below), the unary <code>+</code> explicitly coerces its operand (<code>c</code>) to a <code>number</code> value.</p>
<p>Is <code>+c</code> <em>explicit</em> coercion? Depends on your experience and perspective. If you know (which you do, now!) that unary <code>+</code> is explicitly intended for <code>number</code> coercion, then it's pretty explicit and obvious. However, if you've never seen it before, it can seem awfully confusing, implicit, with hidden side effects, etc.</p>
<p><strong>Note:</strong> The generally accepted perspective in the open-source JS community is that unary <code>+</code> is an accepted form of <em>explicit</em> coercion.</p>
<p>Even if you really like the <code>+c</code> form, there are definitely places where it can look awfully confusing. Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> c <span class="op">=</span> <span class="st">&quot;3.14&quot;</span><span class="op">;</span>
<span class="kw">var</span> d <span class="op">=</span> <span class="dv">5</span><span class="op">+</span> <span class="op">+</span>c<span class="op">;</span>

d<span class="op">;</span> <span class="co">// 8.14</span></code></pre></div>
<p>The unary <code>-</code> operator also coerces like <code>+</code> does, but it also flips the sign of the number. However, you cannot put two <code>--</code> next to each other to unflip the sign, as that's parsed as the decrement operator. Instead, you would need to do: <code>- -&quot;3.14&quot;</code> with a space in between, and that would result in coercion to <code>3.14</code>.</p>
<p>You can probably dream up all sorts of hideous combinations of binary operators (like <code>+</code> for addition) next to the unary form of an operator. Here's another crazy example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="dv">1</span> <span class="op">+</span> <span class="op">-</span> <span class="op">+</span> <span class="op">+</span> <span class="op">+</span> <span class="op">-</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// 2</span></code></pre></div>
<p>You should strongly consider avoiding unary <code>+</code> (or <code>-</code>) coercion when it's immediately adjacent to other operators. While the above works, it would almost universally be considered a bad idea. Even <code>d = +c</code> (or <code>d =+ c</code> for that matter!) can far too easily be confused for <code>d += c</code>, which is entirely different!</p>
<p><strong>Note:</strong> Another extremely confusing place for unary <code>+</code> to be used adjacent to another operator would be the <code>++</code> increment operator and <code>--</code> decrement operator. For example: <code>a +++b</code>, <code>a + ++b</code>, and <code>a + + +b</code>. See &quot;Expression Side-Effects&quot; in Chapter 5 for more about <code>++</code>.</p>
<p>Remember, we're trying to be explicit and <strong>reduce</strong> confusion, not make it much worse!</p>
<h4 id="date-to-number"><code>Date</code> To <code>number</code></h4>
<p>Another common usage of the unary <code>+</code> operator is to coerce a <code>Date</code> object into a <code>number</code>, because the result is the unix timestamp (milliseconds elapsed since 1 January 1970 00:00:00 UTC) representation of the date/time value:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> d <span class="op">=</span> <span class="kw">new</span> <span class="at">Date</span>( <span class="st">&quot;Mon, 18 Aug 2014 08:53:06 CDT&quot;</span> )<span class="op">;</span>

<span class="op">+</span>d<span class="op">;</span> <span class="co">// 1408369986000</span></code></pre></div>
<p>The most common usage of this idiom is to get the current <em>now</em> moment as a timestamp, such as:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> timestamp <span class="op">=</span> <span class="op">+</span><span class="kw">new</span> <span class="at">Date</span>()<span class="op">;</span></code></pre></div>
<p><strong>Note:</strong> Some developers are aware of a peculiar syntactic &quot;trick&quot; in JavaScript, which is that the <code>()</code> set on a constructor call (a function called with <code>new</code>) is <em>optional</em> if there are no arguments to pass. So you may run across the <code>var timestamp = +new Date;</code> form. However, not all developers agree that omitting the <code>()</code> improves readability, as it's an uncommon syntax exception that only applies to the <code>new fn()</code> call form and not the regular <code>fn()</code> call form.</p>
<p>But coercion is not the only way to get the timestamp out of a <code>Date</code> object. A noncoercion approach is perhaps even preferable, as it's even more explicit:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> timestamp <span class="op">=</span> <span class="kw">new</span> <span class="at">Date</span>().<span class="at">getTime</span>()<span class="op">;</span>
<span class="co">// var timestamp = (new Date()).getTime();</span>
<span class="co">// var timestamp = (new Date).getTime();</span></code></pre></div>
<p>But an <em>even more</em> preferable noncoercion option is to use the ES5 added <code>Date.now()</code> static function:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> timestamp <span class="op">=</span> <span class="va">Date</span>.<span class="at">now</span>()<span class="op">;</span></code></pre></div>
<p>And if you want to polyfill <code>Date.now()</code> into older browsers, it's pretty simple:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Date</span>.<span class="at">now</span>) <span class="op">{</span>
    <span class="va">Date</span>.<span class="at">now</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="op">+</span><span class="kw">new</span> <span class="at">Date</span>()<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p>I'd recommend skipping the coercion forms related to dates. Use <code>Date.now()</code> for current <em>now</em> timestamps, and <code>new Date( .. ).getTime()</code> for getting a timestamp of a specific <em>non-now</em> date/time that you need to specify.</p>
<h4 id="the-curious-case-of-the">The Curious Case of the <code>~</code></h4>
<p>One coercive JS operator that is often overlooked and usually very confused is the tilde <code>~</code> operator (aka &quot;bitwise NOT&quot;). Many of those who even understand what it does will often times still want to avoid it. But sticking to the spirit of our approach in this book and series, let's dig into it to find out if <code>~</code> has anything useful to give us.</p>
<p>In the &quot;32-bit (Signed) Integers&quot; section of Chapter 2, we covered how bitwise operators in JS are defined only for 32-bit operations, which means they force their operands to conform to 32-bit value representations. The rules for how this happens are controlled by the <code>ToInt32</code> abstract operation (ES5 spec, section 9.5).</p>
<p><code>ToInt32</code> first does a <code>ToNumber</code> coercion, which means if the value is <code>&quot;123&quot;</code>, it's going to first become <code>123</code> before the <code>ToInt32</code> rules are applied.</p>
<p>While not <em>technically</em> coercion itself (since the type doesn't change!), using bitwise operators (like <code>|</code> or <code>~</code>) with certain special <code>number</code> values produces a coercive effect that results in a different <code>number</code> value.</p>
<p>For example, let's first consider the <code>|</code> &quot;bitwise OR&quot; operator used in the otherwise no-op idiom <code>0 | x</code>, which (as Chapter 2 showed) essentially only does the <code>ToInt32</code> conversion:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="dv">0</span> <span class="op">|</span> <span class="op">-</span><span class="dv">0</span><span class="op">;</span>         <span class="co">// 0</span>
<span class="dv">0</span> <span class="op">|</span> <span class="kw">NaN</span><span class="op">;</span>        <span class="co">// 0</span>
<span class="dv">0</span> <span class="op">|</span> <span class="kw">Infinity</span><span class="op">;</span>   <span class="co">// 0</span>
<span class="dv">0</span> <span class="op">|</span> <span class="op">-</span><span class="kw">Infinity</span><span class="op">;</span>  <span class="co">// 0</span></code></pre></div>
<p>These special numbers aren't 32-bit representable (since they come from the 64-bit IEEE 754 standard -- see Chapter 2), so <code>ToInt32</code> just specifies <code>0</code> as the result from these values.</p>
<p>It's debatable if <code>0 | __</code> is an <em>explicit</em> form of this coercive <code>ToInt32</code> operation or if it's more <em>implicit</em>. From the spec perspective, it's unquestionably <em>explicit</em>, but if you don't understand bitwise operations at this level, it can seem a bit more <em>implicitly</em> magical. Nevertheless, consistent with other assertions in this chapter, we will call it <em>explicit</em>.</p>
<p>So, let's turn our attention back to <code>~</code>. The <code>~</code> operator first &quot;coerces&quot; to a 32-bit <code>number</code> value, and then performs a bitwise negation (flipping each bit's parity).</p>
<p><strong>Note:</strong> This is very similar to how <code>!</code> not only coerces its value to <code>boolean</code> but also flips its parity (see discussion of the &quot;unary <code>!</code>&quot; later).</p>
<p>But... what!? Why do we care about bits being flipped? That's some pretty specialized, nuanced stuff. It's pretty rare for JS developers to need to reason about individual bits.</p>
<p>Another way of thinking about the definition of <code>~</code> comes from old-school computer science/discrete Mathematics: <code>~</code> performs two's-complement. Great, thanks, that's totally clearer!</p>
<p>Let's try again: <code>~x</code> is roughly the same as <code>-(x+1)</code>. That's weird, but slightly easier to reason about. So:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">~</span><span class="dv">42</span><span class="op">;</span>    <span class="co">// -(42+1) ==&gt; -43</span></code></pre></div>
<p>You're probably still wondering what the heck all this <code>~</code> stuff is about, or why it really matters for a coercion discussion. Let's quickly get to the point.</p>
<p>Consider <code>-(x+1)</code>. What's the only value that you can perform that operation on that will produce a <code>0</code> (or <code>-0</code> technically!) result? <code>-1</code>. In other words, <code>~</code> used with a range of <code>number</code> values will produce a falsy (easily coercible to <code>false</code>) <code>0</code> value for the <code>-1</code> input value, and any other truthy <code>number</code> otherwise.</p>
<p>Why is that relevant?</p>
<p><code>-1</code> is commonly called a &quot;sentinel value,&quot; which basically means a value that's given an arbitrary semantic meaning within the greater set of values of its same type (<code>number</code>s). The C-language uses <code>-1</code> sentinel values for many functions that return <code>&gt;= 0</code> values for &quot;success&quot; and <code>-1</code> for &quot;failure.&quot;</p>
<p>JavaScript adopted this precedent when defining the <code>string</code> operation <code>indexOf(..)</code>, which searches for a substring and if found returns its zero-based index position, or <code>-1</code> if not found.</p>
<p>It's pretty common to try to use <code>indexOf(..)</code> not just as an operation to get the position, but as a <code>boolean</code> check of presence/absence of a substring in another <code>string</code>. Here's how developers usually perform such checks:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;Hello World&quot;</span><span class="op">;</span>

<span class="cf">if</span> (<span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;lo&quot;</span> ) <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="op">{</span>   <span class="co">// true</span>
    <span class="co">// found it!</span>
<span class="op">}</span>
<span class="cf">if</span> (<span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;lo&quot;</span> ) <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>) <span class="op">{</span>  <span class="co">// true</span>
    <span class="co">// found it</span>
<span class="op">}</span>

<span class="cf">if</span> (<span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;ol&quot;</span> ) <span class="op">&lt;</span> <span class="dv">0</span>) <span class="op">{</span>    <span class="co">// true</span>
    <span class="co">// not found!</span>
<span class="op">}</span>
<span class="cf">if</span> (<span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;ol&quot;</span> ) <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>) <span class="op">{</span>  <span class="co">// true</span>
    <span class="co">// not found!</span>
<span class="op">}</span></code></pre></div>
<p>I find it kind of gross to look at <code>&gt;= 0</code> or <code>== -1</code>. It's basically a &quot;leaky abstraction,&quot; in that it's leaking underlying implementation behavior -- the usage of sentinel <code>-1</code> for &quot;failure&quot; -- into my code. I would prefer to hide such a detail.</p>
<p>And now, finally, we see why <code>~</code> could help us! Using <code>~</code> with <code>indexOf()</code> &quot;coerces&quot; (actually just transforms) the value <strong>to be appropriately <code>boolean</code>-coercible</strong>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;Hello World&quot;</span><span class="op">;</span>

<span class="op">~</span><span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;lo&quot;</span> )<span class="op">;</span>         <span class="co">// -4   &lt;-- truthy!</span>

<span class="cf">if</span> (<span class="op">~</span><span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;lo&quot;</span> )) <span class="op">{</span>   <span class="co">// true</span>
    <span class="co">// found it!</span>
<span class="op">}</span>

<span class="op">~</span><span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;ol&quot;</span> )<span class="op">;</span>         <span class="co">// 0    &lt;-- falsy!</span>
<span class="op">!~</span><span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;ol&quot;</span> )<span class="op">;</span>        <span class="co">// true</span>

<span class="cf">if</span> (<span class="op">!~</span><span class="va">a</span>.<span class="at">indexOf</span>( <span class="st">&quot;ol&quot;</span> )) <span class="op">{</span>  <span class="co">// true</span>
    <span class="co">// not found!</span>
<span class="op">}</span></code></pre></div>
<p><code>~</code> takes the return value of <code>indexOf(..)</code> and transforms it: for the &quot;failure&quot; <code>-1</code> we get the falsy <code>0</code>, and every other value is truthy.</p>
<p><strong>Note:</strong> The <code>-(x+1)</code> pseudo-algorithm for <code>~</code> would imply that <code>~-1</code> is <code>-0</code>, but actually it produces <code>0</code> because the underlying operation is actually bitwise, not mathematic.</p>
<p>Technically, <code>if (~a.indexOf(..))</code> is still relying on <em>implicit</em> coercion of its resultant <code>0</code> to <code>false</code> or nonzero to <code>true</code>. But overall, <code>~</code> still feels to me more like an <em>explicit</em> coercion mechanism, as long as you know what it's intended to do in this idiom.</p>
<p>I find this to be cleaner code than the previous <code>&gt;= 0</code> / <code>== -1</code> clutter.</p>
<h5 id="truncating-bits">Truncating Bits</h5>
<p>There's one more place <code>~</code> may show up in code you run across: some developers use the double tilde <code>~~</code> to truncate the decimal part of a <code>number</code> (i.e., &quot;coerce&quot; it to a whole number &quot;integer&quot;). It's commonly (though mistakingly) said this is the same result as calling <code>Math.floor(..)</code>.</p>
<p>How <code>~~</code> works is that the first <code>~</code> applies the <code>ToInt32</code> &quot;coercion&quot; and does the bitwise flip, and then the second <code>~</code> does another bitwise flip, flipping all the bits back to the original state. The end result is just the <code>ToInt32</code> &quot;coercion&quot; (aka truncation).</p>
<p><strong>Note:</strong> The bitwise double-flip of <code>~~</code> is very similar to the parity double-negate <code>!!</code> behavior, explained in the &quot;Explicitly: * --&gt; Boolean&quot; section later.</p>
<p>However, <code>~~</code> needs some caution/clarification. First, it only works reliably on 32-bit values. But more importantly, it doesn't work the same on negative numbers as <code>Math.floor(..)</code> does!</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Math</span>.<span class="at">floor</span>( <span class="op">-</span><span class="fl">49.6</span> )<span class="op">;</span>    <span class="co">// -50</span>
<span class="op">~~-</span><span class="fl">49.6</span><span class="op">;</span>                <span class="co">// -49</span></code></pre></div>
<p>Setting the <code>Math.floor(..)</code> difference aside, <code>~~x</code> can truncate to a (32-bit) integer. But so does <code>x | 0</code>, and seemingly with (slightly) <em>less effort</em>.</p>
<p>So, why might you choose <code>~~x</code> over <code>x | 0</code>, then? Operator precedence (see Chapter 5):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">~~</span><span class="fl">1E20</span> / <span class="dv">10</span><span class="op">;</span>        <span class="co">// 166199296</span>

<span class="fl">1E20</span> <span class="op">|</span> <span class="dv">0</span> / <span class="dv">10</span><span class="op">;</span>      <span class="co">// 1661992960</span>
(<span class="fl">1E20</span> <span class="op">|</span> <span class="dv">0</span>) / <span class="dv">10</span><span class="op">;</span>    <span class="co">// 166199296</span></code></pre></div>
<p>Just as with all other advice here, use <code>~</code> and <code>~~</code> as explicit mechanisms for &quot;coercion&quot; and value transformation only if everyone who reads/writes such code is properly aware of how these operators work!</p>
<h3 id="explicitly-parsing-numeric-strings">Explicitly: Parsing Numeric Strings</h3>
<p>A similar outcome to coercing a <code>string</code> to a <code>number</code> can be achieved by parsing a <code>number</code> out of a <code>string</code>'s character contents. There are, however, distinct differences between this parsing and the type conversion we examined above.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;42px&quot;</span><span class="op">;</span>

<span class="at">Number</span>( a )<span class="op">;</span>    <span class="co">// 42</span>
<span class="at">parseInt</span>( a )<span class="op">;</span>  <span class="co">// 42</span>

<span class="at">Number</span>( b )<span class="op">;</span>    <span class="co">// NaN</span>
<span class="at">parseInt</span>( b )<span class="op">;</span>  <span class="co">// 42</span></code></pre></div>
<p>Parsing a numeric value out of a string is <em>tolerant</em> of non-numeric characters -- it just stops parsing left-to-right when encountered -- whereas coercion is <em>not tolerant</em> and fails resulting in the <code>NaN</code> value.</p>
<p>Parsing should not be seen as a substitute for coercion. These two tasks, while similar, have different purposes. Parse a <code>string</code> as a <code>number</code> when you don't know/care what other non-numeric characters there may be on the right-hand side. Coerce a <code>string</code> (to a <code>number</code>) when the only acceptable values are numeric and something like <code>&quot;42px&quot;</code> should be rejected as a <code>number</code>.</p>
<p><strong>Tip:</strong> <code>parseInt(..)</code> has a twin, <code>parseFloat(..)</code>, which (as it sounds) pulls out a floating-point number from a string.</p>
<p>Don't forget that <code>parseInt(..)</code> operates on <code>string</code> values. It makes absolutely no sense to pass a <code>number</code> value to <code>parseInt(..)</code>. Nor would it make sense to pass any other type of value, like <code>true</code>, <code>function(){..}</code> or <code>[1,2,3]</code>.</p>
<p>If you pass a non-<code>string</code>, the value you pass will automatically be coerced to a <code>string</code> first (see &quot;<code>ToString</code>&quot; earlier), which would clearly be a kind of hidden <em>implicit</em> coercion. It's a really bad idea to rely upon such a behavior in your program, so never use <code>parseInt(..)</code> with a non-<code>string</code> value.</p>
<p>Prior to ES5, another gotcha existed with <code>parseInt(..)</code>, which was the source of many JS programs' bugs. If you didn't pass a second argument to indicate which numeric base (aka radix) to use for interpreting the numeric <code>string</code> contents, <code>parseInt(..)</code> would look at the beginning character(s) to make a guess.</p>
<p>If the first two characters were <code>&quot;0x&quot;</code> or <code>&quot;0X&quot;</code>, the guess (by convention) was that you wanted to interpret the <code>string</code> as a hexadecimal (base-16) <code>number</code>. Otherwise, if the first character was <code>&quot;0&quot;</code>, the guess (again, by convention) was that you wanted to interpret the <code>string</code> as an octal (base-8) <code>number</code>.</p>
<p>Hexadecimal <code>string</code>s (with the leading <code>0x</code> or <code>0X</code>) aren't terribly easy to get mixed up. But the octal number guessing proved devilishly common. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> hour <span class="op">=</span> <span class="at">parseInt</span>( <span class="va">selectedHour</span>.<span class="at">value</span> )<span class="op">;</span>
<span class="kw">var</span> minute <span class="op">=</span> <span class="at">parseInt</span>( <span class="va">selectedMinute</span>.<span class="at">value</span> )<span class="op">;</span>

<span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;The time you selected was: &quot;</span> <span class="op">+</span> hour <span class="op">+</span> <span class="st">&quot;:&quot;</span> <span class="op">+</span> minute)<span class="op">;</span></code></pre></div>
<p>Seems harmless, right? Try selecting <code>08</code> for the hour and <code>09</code> for the minute. You'll get <code>0:0</code>. Why? because neither <code>8</code> nor <code>9</code> are valid characters in octal base-8.</p>
<p>The pre-ES5 fix was simple, but so easy to forget: <strong>always pass <code>10</code> as the second argument</strong>. This was totally safe:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> hour <span class="op">=</span> <span class="at">parseInt</span>( <span class="va">selectedHour</span>.<span class="at">value</span><span class="op">,</span> <span class="dv">10</span> )<span class="op">;</span>
<span class="kw">var</span> minute <span class="op">=</span> <span class="at">parseInt</span>( <span class="va">selectedMiniute</span>.<span class="at">value</span><span class="op">,</span> <span class="dv">10</span> )<span class="op">;</span></code></pre></div>
<p>As of ES5, <code>parseInt(..)</code> no longer guesses octal. Unless you say otherwise, it assumes base-10 (or base-16 for <code>&quot;0x&quot;</code> prefixes). That's much nicer. Just be careful if your code has to run in pre-ES5 environments, in which case you still need to pass <code>10</code> for the radix.</p>
<h4 id="parsing-non-strings">Parsing Non-Strings</h4>
<p>One somewhat infamous example of <code>parseInt(..)</code>'s behavior is highlighted in a sarcastic joke post a few years ago, poking fun at this JS behavior:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="at">parseInt</span>( <span class="dv">1</span>/<span class="dv">0</span><span class="op">,</span> <span class="dv">19</span> )<span class="op">;</span> <span class="co">// 18</span></code></pre></div>
<p>The assumptive (but totally invalid) assertion was, &quot;If I pass in Infinity, and parse an integer out of that, I should get Infinity back, not 18.&quot; Surely, JS must be crazy for this outcome, right?</p>
<p>Though this example is obviously contrived and unreal, let's indulge the madness for a moment and examine whether JS really is that crazy.</p>
<p>First off, the most obvious sin committed here is to pass a non-<code>string</code> to <code>parseInt(..)</code>. That's a no-no. Do it and you're asking for trouble. But even if you do, JS politely coerces what you pass in into a <code>string</code> that it can try to parse.</p>
<p>Some would argue that this is unreasonable behavior, and that <code>parseInt(..)</code> should refuse to operate on a non-<code>string</code> value. Should it perhaps throw an error? That would be very Java-like, frankly. I shudder at thinking JS should start throwing errors all over the place so that <code>try..catch</code> is needed around almost every line.</p>
<p>Should it return <code>NaN</code>? Maybe. But... what about:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="at">parseInt</span>( <span class="kw">new</span> <span class="at">String</span>( <span class="st">&quot;42&quot;</span>) )<span class="op">;</span></code></pre></div>
<p>Should that fail, too? It's a non-<code>string</code> value. If you want that <code>String</code> object wrapper to be unboxed to <code>&quot;42&quot;</code>, then is it really so unusual for <code>42</code> to first become <code>&quot;42&quot;</code> so that <code>42</code> can be parsed back out?</p>
<p>I would argue that this half-<em>explicit</em>, half-<em>implicit</em> coercion that can occur can often be a very helpful thing. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span>
    <span class="dt">num</span><span class="op">:</span> <span class="dv">21</span><span class="op">,</span>
    <span class="dt">toString</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span> <span class="cf">return</span> <span class="at">String</span>( <span class="kw">this</span>.<span class="at">num</span> <span class="op">*</span> <span class="dv">2</span> )<span class="op">;</span> <span class="op">}</span>
<span class="op">};</span>

<span class="at">parseInt</span>( a )<span class="op">;</span> <span class="co">// 42</span></code></pre></div>
<p>The fact that <code>parseInt(..)</code> forcibly coerces its value to a <code>string</code> to perform the parse on is quite sensible. If you pass in garbage, and you get garbage back out, don't blame the trash can -- it just did its job faithfully.</p>
<p>So, if you pass in a value like <code>Infinity</code> (the result of <code>1 / 0</code> obviously), what sort of <code>string</code> representation would make the most sense for its coercion? Only two reasonable choices come to mind: <code>&quot;Infinity&quot;</code> and <code>&quot;&quot;</code>. JS chose <code>&quot;Infinity&quot;</code>. I'm glad it did.</p>
<p>I think it's a good thing that <strong>all values</strong> in JS have some sort of default <code>string</code> representation, so that they aren't mysterious black boxes that we can't debug and reason about.</p>
<p>Now, what about base-19? Obviously, completely bogus and contrived. No real JS programs use base-19. It's absurd. But again, let's indulge the ridiculousness. In base-19, the valid numeric characters are <code>0</code> - <code>9</code> and <code>a</code> - <code>i</code> (case insensitive).</p>
<p>So, back to our <code>parseInt( 1/0, 19 )</code> example. It's essentially <code>parseInt( &quot;Infinity&quot;, 19 )</code>. How does it parse? The first character is <code>&quot;I&quot;</code>, which is value <code>18</code> in the silly base-19. The second character <code>&quot;n&quot;</code> is not in the valid set of numeric characters, and as such the parsing simply politely stops, just like when it ran across <code>&quot;p&quot;</code> in <code>&quot;42px&quot;</code>.</p>
<p>The result? <code>18</code>. Exactly like it sensibly should be. The behaviors involved to get us there, and not to an error or to <code>Infinity</code> itself, are <strong>very important</strong> to JS, and should not be so easily discarded.</p>
<p>Other examples of this behavior with <code>parseInt(..)</code> that may be surprising but are quite sensible include:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="at">parseInt</span>( <span class="fl">0.000008</span> )<span class="op">;</span>       <span class="co">// 0   (&quot;0&quot; from &quot;0.000008&quot;)</span>
<span class="at">parseInt</span>( <span class="fl">0.0000008</span> )<span class="op">;</span>      <span class="co">// 8   (&quot;8&quot; from &quot;8e-7&quot;)</span>
<span class="at">parseInt</span>( <span class="kw">false</span><span class="op">,</span> <span class="dv">16</span> )<span class="op">;</span>      <span class="co">// 250 (&quot;fa&quot; from &quot;false&quot;)</span>
<span class="at">parseInt</span>( parseInt<span class="op">,</span> <span class="dv">16</span> )<span class="op">;</span>   <span class="co">// 15  (&quot;f&quot; from &quot;function..&quot;)</span>

<span class="at">parseInt</span>( <span class="st">&quot;0x10&quot;</span> )<span class="op">;</span>         <span class="co">// 16</span>
<span class="at">parseInt</span>( <span class="st">&quot;103&quot;</span><span class="op">,</span> <span class="dv">2</span> )<span class="op">;</span>       <span class="co">// 2</span></code></pre></div>
<p><code>parseInt(..)</code> is actually pretty predictable and consistent in its behavior. If you use it correctly, you'll get sensible results. If you use it incorrectly, the crazy results you get are not the fault of JavaScript.</p>
<h3 id="explicitly----boolean">Explicitly: * --&gt; Boolean</h3>
<p>Now, let's examine coercing from any non-<code>boolean</code> value to a <code>boolean</code>.</p>
<p>Just like with <code>String(..)</code> and <code>Number(..)</code> above, <code>Boolean(..)</code> (without the <code>new</code>, of course!) is an explicit way of forcing the <code>ToBoolean</code> coercion:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;0&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> []<span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="op">{};</span>

<span class="kw">var</span> d <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span>
<span class="kw">var</span> e <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
<span class="kw">var</span> f <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>
<span class="kw">var</span> g<span class="op">;</span>

<span class="at">Boolean</span>( a )<span class="op">;</span> <span class="co">// true</span>
<span class="at">Boolean</span>( b )<span class="op">;</span> <span class="co">// true</span>
<span class="at">Boolean</span>( c )<span class="op">;</span> <span class="co">// true</span>

<span class="at">Boolean</span>( d )<span class="op">;</span> <span class="co">// false</span>
<span class="at">Boolean</span>( e )<span class="op">;</span> <span class="co">// false</span>
<span class="at">Boolean</span>( f )<span class="op">;</span> <span class="co">// false</span>
<span class="at">Boolean</span>( g )<span class="op">;</span> <span class="co">// false</span></code></pre></div>
<p>While <code>Boolean(..)</code> is clearly explicit, it's not at all common or idiomatic.</p>
<p>Just like the unary <code>+</code> operator coerces a value to a <code>number</code> (see above), the unary <code>!</code> negate operator explicitly coerces a value to a <code>boolean</code>. The <em>problem</em> is that it also flips the value from truthy to falsy or vice versa. So, the most common way JS developers explicitly coerce to <code>boolean</code> is to use the <code>!!</code> double-negate operator, because the second <code>!</code> will flip the parity back to the original:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;0&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> []<span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="op">{};</span>

<span class="kw">var</span> d <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span>
<span class="kw">var</span> e <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
<span class="kw">var</span> f <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>
<span class="kw">var</span> g<span class="op">;</span>

<span class="op">!!</span>a<span class="op">;</span>    <span class="co">// true</span>
<span class="op">!!</span>b<span class="op">;</span>    <span class="co">// true</span>
<span class="op">!!</span>c<span class="op">;</span>    <span class="co">// true</span>

<span class="op">!!</span>d<span class="op">;</span>    <span class="co">// false</span>
<span class="op">!!</span>e<span class="op">;</span>    <span class="co">// false</span>
<span class="op">!!</span>f<span class="op">;</span>    <span class="co">// false</span>
<span class="op">!!</span>g<span class="op">;</span>    <span class="co">// false</span></code></pre></div>
<p>Any of these <code>ToBoolean</code> coercions would happen <em>implicitly</em> without the <code>Boolean(..)</code> or <code>!!</code>, if used in a <code>boolean</code> context such as an <code>if (..) ..</code> statement. But the goal here is to explicitly force the value to a <code>boolean</code> to make it clearer that the <code>ToBoolean</code> coercion is intended.</p>
<p>Another example use-case for explicit <code>ToBoolean</code> coercion is if you want to force a <code>true</code>/<code>false</code> value coercion in the JSON serialization of a data structure:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [
    <span class="dv">1</span><span class="op">,</span>
    <span class="kw">function</span>()<span class="op">{</span> <span class="co">/*..*/</span> <span class="op">},</span>
    <span class="dv">2</span><span class="op">,</span>
    <span class="kw">function</span>()<span class="op">{</span> <span class="co">/*..*/</span> <span class="op">}</span>
]<span class="op">;</span>

<span class="va">JSON</span>.<span class="at">stringify</span>( a )<span class="op">;</span> <span class="co">// &quot;[1,null,2,null]&quot;</span>

<span class="va">JSON</span>.<span class="at">stringify</span>( a<span class="op">,</span> <span class="kw">function</span>(key<span class="op">,</span>val)<span class="op">{</span>
    <span class="cf">if</span> (<span class="kw">typeof</span> val <span class="op">==</span> <span class="st">&quot;function&quot;</span>) <span class="op">{</span>
        <span class="co">// force `ToBoolean` coercion of the function</span>
        <span class="cf">return</span> <span class="op">!!</span>val<span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">else</span> <span class="op">{</span>
        <span class="cf">return</span> val<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span> )<span class="op">;</span>
<span class="co">// &quot;[1,true,2,true]&quot;</span></code></pre></div>
<p>If you come to JavaScript from Java, you may recognize this idiom:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>

<span class="kw">var</span> b <span class="op">=</span> a <span class="op">?</span> <span class="kw">true</span> : <span class="kw">false</span><span class="op">;</span></code></pre></div>
<p>The <code>? :</code> ternary operator will test <code>a</code> for truthiness, and based on that test will either assign <code>true</code> or <code>false</code> to <code>b</code>, accordingly.</p>
<p>On its surface, this idiom looks like a form of <em>explicit</em> <code>ToBoolean</code>-type coercion, since it's obvious that only either <code>true</code> or <code>false</code> come out of the operation.</p>
<p>However, there's a hidden <em>implicit</em> coercion, in that the <code>a</code> expression has to first be coerced to <code>boolean</code> to perform the truthiness test. I'd call this idiom &quot;explicitly implicit.&quot; Furthermore, I'd suggest <strong>you should avoid this idiom completely</strong> in JavaScript. It offers no real benefit, and worse, masquerades as something it's not.</p>
<p><code>Boolean(a)</code> and <code>!!a</code> are far better as <em>explicit</em> coercion options.</p>
<h2 id="implicit-coercion">Implicit Coercion</h2>
<p><em>Implicit</em> coercion refers to type conversions that are hidden, with non-obvious side-effects that implicitly occur from other actions. In other words, <em>implicit coercions</em> are any type conversions that aren't obvious (to you).</p>
<p>While it's clear what the goal of <em>explicit</em> coercion is (making code explicit and more understandable), it might be <em>too</em> obvious that <em>implicit</em> coercion has the opposite goal: making code harder to understand.</p>
<p>Taken at face value, I believe that's where much of the ire towards coercion comes from. The majority of complaints about &quot;JavaScript coercion&quot; are actually aimed (whether they realize it or not) at <em>implicit</em> coercion.</p>
<p><strong>Note:</strong> Douglas Crockford, author of <em>&quot;JavaScript: The Good Parts&quot;</em>, has claimed in many conference talks and writings that JavaScript coercion should be avoided. But what he seems to mean is that <em>implicit</em> coercion is bad (in his opinion). However, if you read his own code, you'll find plenty of examples of coercion, both <em>implicit</em> and <em>explicit</em>! In truth, his angst seems to primarily be directed at the <code>==</code> operation, but as you'll see in this chapter, that's only part of the coercion mechanism.</p>
<p>So, <strong>is implicit coercion</strong> evil? Is it dangerous? Is it a flaw in JavaScript's design? Should we avoid it at all costs?</p>
<p>I bet most of you readers are inclined to enthusiastically cheer, &quot;Yes!&quot;</p>
<p><strong>Not so fast.</strong> Hear me out.</p>
<p>Let's take a different perspective on what <em>implicit</em> coercion is, and can be, than just that it's &quot;the opposite of the good explicit kind of coercion.&quot; That's far too narrow and misses an important nuance.</p>
<p>Let's define the goal of <em>implicit</em> coercion as: to reduce verbosity, boilerplate, and/or unnecessary implementation detail that clutters up our code with noise that distracts from the more important intent.</p>
<h3 id="simplifying-implicitly">Simplifying Implicitly</h3>
<p>Before we even get to JavaScript, let me suggest something pseudo-code'ish from some theoretical strongly typed language to illustrate:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">SomeType x <span class="op">=</span> <span class="at">SomeType</span>( <span class="at">AnotherType</span>( y ) )</code></pre></div>
<p>In this example, I have some arbitrary type of value in <code>y</code> that I want to convert to the <code>SomeType</code> type. The problem is, this language can't go directly from whatever <code>y</code> currently is to <code>SomeType</code>. It needs an intermediate step, where it first converts to <code>AnotherType</code>, and then from <code>AnotherType</code> to <code>SomeType</code>.</p>
<p>Now, what if that language (or definition you could create yourself with the language) <em>did</em> just let you say:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">SomeType x <span class="op">=</span> <span class="at">SomeType</span>( y )</code></pre></div>
<p>Wouldn't you generally agree that we simplified the type conversion here to reduce the unnecessary &quot;noise&quot; of the intermediate conversion step? I mean, is it <em>really</em> all that important, right here at this point in the code, to see and deal with the fact that <code>y</code> goes to <code>AnotherType</code> first before then going to <code>SomeType</code>?</p>
<p>Some would argue, at least in some circumstances, yes. But I think an equal argument can be made of many other circumstances that here, the simplification <strong>actually aids in the readability of the code</strong> by abstracting or hiding away such details, either in the language itself or in our own abstractions.</p>
<p>Undoubtedly, behind the scenes, somewhere, the intermediate conversion step is still happening. But if that detail is hidden from view here, we can just reason about getting <code>y</code> to type <code>SomeType</code> as a generic operation and hide the messy details.</p>
<p>While not a perfect analogy, what I'm going to argue throughout the rest of this chapter is that JS <em>implicit</em> coercion can be thought of as providing a similar aid to your code.</p>
<p>But, <strong>and this is very important</strong>, that is not an unbounded, absolute statement. There are definitely plenty of <em>evils</em> lurking around <em>implicit</em> coercion, that will harm your code much more than any potential readability improvements. Clearly, we have to learn how to avoid such constructs so we don't poison our code with all manner of bugs.</p>
<p>Many developers believe that if a mechanism can do some useful thing <strong>A</strong> but can also be abused or misused to do some awful thing <strong>Z</strong>, then we should throw out that mechanism altogether, just to be safe.</p>
<p>My encouragement to you is: don't settle for that. Don't &quot;throw the baby out with the bathwater.&quot; Don't assume <em>implicit</em> coercion is all bad because all you think you've ever seen is its &quot;bad parts.&quot; I think there are &quot;good parts&quot; here, and I want to help and inspire more of you to find and embrace them!</p>
<h3 id="implicitly-strings----numbers">Implicitly: Strings &lt;--&gt; Numbers</h3>
<p>Earlier in this chapter, we explored <em>explicitly</em> coercing between <code>string</code> and <code>number</code> values. Now, let's explore the same task but with <em>implicit</em> coercion approaches. But before we do, we have to examine some nuances of operations that will <em>implicitly</em> force coercion.</p>
<p>The <code>+</code> operator is overloaded to serve the purposes of both <code>number</code> addition and <code>string</code> concatenation. So how does JS know which type of operation you want to use? Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;0&quot;</span><span class="op">;</span>

<span class="kw">var</span> c <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> d <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>

a <span class="op">+</span> b<span class="op">;</span> <span class="co">// &quot;420&quot;</span>
c <span class="op">+</span> d<span class="op">;</span> <span class="co">// 42</span></code></pre></div>
<p>What's different that causes <code>&quot;420&quot;</code> vs <code>42</code>? It's a common misconception that the difference is whether one or both of the operands is a <code>string</code>, as that means <code>+</code> will assume <code>string</code> concatenation. While that's partially true, it's more complicated than that.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span>]<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> [<span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]<span class="op">;</span>

a <span class="op">+</span> b<span class="op">;</span> <span class="co">// &quot;1,23,4&quot;</span></code></pre></div>
<p>Neither of these operands is a <code>string</code>, but clearly they were both coerced to <code>string</code>s and then the <code>string</code> concatenation kicked in. So what's really going on?</p>
<p>(<strong>Warning:</strong> deeply nitty gritty spec-speak coming, so skip the next two paragraphs if that intimidates you!)</p>
<hr />
<p>According to ES5 spec section 11.6.1, the <code>+</code> algorithm (when an <code>object</code> value is an operand) will concatenate if either operand is either already a <code>string</code>, or if the following steps produce a <code>string</code> representation. So, when <code>+</code> receives an <code>object</code> (including <code>array</code>) for either operand, it first calls the <code>ToPrimitive</code> abstract operation (section 9.1) on the value, which then calls the <code>[[DefaultValue]]</code> algorithm (section 8.12.8) with a context hint of <code>number</code>.</p>
<p>If you're paying close attention, you'll notice that this operation is now identical to how the <code>ToNumber</code> abstract operation handles <code>object</code>s (see the &quot;<code>ToNumber</code>&quot;&quot; section earlier). The <code>valueOf()</code> operation on the <code>array</code> will fail to produce a simple primitive, so it then falls to a <code>toString()</code> representation. The two <code>array</code>s thus become <code>&quot;1,2&quot;</code> and <code>&quot;3,4&quot;</code>, respectively. Now, <code>+</code> concatenates the two <code>string</code>s as you'd normally expect: <code>&quot;1,23,4&quot;</code>.</p>
<hr />
<p>Let's set aside those messy details and go back to an earlier, simplified explanation: if either operand to <code>+</code> is a <code>string</code> (or becomes one with the above steps!), the operation will be <code>string</code> concatenation. Otherwise, it's always numeric addition.</p>
<p><strong>Note:</strong> A commonly cited coercion gotcha is <code>[] + {}</code> vs. <code>{} + []</code>, as those two expressions result, respectively, in <code>&quot;[object Object]&quot;</code> and <code>0</code>. There's more to it, though, and we cover those details in &quot;Blocks&quot; in Chapter 5.</p>
<p>What's that mean for <em>implicit</em> coercion?</p>
<p>You can coerce a <code>number</code> to a <code>string</code> simply by &quot;adding&quot; the <code>number</code> and the <code>&quot;&quot;</code> empty <code>string</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> a <span class="op">+</span> <span class="st">&quot;&quot;</span><span class="op">;</span>

b<span class="op">;</span> <span class="co">// &quot;42&quot;</span></code></pre></div>
<p><strong>Tip:</strong> Numeric addition with the <code>+</code> operator is commutative, which means <code>2 + 3</code> is the same as <code>3 + 2</code>. String concatenation with <code>+</code> is obviously not generally commutative, <strong>but</strong> with the specific case of <code>&quot;&quot;</code>, it's effectively commutative, as <code>a + &quot;&quot;</code> and <code>&quot;&quot; + a</code> will produce the same result.</p>
<p>It's extremely common/idiomatic to (<em>implicitly</em>) coerce <code>number</code> to <code>string</code> with a <code>+ &quot;&quot;</code> operation. In fact, interestingly, even some of the most vocal critics of <em>implicit</em> coercion still use that approach in their own code, instead of one of its <em>explicit</em> alternatives.</p>
<p><strong>I think this is a great example</strong> of a useful form in <em>implicit</em> coercion, despite how frequently the mechanism gets criticized!</p>
<p>Comparing this <em>implicit</em> coercion of <code>a + &quot;&quot;</code> to our earlier example of <code>String(a)</code> <em>explicit</em> coercion, there's one additional quirk to be aware of. Because of how the <code>ToPrimitive</code> abstract operation works, <code>a + &quot;&quot;</code> invokes <code>valueOf()</code> on the <code>a</code> value, whose return value is then finally converted to a <code>string</code> via the internal <code>ToString</code> abstract operation. But <code>String(a)</code> just invokes <code>toString()</code> directly.</p>
<p>Both approaches ultimately result in a <code>string</code>, but if you're using an <code>object</code> instead of a regular primitive <code>number</code> value, you may not necessarily get the <em>same</em> <code>string</code> value!</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span>
    <span class="dt">valueOf</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span> <span class="cf">return</span> <span class="dv">42</span><span class="op">;</span> <span class="op">},</span>
    <span class="dt">toString</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span> <span class="cf">return</span> <span class="dv">4</span><span class="op">;</span> <span class="op">}</span>
<span class="op">};</span>

a <span class="op">+</span> <span class="st">&quot;&quot;</span><span class="op">;</span>         <span class="co">// &quot;42&quot;</span>

<span class="at">String</span>( a )<span class="op">;</span>    <span class="co">// &quot;4&quot;</span></code></pre></div>
<p>Generally, this sort of gotcha won't bite you unless you're really trying to create confusing data structures and operations, but you should be careful if you're defining both your own <code>valueOf()</code> and <code>toString()</code> methods for some <code>object</code>, as how you coerce the value could affect the outcome.</p>
<p>What about the other direction? How can we <em>implicitly coerce</em> from <code>string</code> to <code>number</code>?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;3.14&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> a <span class="op">-</span> <span class="dv">0</span><span class="op">;</span>

b<span class="op">;</span> <span class="co">// 3.14</span></code></pre></div>
<p>The <code>-</code> operator is defined only for numeric subtraction, so <code>a - 0</code> forces <code>a</code>'s value to be coerced to a <code>number</code>. While far less common, <code>a * 1</code> or <code>a / 1</code> would accomplish the same result, as those operators are also only defined for numeric operations.</p>
<p>What about <code>object</code> values with the <code>-</code> operator? Similar story as for <code>+</code> above:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [<span class="dv">3</span>]<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> [<span class="dv">1</span>]<span class="op">;</span>

a <span class="op">-</span> b<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p>Both <code>array</code> values have to become <code>number</code>s, but they end up first being coerced to <code>strings</code> (using the expected <code>toString()</code> serialization), and then are coerced to <code>number</code>s, for the <code>-</code> subtraction to perform on.</p>
<p>So, is <em>implicit</em> coercion of <code>string</code> and <code>number</code> values the ugly evil you've always heard horror stories about? I don't personally think so.</p>
<p>Compare <code>b = String(a)</code> (<em>explicit</em>) to <code>b = a + &quot;&quot;</code> (<em>implicit</em>). I think cases can be made for both approaches being useful in your code. Certainly <code>b = a + &quot;&quot;</code> is quite a bit more common in JS programs, proving its own utility regardless of <em>feelings</em> about the merits or hazards of <em>implicit</em> coercion in general.</p>
<h3 id="implicitly-booleans----numbers">Implicitly: Booleans --&gt; Numbers</h3>
<p>I think a case where <em>implicit</em> coercion can really shine is in simplifying certain types of complicated <code>boolean</code> logic into simple numeric addition. Of course, this is not a general-purpose technique, but a specific solution for specific cases.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">onlyOne</span>(a<span class="op">,</span>b<span class="op">,</span>c) <span class="op">{</span>
    <span class="cf">return</span> <span class="op">!!</span>((a <span class="op">&amp;&amp;</span> <span class="op">!</span>b <span class="op">&amp;&amp;</span> <span class="op">!</span>c) <span class="op">||</span>
        (<span class="op">!</span>a <span class="op">&amp;&amp;</span> b <span class="op">&amp;&amp;</span> <span class="op">!</span>c) <span class="op">||</span> (<span class="op">!</span>a <span class="op">&amp;&amp;</span> <span class="op">!</span>b <span class="op">&amp;&amp;</span> c))<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>

<span class="at">onlyOne</span>( a<span class="op">,</span> b<span class="op">,</span> b )<span class="op">;</span> <span class="co">// true</span>
<span class="at">onlyOne</span>( b<span class="op">,</span> a<span class="op">,</span> b )<span class="op">;</span> <span class="co">// true</span>

<span class="at">onlyOne</span>( a<span class="op">,</span> b<span class="op">,</span> a )<span class="op">;</span> <span class="co">// false</span></code></pre></div>
<p>This <code>onlyOne(..)</code> utility should only return <code>true</code> if exactly one of the arguments is <code>true</code> / truthy. It's using <em>implicit</em> coercion on the truthy checks and <em>explicit</em> coercion on the others, including the final return value.</p>
<p>But what if we needed that utility to be able to handle four, five, or twenty flags in the same way? It's pretty difficult to imagine implementing code that would handle all those permutations of comparisons.</p>
<p>But here's where coercing the <code>boolean</code> values to <code>number</code>s (<code>0</code> or <code>1</code>, obviously) can greatly help:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">onlyOne</span>() <span class="op">{</span>
    <span class="kw">var</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
    <span class="cf">for</span> (<span class="kw">var</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">arguments</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
        <span class="co">// skip falsy values. same as treating</span>
        <span class="co">// them as 0&#39;s, but avoids NaN&#39;s.</span>
        <span class="cf">if</span> (arguments[i]) <span class="op">{</span>
            sum <span class="op">+=</span> arguments[i]<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>
    <span class="cf">return</span> sum <span class="op">==</span> <span class="dv">1</span><span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>

<span class="at">onlyOne</span>( b<span class="op">,</span> a )<span class="op">;</span>        <span class="co">// true</span>
<span class="at">onlyOne</span>( b<span class="op">,</span> a<span class="op">,</span> b<span class="op">,</span> b<span class="op">,</span> b )<span class="op">;</span>   <span class="co">// true</span>

<span class="at">onlyOne</span>( b<span class="op">,</span> b )<span class="op">;</span>        <span class="co">// false</span>
<span class="at">onlyOne</span>( b<span class="op">,</span> a<span class="op">,</span> b<span class="op">,</span> b<span class="op">,</span> b<span class="op">,</span> a )<span class="op">;</span>    <span class="co">// false</span></code></pre></div>
<p><strong>Note:</strong> Of course, instead of the <code>for</code> loop in <code>onlyOne(..)</code>, you could more tersely use the ES5 <code>reduce(..)</code> utility, but I didn't want to obscure the concepts.</p>
<p>What we're doing here is relying on the <code>1</code> for <code>true</code>/truthy coercions, and numerically adding them all up. <code>sum += arguments[i]</code> uses <em>implicit</em> coercion to make that happen. If one and only one value in the <code>arguments</code> list is <code>true</code>, then the numeric sum will be <code>1</code>, otherwise the sum will not be <code>1</code> and thus the desired condition is not met.</p>
<p>We could of course do this with <em>explicit</em> coercion instead:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">onlyOne</span>() <span class="op">{</span>
    <span class="kw">var</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
    <span class="cf">for</span> (<span class="kw">var</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">arguments</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
        sum <span class="op">+=</span> <span class="at">Number</span>( <span class="op">!!</span>arguments[i] )<span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">return</span> sum <span class="op">===</span> <span class="dv">1</span><span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>We first use <code>!!arguments[i]</code> to force the coercion of the value to <code>true</code> or <code>false</code>. That's so you could pass non-<code>boolean</code> values in, like <code>onlyOne( &quot;42&quot;, 0 )</code>, and it would still work as expected (otherwise you'd end up with <code>string</code> concatenation and the logic would be incorrect).</p>
<p>Once we're sure it's a <code>boolean</code>, we do another <em>explicit</em> coercion with <code>Number(..)</code> to make sure the value is <code>0</code> or <code>1</code>.</p>
<p>Is the <em>explicit</em> coercion form of this utility &quot;better&quot;? It does avoid the <code>NaN</code> trap as explained in the code comments. But, ultimately, it depends on your needs. I personally think the former version, relying on <em>implicit</em> coercion is more elegant (if you won't be passing <code>undefined</code> or <code>NaN</code>), and the <em>explicit</em> version is needlessly more verbose.</p>
<p>But as with almost everything we're discussing here, it's a judgment call.</p>
<p><strong>Note:</strong> Regardless of <em>implicit</em> or <em>explicit</em> approaches, you could easily make <code>onlyTwo(..)</code> or <code>onlyFive(..)</code> variations by simply changing the final comparison from <code>1</code>, to <code>2</code> or <code>5</code>, respectively. That's drastically easier than adding a bunch of <code>&amp;&amp;</code> and <code>||</code> expressions. So, generally, coercion is very helpful in this case.</p>
<h3 id="implicitly----boolean">Implicitly: * --&gt; Boolean</h3>
<p>Now, let's turn our attention to <em>implicit</em> coercion to <code>boolean</code> values, as it's by far the most common and also by far the most potentially troublesome.</p>
<p>Remember, <em>implicit</em> coercion is what kicks in when you use a value in such a way that it forces the value to be converted. For numeric and <code>string</code> operations, it's fairly easy to see how the coercions can occur.</p>
<p>But, what sort of expression operations require/force (<em>implicitly</em>) a <code>boolean</code> coercion?</p>
<ol type="1">
<li>The test expression in an <code>if (..)</code> statement.</li>
<li>The test expression (second clause) in a <code>for ( .. ; .. ; .. )</code> header.</li>
<li>The test expression in <code>while (..)</code> and <code>do..while(..)</code> loops.</li>
<li>The test expression (first clause) in <code>? :</code> ternary expressions.</li>
<li>The left-hand operand (which serves as a test expression -- see below!) to the <code>||</code> (&quot;logical or&quot;) and <code>&amp;&amp;</code> (&quot;logical and&quot;) operators.</li>
</ol>
<p>Any value used in these contexts that is not already a <code>boolean</code> will be <em>implicitly</em> coerced to a <code>boolean</code> using the rules of the <code>ToBoolean</code> abstract operation covered earlier in this chapter.</p>
<p>Let's look at some examples:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span>
<span class="kw">var</span> c<span class="op">;</span>
<span class="kw">var</span> d <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>

<span class="cf">if</span> (a) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;yep&quot;</span> )<span class="op">;</span>       <span class="co">// yep</span>
<span class="op">}</span>

<span class="cf">while</span> (c) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;nope, never runs&quot;</span> )<span class="op">;</span>
<span class="op">}</span>

c <span class="op">=</span> d <span class="op">?</span> a : b<span class="op">;</span>
c<span class="op">;</span>                  <span class="co">// &quot;abc&quot;</span>

<span class="cf">if</span> ((a <span class="op">&amp;&amp;</span> d) <span class="op">||</span> c) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;yep&quot;</span> )<span class="op">;</span>       <span class="co">// yep</span>
<span class="op">}</span></code></pre></div>
<p>In all these contexts, the non-<code>boolean</code> values are <em>implicitly coerced</em> to their <code>boolean</code> equivalents to make the test decisions.</p>
<h3 id="operators-and">Operators <code>||</code> and <code>&amp;&amp;</code></h3>
<p>It's quite likely that you have seen the <code>||</code> (&quot;logical or&quot;) and <code>&amp;&amp;</code> (&quot;logical and&quot;) operators in most or all other languages you've used. So it'd be natural to assume that they work basically the same in JavaScript as in other similar languages.</p>
<p>There's some very little known, but very important, nuance here.</p>
<p>In fact, I would argue these operators shouldn't even be called &quot;logical ___ operators&quot;, as that name is incomplete in describing what they do. If I were to give them a more accurate (if more clumsy) name, I'd call them &quot;selector operators,&quot; or more completely, &quot;operand selector operators.&quot;</p>
<p>Why? Because they don't actually result in a <em>logic</em> value (aka <code>boolean</code>) in JavaScript, as they do in some other languages.</p>
<p>So what <em>do</em> they result in? They result in the value of one (and only one) of their two operands. In other words, <strong>they select one of the two operand's values</strong>.</p>
<p>Quoting the ES5 spec from section 11.11:</p>
<blockquote>
<p>The value produced by a &amp;&amp; or || operator is not necessarily of type Boolean. The value produced will always be the value of one of the two operand expressions.</p>
</blockquote>
<p>Let's illustrate:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>

a <span class="op">||</span> b<span class="op">;</span>     <span class="co">// 42</span>
a <span class="op">&amp;&amp;</span> b<span class="op">;</span>     <span class="co">// &quot;abc&quot;</span>

c <span class="op">||</span> b<span class="op">;</span>     <span class="co">// &quot;abc&quot;</span>
c <span class="op">&amp;&amp;</span> b<span class="op">;</span>     <span class="co">// null</span></code></pre></div>
<p><strong>Wait, what!?</strong> Think about that. In languages like C and PHP, those expressions result in <code>true</code> or <code>false</code>, but in JS (and Python and Ruby, for that matter!), the result comes from the values themselves.</p>
<p>Both <code>||</code> and <code>&amp;&amp;</code> operators perform a <code>boolean</code> test on the <strong>first operand</strong> (<code>a</code> or <code>c</code>). If the operand is not already <code>boolean</code> (as it's not, here), a normal <code>ToBoolean</code> coercion occurs, so that the test can be performed.</p>
<p>For the <code>||</code> operator, if the test is <code>true</code>, the <code>||</code> expression results in the value of the <em>first operand</em> (<code>a</code> or <code>c</code>). If the test is <code>false</code>, the <code>||</code> expression results in the value of the <em>second operand</em> (<code>b</code>).</p>
<p>Inversely, for the <code>&amp;&amp;</code> operator, if the test is <code>true</code>, the <code>&amp;&amp;</code> expression results in the value of the <em>second operand</em> (<code>b</code>). If the test is <code>false</code>, the <code>&amp;&amp;</code> expression results in the value of the <em>first operand</em> (<code>a</code> or <code>c</code>).</p>
<p>The result of a <code>||</code> or <code>&amp;&amp;</code> expression is always the underlying value of one of the operands, <strong>not</strong> the (possibly coerced) result of the test. In <code>c &amp;&amp; b</code>, <code>c</code> is <code>null</code>, and thus falsy. But the <code>&amp;&amp;</code> expression itself results in <code>null</code> (the value in <code>c</code>), not in the coerced <code>false</code> used in the test.</p>
<p>Do you see how these operators act as &quot;operand selectors&quot;, now?</p>
<p>Another way of thinking about these operators:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">a <span class="op">||</span> b<span class="op">;</span>
<span class="co">// roughly equivalent to:</span>
a <span class="op">?</span> a : b<span class="op">;</span>

a <span class="op">&amp;&amp;</span> b<span class="op">;</span>
<span class="co">// roughly equivalent to:</span>
a <span class="op">?</span> b : a<span class="op">;</span></code></pre></div>
<p><strong>Note:</strong> I call <code>a || b</code> &quot;roughly equivalent&quot; to <code>a ? a : b</code> because the outcome is identical, but there's a nuanced difference. In <code>a ? a : b</code>, if <code>a</code> was a more complex expression (like for instance one that might have side effects like calling a <code>function</code>, etc.), then the <code>a</code> expression would possibly be evaluated twice (if the first evaluation was truthy). By contrast, for <code>a || b</code>, the <code>a</code> expression is evaluated only once, and that value is used both for the coercive test as well as the result value (if appropriate). The same nuance applies to the <code>a &amp;&amp; b</code> and <code>a ? b : a</code> expressions.</p>
<p>An extremely common and helpful usage of this behavior, which there's a good chance you may have used before and not fully understood, is:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a<span class="op">,</span>b) <span class="op">{</span>
    a <span class="op">=</span> a <span class="op">||</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span>
    b <span class="op">=</span> b <span class="op">||</span> <span class="st">&quot;world&quot;</span><span class="op">;</span>

    <span class="va">console</span>.<span class="at">log</span>( a <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> b )<span class="op">;</span>
<span class="op">}</span>

<span class="at">foo</span>()<span class="op">;</span>                  <span class="co">// &quot;hello world&quot;</span>
<span class="at">foo</span>( <span class="st">&quot;yeah&quot;</span><span class="op">,</span> <span class="st">&quot;yeah!&quot;</span> )<span class="op">;</span> <span class="co">// &quot;yeah yeah!&quot;</span></code></pre></div>
<p>The <code>a = a || &quot;hello&quot;</code> idiom (sometimes said to be JavaScript's version of the C# &quot;null coalescing operator&quot;) acts to test <code>a</code> and if it has no value (or only an undesired falsy value), provides a backup default value (<code>&quot;hello&quot;</code>).</p>
<p><strong>Be careful</strong>, though!</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="at">foo</span>( <span class="st">&quot;That&#39;s it!&quot;</span><span class="op">,</span> <span class="st">&quot;&quot;</span> )<span class="op">;</span> <span class="co">// &quot;That&#39;s it! world&quot; &lt;-- Oops!</span></code></pre></div>
<p>See the problem? <code>&quot;&quot;</code> as the second argument is a falsy value (see <code>ToBoolean</code> earlier in this chapter), so the <code>b = b || &quot;world&quot;</code> test fails, and the <code>&quot;world&quot;</code> default value is substituted, even though the intent probably was to have the explicitly passed <code>&quot;&quot;</code> be the value assigned to <code>b</code>.</p>
<p>This <code>||</code> idiom is extremely common, and quite helpful, but you have to use it only in cases where <em>all falsy values</em> should be skipped. Otherwise, you'll need to be more explicit in your test, and probably use a <code>? :</code> ternary instead.</p>
<p>This <em>default value assignment</em> idiom is so common (and useful!) that even those who publicly and vehemently decry JavaScript coercion often use it in their own code!</p>
<p>What about <code>&amp;&amp;</code>?</p>
<p>There's another idiom that is quite a bit less commonly authored manually, but which is used by JS minifiers frequently. The <code>&amp;&amp;</code> operator &quot;selects&quot; the second operand if and only if the first operand tests as truthy, and this usage is sometimes called the &quot;guard operator&quot; (also see &quot;Short Circuited&quot; in Chapter 5) -- the first expression test &quot;guards&quot; the second expression:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( a )<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>

a <span class="op">&amp;&amp;</span> <span class="at">foo</span>()<span class="op">;</span> <span class="co">// 42</span></code></pre></div>
<p><code>foo()</code> gets called only because <code>a</code> tests as truthy. If that test failed, this <code>a &amp;&amp; foo()</code> expression statement would just silently stop -- this is known as &quot;short circuiting&quot; -- and never call <code>foo()</code>.</p>
<p>Again, it's not nearly as common for people to author such things. Usually, they'd do <code>if (a) { foo(); }</code> instead. But JS minifiers choose <code>a &amp;&amp; foo()</code> because it's much shorter. So, now, if you ever have to decipher such code, you'll know what it's doing and why.</p>
<p>OK, so <code>||</code> and <code>&amp;&amp;</code> have some neat tricks up their sleeve, as long as you're willing to allow the <em>implicit</em> coercion into the mix.</p>
<p><strong>Note:</strong> Both the <code>a = b || &quot;something&quot;</code> and <code>a &amp;&amp; b()</code> idioms rely on short circuiting behavior, which we cover in more detail in Chapter 5.</p>
<p>The fact that these operators don't actually result in <code>true</code> and <code>false</code> is possibly messing with your head a little bit by now. You're probably wondering how all your <code>if</code> statements and <code>for</code> loops have been working, if they've included compound logical expressions like <code>a &amp;&amp; (b || c)</code>.</p>
<p>Don't worry! The sky is not falling. Your code is (probably) just fine. It's just that you probably never realized before that there was an <em>implicit</em> coercion to <code>boolean</code> going on <strong>after</strong> the compound expression was evaluated.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>

<span class="cf">if</span> (a <span class="op">&amp;&amp;</span> (b <span class="op">||</span> c)) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;yep&quot;</span> )<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>This code still works the way you always thought it did, except for one subtle extra detail. The <code>a &amp;&amp; (b || c)</code> expression <em>actually</em> results in <code>&quot;foo&quot;</code>, not <code>true</code>. So, the <code>if</code> statement <em>then</em> forces the <code>&quot;foo&quot;</code> value to coerce to a <code>boolean</code>, which of course will be <code>true</code>.</p>
<p>See? No reason to panic. Your code is probably still safe. But now you know more about how it does what it does.</p>
<p>And now you also realize that such code is using <em>implicit</em> coercion. If you're in the &quot;avoid (implicit) coercion camp&quot; still, you're going to need to go back and make all of those tests <em>explicit</em>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!!</span>a <span class="op">&amp;&amp;</span> (<span class="op">!!</span>b <span class="op">||</span> <span class="op">!!</span>c)) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;yep&quot;</span> )<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Good luck with that! ... Sorry, just teasing.</p>
<h3 id="symbol-coercion">Symbol Coercion</h3>
<p>Up to this point, there's been almost no observable outcome difference between <em>explicit</em> and <em>implicit</em> coercion -- only the readability of code has been at stake.</p>
<p>But ES6 Symbols introduce a gotcha into the coercion system that we need to discuss briefly. For reasons that go well beyond the scope of what we'll discuss in this book, <em>explicit</em> coercion of a <code>symbol</code> to a <code>string</code> is allowed, but <em>implicit</em> coercion of the same is disallowed and throws an error.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> s1 <span class="op">=</span> <span class="at">Symbol</span>( <span class="st">&quot;cool&quot;</span> )<span class="op">;</span>
<span class="at">String</span>( s1 )<span class="op">;</span>                   <span class="co">// &quot;Symbol(cool)&quot;</span>

<span class="kw">var</span> s2 <span class="op">=</span> <span class="at">Symbol</span>( <span class="st">&quot;not cool&quot;</span> )<span class="op">;</span>
s2 <span class="op">+</span> <span class="st">&quot;&quot;</span><span class="op">;</span>                        <span class="co">// TypeError</span></code></pre></div>
<p><code>symbol</code> values cannot coerce to <code>number</code> at all (throws an error either way), but strangely they can both <em>explicitly</em> and <em>implicitly</em> coerce to <code>boolean</code> (always <code>true</code>).</p>
<p>Consistency is always easier to learn, and exceptions are never fun to deal with, but we just need to be careful around the new ES6 <code>symbol</code> values and how we coerce them.</p>
<p>The good news: it's probably going to be exceedingly rare for you to need to coerce a <code>symbol</code> value. The way they're typically used (see Chapter 3) will probably not call for coercion on a normal basis.</p>
<h2 id="loose-equals-vs.-strict-equals">Loose Equals vs. Strict Equals</h2>
<p>Loose equals is the <code>==</code> operator, and strict equals is the <code>===</code> operator. Both operators are used for comparing two values for &quot;equality,&quot; but the &quot;loose&quot; vs. &quot;strict&quot; indicates a <strong>very important</strong> difference in behavior between the two, specifically in how they decide &quot;equality.&quot;</p>
<p>A very common misconception about these two operators is: &quot;<code>==</code> checks values for equality and <code>===</code> checks both values and types for equality.&quot; While that sounds nice and reasonable, it's inaccurate. Countless well-respected JavaScript books and blogs have said exactly that, but unfortunately they're all <em>wrong</em>.</p>
<p>The correct description is: &quot;<code>==</code> allows coercion in the equality comparison and <code>===</code> disallows coercion.&quot;</p>
<h3 id="equality-performance">Equality Performance</h3>
<p>Stop and think about the difference between the first (inaccurate) explanation and this second (accurate) one.</p>
<p>In the first explanation, it seems obvious that <code>===</code> is <em>doing more work</em> than <code>==</code>, because it has to <em>also</em> check the type. In the second explanation, <code>==</code> is the one <em>doing more work</em> because it has to follow through the steps of coercion if the types are different.</p>
<p>Don't fall into the trap, as many have, of thinking this has anything to do with performance, though, as if <code>==</code> is going to be slower than <code>===</code> in any relevant way. While it's measurable that coercion does take <em>a little bit</em> of processing time, it's mere microseconds (yes, that's millionths of a second!).</p>
<p>If you're comparing two values of the same types, <code>==</code> and <code>===</code> use the identical algorithm, and so other than minor differences in engine implementation, they should do the same work.</p>
<p>If you're comparing two values of different types, the performance isn't the important factor. What you should be asking yourself is: when comparing these two values, do I want coercion or not?</p>
<p>If you want coercion, use <code>==</code> loose equality, but if you don't want coercion, use <code>===</code> strict equality.</p>
<p><strong>Note:</strong> The implication here then is that both <code>==</code> and <code>===</code> check the types of their operands. The difference is in how they respond if the types don't match.</p>
<h3 id="abstract-equality">Abstract Equality</h3>
<p>The <code>==</code> operator's behavior is defined as &quot;The Abstract Equality Comparison Algorithm&quot; in section 11.9.3 of the ES5 spec. What's listed there is a comprehensive but simple algorithm that explicitly states every possible combination of types, and how the coercions (if necessary) should happen for each combination.</p>
<p><strong>Warning:</strong> When (<em>implicit</em>) coercion is maligned as being too complicated and too flawed to be a <em>useful good part</em>, it is these rules of &quot;abstract equality&quot; that are being condemned. Generally, they are said to be too complex and too unintuitive for developers to practically learn and use, and that they are prone more to causing bugs in JS programs than to enabling greater code readability. I believe this is a flawed premise -- that you readers are competent developers who write (and read and understand!) algorithms (aka code) all day long. So, what follows is a plain exposition of the &quot;abstract equality&quot; in simple terms. But I implore you to also read the ES5 spec section 11.9.3. I think you'll be surprised at just how reasonable it is.</p>
<p>Basically, the first clause (11.9.3.1) says, if the two values being compared are of the same type, they are simply and naturally compared via Identity as you'd expect. For example, <code>42</code> is only equal to <code>42</code>, and <code>&quot;abc&quot;</code> is only equal to <code>&quot;abc&quot;</code>.</p>
<p>Some minor exceptions to normal expectation to be aware of:</p>
<ul>
<li><code>NaN</code> is never equal to itself (see Chapter 2)</li>
<li><code>+0</code> and <code>-0</code> are equal to each other (see Chapter 2)</li>
</ul>
<p>The final provision in clause 11.9.3.1 is for <code>==</code> loose equality comparison with <code>object</code>s (including <code>function</code>s and <code>array</code>s). Two such values are only <em>equal</em> if they are both references to <em>the exact same value</em>. No coercion occurs here.</p>
<p><strong>Note:</strong> The <code>===</code> strict equality comparison is defined identically to 11.9.3.1, including the provision about two <code>object</code> values. It's a very little known fact that <strong><code>==</code> and <code>===</code> behave identically</strong> in the case where two <code>object</code>s are being compared!</p>
<p>The rest of the algorithm in 11.9.3 specifies that if you use <code>==</code> loose equality to compare two values of different types, one or both of the values will need to be <em>implicitly</em> coerced. This coercion happens so that both values eventually end up as the same type, which can then directly be compared for equality using simple value Identity.</p>
<p><strong>Note:</strong> The <code>!=</code> loose not-equality operation is defined exactly as you'd expect, in that it's literally the <code>==</code> operation comparison performed in its entirety, then the negation of the result. The same goes for the <code>!==</code> strict not-equality operation.</p>
<h4 id="comparing-strings-to-numbers">Comparing: <code>string</code>s to <code>number</code>s</h4>
<p>To illustrate <code>==</code> coercion, let's first build off the <code>string</code> and <code>number</code> examples earlier in this chapter:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>

a <span class="op">===</span> b<span class="op">;</span>    <span class="co">// false</span>
a <span class="op">==</span> b<span class="op">;</span>     <span class="co">// true</span></code></pre></div>
<p>As we'd expect, <code>a === b</code> fails, because no coercion is allowed, and indeed the <code>42</code> and <code>&quot;42&quot;</code> values are different.</p>
<p>However, the second comparison <code>a == b</code> uses loose equality, which means that if the types happen to be different, the comparison algorithm will perform <em>implicit</em> coercion on one or both values.</p>
<p>But exactly what kind of coercion happens here? Does the <code>a</code> value of <code>42</code> become a <code>string</code>, or does the <code>b</code> value of <code>&quot;42&quot;</code> become a <code>number</code>?</p>
<p>In the ES5 spec, clauses 11.9.3.4-5 say:</p>
<blockquote>
<ol start="4" type="1">
<li>If Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber(y).</li>
<li>If Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x) == y.</li>
</ol>
</blockquote>
<p><strong>Warning:</strong> The spec uses <code>Number</code> and <code>String</code> as the formal names for the types, while this book prefers <code>number</code> and <code>string</code> for the primitive types. Do not let the capitalization of <code>Number</code> in the spec confuse you for the <code>Number()</code> native function. For our purposes, the capitalization of the type name is irrelevant -- they have basically the same meaning.</p>
<p>Clearly, the spec says the <code>&quot;42&quot;</code> value is coerced to a <code>number</code> for the comparison. The <em>how</em> of that coercion has already been covered earlier, specifically with the <code>ToNumber</code> abstract operation. In this case, it's quite obvious then that the resulting two <code>42</code> values are equal.</p>
<h4 id="comparing-anything-to-boolean">Comparing: anything to <code>boolean</code></h4>
<p>One of the biggest gotchas with the <em>implicit</em> coercion of <code>==</code> loose equality pops up when you try to compare a value directly to <code>true</code> or <code>false</code>.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>

a <span class="op">==</span> b<span class="op">;</span> <span class="co">// false</span></code></pre></div>
<p>Wait, what happened here!? We know that <code>&quot;42&quot;</code> is a truthy value (see earlier in this chapter). So, how come it's not <code>==</code> loose equal to <code>true</code>?</p>
<p>The reason is both simple and deceptively tricky. It's so easy to misunderstand, many JS developers never pay close enough attention to fully grasp it.</p>
<p>Let's again quote the spec, clauses 11.9.3.6-7:</p>
<blockquote>
<ol start="6" type="1">
<li>If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.</li>
<li>If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).</li>
</ol>
</blockquote>
<p>Let's break that down. First:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> x <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
<span class="kw">var</span> y <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>

x <span class="op">==</span> y<span class="op">;</span> <span class="co">// false</span></code></pre></div>
<p>The <code>Type(x)</code> is indeed <code>Boolean</code>, so it performs <code>ToNumber(x)</code>, which coerces <code>true</code> to <code>1</code>. Now, <code>1 == &quot;42&quot;</code> is evaluated. The types are still different, so (essentially recursively) we reconsult the algorithm, which just as above will coerce <code>&quot;42&quot;</code> to <code>42</code>, and <code>1 == 42</code> is clearly <code>false</code>.</p>
<p>Reverse it, and we still get the same outcome:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> x <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>
<span class="kw">var</span> y <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>

x <span class="op">==</span> y<span class="op">;</span> <span class="co">// false</span></code></pre></div>
<p>The <code>Type(y)</code> is <code>Boolean</code> this time, so <code>ToNumber(y)</code> yields <code>0</code>. <code>&quot;42&quot; == 0</code> recursively becomes <code>42 == 0</code>, which is of course <code>false</code>.</p>
<p>In other words, <strong>the value <code>&quot;42&quot;</code> is neither <code>== true</code> nor <code>== false</code>.</strong> At first, that statement might seem crazy. How can a value be neither truthy nor falsy?</p>
<p>But that's the problem! You're asking the wrong question, entirely. It's not your fault, really. Your brain is tricking you.</p>
<p><code>&quot;42&quot;</code> is indeed truthy, but <code>&quot;42&quot; == true</code> <strong>is not performing a boolean test/coercion</strong> at all, no matter what your brain says. <code>&quot;42&quot;</code> <em>is not</em> being coerced to a <code>boolean</code> (<code>true</code>), but instead <code>true</code> is being coerced to a <code>1</code>, and then <code>&quot;42&quot;</code> is being coerced to <code>42</code>.</p>
<p>Whether we like it or not, <code>ToBoolean</code> is not even involved here, so the truthiness or falsiness of <code>&quot;42&quot;</code> is irrelevant to the <code>==</code> operation!</p>
<p>What <em>is</em> relevant is to understand how the <code>==</code> comparison algorithm behaves with all the different type combinations. As it regards a <code>boolean</code> value on either side of the <code>==</code>, a <code>boolean</code> always coerces to a <code>number</code> <em>first</em>.</p>
<p>If that seems strange to you, you're not alone. I personally would recommend to never, ever, under any circumstances, use <code>== true</code> or <code>== false</code>. Ever.</p>
<p>But remember, I'm only talking about <code>==</code> here. <code>=== true</code> and <code>=== false</code> wouldn't allow the coercion, so they're safe from this hidden <code>ToNumber</code> coercion.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>

<span class="co">// bad (will fail!):</span>
<span class="cf">if</span> (a <span class="op">==</span> <span class="kw">true</span>) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span>

<span class="co">// also bad (will fail!):</span>
<span class="cf">if</span> (a <span class="op">===</span> <span class="kw">true</span>) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span>

<span class="co">// good enough (works implicitly):</span>
<span class="cf">if</span> (a) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span>

<span class="co">// better (works explicitly):</span>
<span class="cf">if</span> (<span class="op">!!</span>a) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span>

<span class="co">// also great (works explicitly):</span>
<span class="cf">if</span> (<span class="at">Boolean</span>( a )) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>If you avoid ever using <code>== true</code> or <code>== false</code> (aka loose equality with <code>boolean</code>s) in your code, you'll never have to worry about this truthiness/falsiness mental gotcha.</p>
<h4 id="comparing-nulls-to-undefineds">Comparing: <code>null</code>s to <code>undefined</code>s</h4>
<p>Another example of <em>implicit</em> coercion can be seen with <code>==</code> loose equality between <code>null</code> and <code>undefined</code> values. Yet again quoting the ES5 spec, clauses 11.9.3.2-3:</p>
<blockquote>
<ol start="2" type="1">
<li>If x is null and y is undefined, return true.</li>
<li>If x is undefined and y is null, return true.</li>
</ol>
</blockquote>
<p><code>null</code> and <code>undefined</code>, when compared with <code>==</code> loose equality, equate to (aka coerce to) each other (as well as themselves, obviously), and no other values in the entire language.</p>
<p>What this means is that <code>null</code> and <code>undefined</code> can be treated as indistinguishable for comparison purposes, if you use the <code>==</code> loose equality operator to allow their mutual <em>implicit</em> coercion.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>
<span class="kw">var</span> b<span class="op">;</span>

a <span class="op">==</span> b<span class="op">;</span>     <span class="co">// true</span>
a <span class="op">==</span> <span class="kw">null</span><span class="op">;</span>  <span class="co">// true</span>
b <span class="op">==</span> <span class="kw">null</span><span class="op">;</span>  <span class="co">// true</span>

a <span class="op">==</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// false</span>
b <span class="op">==</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// false</span>
a <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span>    <span class="co">// false</span>
b <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span>    <span class="co">// false</span>
a <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>     <span class="co">// false</span>
b <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>     <span class="co">// false</span></code></pre></div>
<p>The coercion between <code>null</code> and <code>undefined</code> is safe and predictable, and no other values can give false positives in such a check. I recommend using this coercion to allow <code>null</code> and <code>undefined</code> to be indistinguishable and thus treated as the same value.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="at">doSomething</span>()<span class="op">;</span>

<span class="cf">if</span> (a <span class="op">==</span> <span class="kw">null</span>) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>The <code>a == null</code> check will pass only if <code>doSomething()</code> returns either <code>null</code> or <code>undefined</code>, and will fail with any other value, even other falsy values like <code>0</code>, <code>false</code>, and <code>&quot;&quot;</code>.</p>
<p>The <em>explicit</em> form of the check, which disallows any such coercion, is (I think) unnecessarily much uglier (and perhaps a tiny bit less performant!):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="at">doSomething</span>()<span class="op">;</span>

<span class="cf">if</span> (a <span class="op">===</span> <span class="kw">undefined</span> <span class="op">||</span> a <span class="op">===</span> <span class="kw">null</span>) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>In my opinion, the form <code>a == null</code> is yet another example where <em>implicit</em> coercion improves code readability, but does so in a reliably safe way.</p>
<h4 id="comparing-objects-to-non-objects">Comparing: <code>object</code>s to non-<code>object</code>s</h4>
<p>If an <code>object</code>/<code>function</code>/<code>array</code> is compared to a simple scalar primitive (<code>string</code>, <code>number</code>, or <code>boolean</code>), the ES5 spec says in clauses 11.9.3.8-9:</p>
<blockquote>
<ol start="8" type="1">
<li>If Type(x) is either String or Number and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).</li>
<li>If Type(x) is Object and Type(y) is either String or Number, return the result of the comparison ToPrimitive(x) == y.</li>
</ol>
</blockquote>
<p><strong>Note:</strong> You may notice that these clauses only mention <code>String</code> and <code>Number</code>, but not <code>Boolean</code>. That's because, as quoted earlier, clauses 11.9.3.6-7 take care of coercing any <code>Boolean</code> operand presented to a <code>Number</code> first.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> [ <span class="dv">42</span> ]<span class="op">;</span>

a <span class="op">==</span> b<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>The <code>[ 42 ]</code> value has its <code>ToPrimitive</code> abstract operation called (see the &quot;Abstract Value Operations&quot; section earlier), which results in the <code>&quot;42&quot;</code> value. From there, it's just <code>42 == &quot;42&quot;</code>, which as we've already covered becomes <code>42 == 42</code>, so <code>a</code> and <code>b</code> are found to be coercively equal.</p>
<p><strong>Tip:</strong> All the quirks of the <code>ToPrimitive</code> abstract operation that we discussed earlier in this chapter (<code>toString()</code>, <code>valueOf()</code>) apply here as you'd expect. This can be quite useful if you have a complex data structure that you want to define a custom <code>valueOf()</code> method on, to provide a simple value for equality comparison purposes.</p>
<p>In Chapter 3, we covered &quot;unboxing,&quot; where an <code>object</code> wrapper around a primitive value (like from <code>new String(&quot;abc&quot;)</code>, for instance) is unwrapped, and the underlying primitive value (<code>&quot;abc&quot;</code>) is returned. This behavior is related to the <code>ToPrimitive</code> coercion in the <code>==</code> algorithm:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="at">Object</span>( a )<span class="op">;</span>    <span class="co">// same as `new String( a )`</span>

a <span class="op">===</span> b<span class="op">;</span>                <span class="co">// false</span>
a <span class="op">==</span> b<span class="op">;</span>                 <span class="co">// true</span></code></pre></div>
<p><code>a == b</code> is <code>true</code> because <code>b</code> is coerced (aka &quot;unboxed,&quot; unwrapped) via <code>ToPrimitive</code> to its underlying <code>&quot;abc&quot;</code> simple scalar primitive value, which is the same as the value in <code>a</code>.</p>
<p>There are some values where this is not the case, though, because of other overriding rules in the <code>==</code> algorithm. Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="at">Object</span>( a )<span class="op">;</span>    <span class="co">// same as `Object()`</span>
a <span class="op">==</span> b<span class="op">;</span>                 <span class="co">// false</span>

<span class="kw">var</span> c <span class="op">=</span> <span class="kw">undefined</span><span class="op">;</span>
<span class="kw">var</span> d <span class="op">=</span> <span class="at">Object</span>( c )<span class="op">;</span>    <span class="co">// same as `Object()`</span>
c <span class="op">==</span> d<span class="op">;</span>                 <span class="co">// false</span>

<span class="kw">var</span> e <span class="op">=</span> <span class="kw">NaN</span><span class="op">;</span>
<span class="kw">var</span> f <span class="op">=</span> <span class="at">Object</span>( e )<span class="op">;</span>    <span class="co">// same as `new Number( e )`</span>
e <span class="op">==</span> f<span class="op">;</span>                 <span class="co">// false</span></code></pre></div>
<p>The <code>null</code> and <code>undefined</code> values cannot be boxed -- they have no object wrapper equivalent -- so <code>Object(null)</code> is just like <code>Object()</code> in that both just produce a normal object.</p>
<p><code>NaN</code> can be boxed to its <code>Number</code> object wrapper equivalent, but when <code>==</code> causes an unboxing, the <code>NaN == NaN</code> comparison fails because <code>NaN</code> is never equal to itself (see Chapter 2).</p>
<h3 id="edge-cases">Edge Cases</h3>
<p>Now that we've thoroughly examined how the <em>implicit</em> coercion of <code>==</code> loose equality works (in both sensible and surprising ways), let's try to call out the worst, craziest corner cases so we can see what we need to avoid to not get bitten with coercion bugs.</p>
<p>First, let's examine how modifying the built-in native prototypes can produce crazy results:</p>
<h4 id="a-number-by-any-other-value-would...">A Number By Any Other Value Would...</h4>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Number</span>.<span class="va">prototype</span>.<span class="at">valueOf</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span>
<span class="op">};</span>

<span class="kw">new</span> <span class="at">Number</span>( <span class="dv">2</span> ) <span class="op">==</span> <span class="dv">3</span><span class="op">;</span>   <span class="co">// true</span></code></pre></div>
<p><strong>Warning:</strong> <code>2 == 3</code> would not have fallen into this trap, because neither <code>2</code> nor <code>3</code> would have invoked the built-in <code>Number.prototype.valueOf()</code> method because both are already primitive <code>number</code> values and can be compared directly. However, <code>new Number(2)</code> must go through the <code>ToPrimitive</code> coercion, and thus invoke <code>valueOf()</code>.</p>
<p>Evil, huh? Of course it is. No one should ever do such a thing. The fact that you <em>can</em> do this is sometimes used as a criticism of coercion and <code>==</code>. But that's misdirected frustration. JavaScript is not <em>bad</em> because you can do such things, a developer is <em>bad</em> <strong>if they do such things</strong>. Don't fall into the &quot;my programming language should protect me from myself&quot; fallacy.</p>
<p>Next, let's consider another tricky example, which takes the evil from the previous example to another level:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (a <span class="op">==</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> a <span class="op">==</span> <span class="dv">3</span>) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>You might think this would be impossible, because <code>a</code> could never be equal to both <code>2</code> and <code>3</code> <em>at the same time</em>. But &quot;at the same time&quot; is inaccurate, since the first expression <code>a == 2</code> happens strictly <em>before</em> <code>a == 3</code>.</p>
<p>So, what if we make <code>a.valueOf()</code> have side effects each time it's called, such that the first time it returns <code>2</code> and the second time it's called it returns <code>3</code>? Pretty easy:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>

<span class="va">Number</span>.<span class="va">prototype</span>.<span class="at">valueOf</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
    <span class="cf">return</span> i<span class="op">++;</span>
<span class="op">};</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Number</span>( <span class="dv">42</span> )<span class="op">;</span>

<span class="cf">if</span> (a <span class="op">==</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> a <span class="op">==</span> <span class="dv">3</span>) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Yep, this happened.&quot;</span> )<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Again, these are evil tricks. Don't do them. But also don't use them as complaints against coercion. Potential abuses of a mechanism are not sufficient evidence to condemn the mechanism. Just avoid these crazy tricks, and stick only with valid and proper usage of coercion.</p>
<h4 id="false-y-comparisons">False-y Comparisons</h4>
<p>The most common complaint against <em>implicit</em> coercion in <code>==</code> comparisons comes from how falsy values behave surprisingly when compared to each other.</p>
<p>To illustrate, let's look at a list of the corner-cases around falsy value comparisons, to see which ones are reasonable and which are troublesome:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&quot;0&quot;</span> <span class="op">==</span> <span class="kw">null</span><span class="op">;</span>            <span class="co">// false</span>
<span class="st">&quot;0&quot;</span> <span class="op">==</span> <span class="kw">undefined</span><span class="op">;</span>       <span class="co">// false</span>
<span class="st">&quot;0&quot;</span> <span class="op">==</span> <span class="kw">false</span><span class="op">;</span>           <span class="co">// true -- UH OH!</span>
<span class="st">&quot;0&quot;</span> <span class="op">==</span> <span class="kw">NaN</span><span class="op">;</span>             <span class="co">// false</span>
<span class="st">&quot;0&quot;</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>               <span class="co">// true</span>
<span class="st">&quot;0&quot;</span> <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span>              <span class="co">// false</span>

<span class="kw">false</span> <span class="op">==</span> <span class="kw">null</span><span class="op">;</span>          <span class="co">// false</span>
<span class="kw">false</span> <span class="op">==</span> <span class="kw">undefined</span><span class="op">;</span>     <span class="co">// false</span>
<span class="kw">false</span> <span class="op">==</span> <span class="kw">NaN</span><span class="op">;</span>           <span class="co">// false</span>
<span class="kw">false</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>             <span class="co">// true -- UH OH!</span>
<span class="kw">false</span> <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span>            <span class="co">// true -- UH OH!</span>
<span class="kw">false</span> <span class="op">==</span> []<span class="op">;</span>            <span class="co">// true -- UH OH!</span>
<span class="kw">false</span> <span class="op">==</span> <span class="op">{};</span>            <span class="co">// false</span>

<span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="kw">null</span><span class="op">;</span>             <span class="co">// false</span>
<span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="kw">undefined</span><span class="op">;</span>        <span class="co">// false</span>
<span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="kw">NaN</span><span class="op">;</span>              <span class="co">// false</span>
<span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>                <span class="co">// true -- UH OH!</span>
<span class="st">&quot;&quot;</span> <span class="op">==</span> []<span class="op">;</span>               <span class="co">// true -- UH OH!</span>
<span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="op">{};</span>               <span class="co">// false</span>

<span class="dv">0</span> <span class="op">==</span> <span class="kw">null</span><span class="op">;</span>              <span class="co">// false</span>
<span class="dv">0</span> <span class="op">==</span> <span class="kw">undefined</span><span class="op">;</span>         <span class="co">// false</span>
<span class="dv">0</span> <span class="op">==</span> <span class="kw">NaN</span><span class="op">;</span>               <span class="co">// false</span>
<span class="dv">0</span> <span class="op">==</span> []<span class="op">;</span>                <span class="co">// true -- UH OH!</span>
<span class="dv">0</span> <span class="op">==</span> <span class="op">{};</span>                <span class="co">// false</span></code></pre></div>
<p>In this list of 24 comparisons, 17 of them are quite reasonable and predictable. For example, we know that <code>&quot;&quot;</code> and <code>NaN</code> are not at all equatable values, and indeed they don't coerce to be loose equals, whereas <code>&quot;0&quot;</code> and <code>0</code> are reasonably equatable and <em>do</em> coerce as loose equals.</p>
<p>However, seven of the comparisons are marked with &quot;UH OH!&quot; because as false positives, they are much more likely gotchas that could trip you up. <code>&quot;&quot;</code> and <code>0</code> are definitely distinctly different values, and it's rare you'd want to treat them as equatable, so their mutual coercion is troublesome. Note that there aren't any false negatives here.</p>
<h4 id="the-crazy-ones">The Crazy Ones</h4>
<p>We don't have to stop there, though. We can keep looking for even more troublesome coercions:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">[] <span class="op">==</span> <span class="op">!</span>[]<span class="op">;</span>      <span class="co">// true</span></code></pre></div>
<p>Oooo, that seems at a higher level of crazy, right!? Your brain may likely trick you that you're comparing a truthy to a falsy value, so the <code>true</code> result is surprising, as we <em>know</em> a value can never be truthy and falsy at the same time!</p>
<p>But that's not what's actually happening. Let's break it down. What do we know about the <code>!</code> unary operator? It explicitly coerces to a <code>boolean</code> using the <code>ToBoolean</code> rules (and it also flips the parity). So before <code>[] == ![]</code> is even processed, it's actually already translated to <code>[] == false</code>. We already saw that form in our above list (<code>false == []</code>), so its surprise result is <em>not new</em> to us.</p>
<p>How about other corner cases?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="dv">2</span> <span class="op">==</span> [<span class="dv">2</span>]<span class="op">;</span>       <span class="co">// true</span>
<span class="st">&quot;&quot;</span> <span class="op">==</span> [<span class="kw">null</span>]<span class="op">;</span>   <span class="co">// true</span></code></pre></div>
<p>As we said earlier in our <code>ToNumber</code> discussion, the right-hand side <code>[2]</code> and <code>[null]</code> values will go through a <code>ToPrimitive</code> coercion so they can be more readily compared to the simple primitives (<code>2</code> and <code>&quot;&quot;</code>, respectively) on the left-hand side. Since the <code>valueOf()</code> for <code>array</code> values just returns the <code>array</code> itself, coercion falls to stringifying the <code>array</code>.</p>
<p><code>[2]</code> will become <code>&quot;2&quot;</code>, which then is <code>ToNumber</code> coerced to <code>2</code> for the right-hand side value in the first comparison. <code>[null]</code> just straight becomes <code>&quot;&quot;</code>.</p>
<p>So, <code>2 == 2</code> and <code>&quot;&quot; == &quot;&quot;</code> are completely understandable.</p>
<p>If your instinct is to still dislike these results, your frustration is not actually with coercion like you probably think it is. It's actually a complaint against the default <code>array</code> values' <code>ToPrimitive</code> behavior of coercing to a <code>string</code> value. More likely, you'd just wish that <code>[2].toString()</code> didn't return <code>&quot;2&quot;</code>, or that <code>[null].toString()</code> didn't return <code>&quot;&quot;</code>.</p>
<p>But what exactly <em>should</em> these <code>string</code> coercions result in? I can't really think of any other appropriate <code>string</code> coercion of <code>[2]</code> than <code>&quot;2&quot;</code>, except perhaps <code>&quot;[2]&quot;</code> -- but that could be very strange in other contexts!</p>
<p>You could rightly make the case that since <code>String(null)</code> becomes <code>&quot;null&quot;</code>, then <code>String([null])</code> should also become <code>&quot;null&quot;</code>. That's a reasonable assertion. So, that's the real culprit.</p>
<p><em>Implicit</em> coercion itself isn't the evil here. Even an <em>explicit</em> coercion of <code>[null]</code> to a <code>string</code> results in <code>&quot;&quot;</code>. What's at odds is whether it's sensible at all for <code>array</code> values to stringify to the equivalent of their contents, and exactly how that happens. So, direct your frustration at the rules for <code>String( [..] )</code>, because that's where the craziness stems from. Perhaps there should be no stringification coercion of <code>array</code>s at all? But that would have lots of other downsides in other parts of the language.</p>
<p>Another famously cited gotcha:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="dv">0</span> <span class="op">==</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span>      <span class="co">// true</span></code></pre></div>
<p>As we discussed earlier with empty <code>&quot;&quot;</code>, <code>&quot;\n&quot;</code> (or <code>&quot; &quot;</code> or any other whitespace combination) is coerced via <code>ToNumber</code>, and the result is <code>0</code>. What other <code>number</code> value would you expect whitespace to coerce to? Does it bother you that <em>explicit</em> <code>Number(&quot; &quot;)</code> yields <code>0</code>?</p>
<p>Really the only other reasonable <code>number</code> value that empty strings or whitespace strings could coerce to is the <code>NaN</code>. But would that <em>really</em> be better? The comparison <code>&quot; &quot; == NaN</code> would of course fail, but it's unclear that we'd have really <em>fixed</em> any of the underlying concerns.</p>
<p>The chances that a real-world JS program fails because <code>0 == &quot;\n&quot;</code> are awfully rare, and such corner cases are easy to avoid.</p>
<p>Type conversions <strong>always</strong> have corner cases, in any language -- nothing specific to coercion. The issues here are about second-guessing a certain set of corner cases (and perhaps rightly so!?), but that's not a salient argument against the overall coercion mechanism.</p>
<p>Bottom line: almost any crazy coercion between <em>normal values</em> that you're likely to run into (aside from intentionally tricky <code>valueOf()</code> or <code>toString()</code> hacks as earlier) will boil down to the short seven-item list of gotcha coercions we've identified above.</p>
<p>To contrast against these 24 likely suspects for coercion gotchas, consider another list like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="dv">42</span> <span class="op">==</span> <span class="st">&quot;43&quot;</span><span class="op">;</span>                         <span class="co">// false</span>
<span class="st">&quot;foo&quot;</span> <span class="op">==</span> <span class="dv">42</span><span class="op">;</span>                        <span class="co">// false</span>
<span class="st">&quot;true&quot;</span> <span class="op">==</span> <span class="kw">true</span><span class="op">;</span>                     <span class="co">// false</span>

<span class="dv">42</span> <span class="op">==</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>                         <span class="co">// true</span>
<span class="st">&quot;foo&quot;</span> <span class="op">==</span> [ <span class="st">&quot;foo&quot;</span> ]<span class="op">;</span>                 <span class="co">// true</span></code></pre></div>
<p>In these nonfalsy, noncorner cases (and there are literally an infinite number of comparisons we could put on this list), the coercion results are totally safe, reasonable, and explainable.</p>
<h4 id="sanity-check">Sanity Check</h4>
<p>OK, we've definitely found some crazy stuff when we've looked deeply into <em>implicit</em> coercion. No wonder that most developers claim coercion is evil and should be avoided, right!?</p>
<p>But let's take a step back and do a sanity check.</p>
<p>By way of magnitude comparison, we have <em>a list</em> of seven troublesome gotcha coercions, but we have <em>another list</em> of (at least 17, but actually infinite) coercions that are totally sane and explainable.</p>
<p>If you're looking for a textbook example of &quot;throwing the baby out with the bathwater,&quot; this is it: discarding the entirety of coercion (the infinitely large list of safe and useful behaviors) because of a list of literally just seven gotchas.</p>
<p>The more prudent reaction would be to ask, &quot;how can I use the countless <em>good parts</em> of coercion, but avoid the few <em>bad parts</em>?&quot;</p>
<p>Let's look again at the <em>bad</em> list:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&quot;0&quot;</span> <span class="op">==</span> <span class="kw">false</span><span class="op">;</span>           <span class="co">// true -- UH OH!</span>
<span class="kw">false</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>             <span class="co">// true -- UH OH!</span>
<span class="kw">false</span> <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span>            <span class="co">// true -- UH OH!</span>
<span class="kw">false</span> <span class="op">==</span> []<span class="op">;</span>            <span class="co">// true -- UH OH!</span>
<span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>                <span class="co">// true -- UH OH!</span>
<span class="st">&quot;&quot;</span> <span class="op">==</span> []<span class="op">;</span>               <span class="co">// true -- UH OH!</span>
<span class="dv">0</span> <span class="op">==</span> []<span class="op">;</span>                <span class="co">// true -- UH OH!</span></code></pre></div>
<p>Four of the seven items on this list involve <code>== false</code> comparison, which we said earlier you should <strong>always, always</strong> avoid. That's a pretty easy rule to remember.</p>
<p>Now the list is down to three.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>                <span class="co">// true -- UH OH!</span>
<span class="st">&quot;&quot;</span> <span class="op">==</span> []<span class="op">;</span>               <span class="co">// true -- UH OH!</span>
<span class="dv">0</span> <span class="op">==</span> []<span class="op">;</span>                <span class="co">// true -- UH OH!</span></code></pre></div>
<p>Are these reasonable coercions you'd do in a normal JavaScript program? Under what conditions would they really happen?</p>
<p>I don't think it's terribly likely that you'd literally use <code>== []</code> in a <code>boolean</code> test in your program, at least not if you know what you're doing. You'd probably instead be doing <code>== &quot;&quot;</code> or <code>== 0</code>, like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">doSomething</span>(a) <span class="op">{</span>
    <span class="cf">if</span> (a <span class="op">==</span> <span class="st">&quot;&quot;</span>) <span class="op">{</span>
        <span class="co">// ..</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>You'd have an oops if you accidentally called <code>doSomething(0)</code> or <code>doSomething([])</code>. Another scenario:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">doSomething</span>(a<span class="op">,</span>b) <span class="op">{</span>
    <span class="cf">if</span> (a <span class="op">==</span> b) <span class="op">{</span>
        <span class="co">// ..</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Again, this could break if you did something like <code>doSomething(&quot;&quot;,0)</code> or <code>doSomething([],&quot;&quot;)</code>.</p>
<p>So, while the situations <em>can</em> exist where these coercions will bite you, and you'll want to be careful around them, they're probably not super common on the whole of your code base.</p>
<h4 id="safely-using-implicit-coercion">Safely Using Implicit Coercion</h4>
<p>The most important advice I can give you: examine your program and reason about what values can show up on either side of an <code>==</code> comparison. To effectively avoid issues with such comparisons, here's some heuristic rules to follow:</p>
<ol type="1">
<li>If either side of the comparison can have <code>true</code> or <code>false</code> values, don't ever, EVER use <code>==</code>.</li>
<li>If either side of the comparison can have <code>[]</code>, <code>&quot;&quot;</code>, or <code>0</code> values, seriously consider not using <code>==</code>.</li>
</ol>
<p>In these scenarios, it's almost certainly better to use <code>===</code> instead of <code>==</code>, to avoid unwanted coercion. Follow those two simple rules and pretty much all the coercion gotchas that could reasonably hurt you will effectively be avoided.</p>
<p><strong>Being more explicit/verbose in these cases will save you from a lot of headaches.</strong></p>
<p>The question of <code>==</code> vs. <code>===</code> is really appropriately framed as: should you allow coercion for a comparison or not?</p>
<p>There's lots of cases where such coercion can be helpful, allowing you to more tersely express some comparison logic (like with <code>null</code> and <code>undefined</code>, for example).</p>
<p>In the overall scheme of things, there's relatively few cases where <em>implicit</em> coercion is truly dangerous. But in those places, for safety sake, definitely use <code>===</code>.</p>
<p><strong>Tip:</strong> Another place where coercion is guaranteed <em>not</em> to bite you is with the <code>typeof</code> operator. <code>typeof</code> is always going to return you one of seven strings (see Chapter 1), and none of them are the empty <code>&quot;&quot;</code> string. As such, there's no case where checking the type of some value is going to run afoul of <em>implicit</em> coercion. <code>typeof x == &quot;function&quot;</code> is 100% as safe and reliable as <code>typeof x === &quot;function&quot;</code>. Literally, the spec says the algorithm will be identical in this situation. So, don't just blindly use <code>===</code> everywhere simply because that's what your code tools tell you to do, or (worst of all) because you've been told in some book to <strong>not think about it</strong>. You own the quality of your code.</p>
<p>Is <em>implicit</em> coercion evil and dangerous? In a few cases, yes, but overwhelmingly, no.</p>
<p>Be a responsible and mature developer. Learn how to use the power of coercion (both <em>explicit</em> and <em>implicit</em>) effectively and safely. And teach those around you to do the same.</p>
<p>Here's a handy table made by Alex Dorey (<span class="citation" data-cites="dorey">@dorey</span> on GitHub) to visualize a variety of comparisons:</p>
<p><img src="fig1.png" width="600"/></p>
<p>Source: https://github.com/dorey/JavaScript-Equality-Table</p>
<h2 id="abstract-relational-comparison">Abstract Relational Comparison</h2>
<p>While this part of <em>implicit</em> coercion often gets a lot less attention, it's important nonetheless to think about what happens with <code>a &lt; b</code> comparisons (similar to how we just examined <code>a == b</code> in depth).</p>
<p>The &quot;Abstract Relational Comparison&quot; algorithm in ES5 section 11.8.5 essentially divides itself into two parts: what to do if the comparison involves both <code>string</code> values (second half), or anything else (first half).</p>
<p><strong>Note:</strong> The algorithm is only defined for <code>a &lt; b</code>. So, <code>a &gt; b</code> is handled as <code>b &lt; a</code>.</p>
<p>The algorithm first calls <code>ToPrimitive</code> coercion on both values, and if the return result of either call is not a <code>string</code>, then both values are coerced to <code>number</code> values using the <code>ToNumber</code> operation rules, and compared numerically.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [ <span class="dv">42</span> ]<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> [ <span class="st">&quot;43&quot;</span> ]<span class="op">;</span>

a <span class="op">&lt;</span> b<span class="op">;</span>  <span class="co">// true</span>
b <span class="op">&lt;</span> a<span class="op">;</span>  <span class="co">// false</span></code></pre></div>
<p><strong>Note:</strong> Similar caveats for <code>-0</code> and <code>NaN</code> apply here as they did in the <code>==</code> algorithm discussed earlier.</p>
<p>However, if both values are <code>string</code>s for the <code>&lt;</code> comparison, simple lexicographic (natural alphabetic) comparison on the characters is performed:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [ <span class="st">&quot;42&quot;</span> ]<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> [ <span class="st">&quot;043&quot;</span> ]<span class="op">;</span>

a <span class="op">&lt;</span> b<span class="op">;</span>  <span class="co">// false</span></code></pre></div>
<p><code>a</code> and <code>b</code> are <em>not</em> coerced to <code>number</code>s, because both of them end up as <code>string</code>s after the <code>ToPrimitive</code> coercion on the two <code>array</code>s. So, <code>&quot;42&quot;</code> is compared character by character to <code>&quot;043&quot;</code>, starting with the first characters <code>&quot;4&quot;</code> and <code>&quot;0&quot;</code>, respectively. Since <code>&quot;0&quot;</code> is lexicographically <em>less than</em> than <code>&quot;4&quot;</code>, the comparison returns <code>false</code>.</p>
<p>The exact same behavior and reasoning goes for:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [ <span class="dv">4</span><span class="op">,</span> <span class="dv">2</span> ]<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> [ <span class="dv">0</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">3</span> ]<span class="op">;</span>

a <span class="op">&lt;</span> b<span class="op">;</span>  <span class="co">// false</span></code></pre></div>
<p>Here, <code>a</code> becomes <code>&quot;4,2&quot;</code> and <code>b</code> becomes <code>&quot;0,4,3&quot;</code>, and those lexicographically compare identically to the previous snippet.</p>
<p>What about:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span> <span class="dt">b</span><span class="op">:</span> <span class="dv">42</span> <span class="op">};</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="op">{</span> <span class="dt">b</span><span class="op">:</span> <span class="dv">43</span> <span class="op">};</span>

a <span class="op">&lt;</span> b<span class="op">;</span>  <span class="co">// ??</span></code></pre></div>
<p><code>a &lt; b</code> is also <code>false</code>, because <code>a</code> becomes <code>[object Object]</code> and <code>b</code> becomes <code>[object Object]</code>, and so clearly <code>a</code> is not lexicographically less than <code>b</code>.</p>
<p>But strangely:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span> <span class="dt">b</span><span class="op">:</span> <span class="dv">42</span> <span class="op">};</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="op">{</span> <span class="dt">b</span><span class="op">:</span> <span class="dv">43</span> <span class="op">};</span>

a <span class="op">&lt;</span> b<span class="op">;</span>  <span class="co">// false</span>
a <span class="op">==</span> b<span class="op">;</span> <span class="co">// false</span>
a <span class="op">&gt;</span> b<span class="op">;</span>  <span class="co">// false</span>

a <span class="op">&lt;=</span> b<span class="op">;</span> <span class="co">// true</span>
a <span class="op">&gt;=</span> b<span class="op">;</span> <span class="co">// true</span></code></pre></div>
<p>Why is <code>a == b</code> not <code>true</code>? They're the same <code>string</code> value (<code>&quot;[object Object]&quot;</code>), so it seems they should be equal, right? Nope. Recall the previous discussion about how <code>==</code> works with <code>object</code> references.</p>
<p>But then how are <code>a &lt;= b</code> and <code>a &gt;= b</code> resulting in <code>true</code>, if <code>a &lt; b</code> <strong>and</strong> <code>a == b</code> <strong>and</strong> <code>a &gt; b</code> are all <code>false</code>?</p>
<p>Because the spec says for <code>a &lt;= b</code>, it will actually evaluate <code>b &lt; a</code> first, and then negate that result. Since <code>b &lt; a</code> is <em>also</em> <code>false</code>, the result of <code>a &lt;= b</code> is <code>true</code>.</p>
<p>That's probably awfully contrary to how you might have explained what <code>&lt;=</code> does up to now, which would likely have been the literal: &quot;less than <em>or</em> equal to.&quot; JS more accurately considers <code>&lt;=</code> as &quot;not greater than&quot; (<code>!(a &gt; b)</code>, which JS treats as <code>!(b &lt; a)</code>). Moreover, <code>a &gt;= b</code> is explained by first considering it as <code>b &lt;= a</code>, and then applying the same reasoning.</p>
<p>Unfortunately, there is no &quot;strict relational comparison&quot; as there is for equality. In other words, there's no way to prevent <em>implicit</em> coercion from occurring with relational comparisons like <code>a &lt; b</code>, other than to ensure that <code>a</code> and <code>b</code> are of the same type explicitly before making the comparison.</p>
<p>Use the same reasoning from our earlier <code>==</code> vs. <code>===</code> sanity check discussion. If coercion is helpful and reasonably safe, like in a <code>42 &lt; &quot;43&quot;</code> comparison, <strong>use it</strong>. On the other hand, if you need to be safe about a relational comparison, <em>explicitly coerce</em> the values first, before using <code>&lt;</code> (or its counterparts).</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> [ <span class="dv">42</span> ]<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;043&quot;</span><span class="op">;</span>

a <span class="op">&lt;</span> b<span class="op">;</span>                      <span class="co">// false -- string comparison!</span>
<span class="at">Number</span>( a ) <span class="op">&lt;</span> <span class="at">Number</span>( b )<span class="op">;</span>  <span class="co">// true -- number comparison!</span></code></pre></div>
<h2 id="review-3">Review</h2>
<p>In this chapter, we turned our attention to how JavaScript type conversions happen, called <strong>coercion</strong>, which can be characterized as either <em>explicit</em> or <em>implicit</em>.</p>
<p>Coercion gets a bad rap, but it's actually quite useful in many cases. An important task for the responsible JS developer is to take the time to learn all the ins and outs of coercion to decide which parts will help improve their code, and which parts they really should avoid.</p>
<p><em>Explicit</em> coercion is code which is obvious that the intent is to convert a value from one type to another. The benefit is improvement in readability and maintainability of code by reducing confusion.</p>
<p><em>Implicit</em> coercion is coercion that is &quot;hidden&quot; as a side-effect of some other operation, where it's not as obvious that the type conversion will occur. While it may seem that <em>implicit</em> coercion is the opposite of <em>explicit</em> and is thus bad (and indeed, many think so!), actually <em>implicit</em> coercion is also about improving the readability of code.</p>
<p>Especially for <em>implicit</em>, coercion must be used responsibly and consciously. Know why you're writing the code you're writing, and how it works. Strive to write code that others will easily be able to learn from and understand as well.</p>
<h1 id="you-dont-know-js-types-grammar-5">You Don't Know JS: Types &amp; Grammar</h1>
<h1 id="chapter-5-grammar">Chapter 5: Grammar</h1>
<p>The last major topic we want to tackle is how JavaScript's language syntax works (aka its grammar). You may think you know how to write JS, but there's an awful lot of nuance to various parts of the language grammar that lead to confusion and misconception, so we want to dive into those parts and clear some things up.</p>
<p><strong>Note:</strong> The term &quot;grammar&quot; may be a little less familiar to readers than the term &quot;syntax.&quot; In many ways, they are similar terms, describing the <em>rules</em> for how the language works. There are nuanced differences, but they mostly don't matter for our discussion here. The grammar for JavaScript is a structured way to describe how the syntax (operators, keywords, etc.) fits together into well-formed, valid programs. In other words, discussing syntax without grammar would leave out a lot of the important details. So our focus here in this chapter is most accurately described as <em>grammar</em>, even though the raw syntax of the language is what developers directly interact with.</p>
<h2 id="statements-expressions">Statements &amp; Expressions</h2>
<p>It's fairly common for developers to assume that the term &quot;statement&quot; and &quot;expression&quot; are roughly equivalent. But here we need to distinguish between the two, because there are some very important differences in our JS programs.</p>
<p>To draw the distinction, let's borrow from terminology you may be more familiar with: the English language.</p>
<p>A &quot;sentence&quot; is one complete formation of words that expresses a thought. It's comprised of one or more &quot;phrases,&quot; each of which can be connected with punctuation marks or conjunction words (&quot;and,&quot; &quot;or,&quot; etc). A phrase can itself be made up of smaller phrases. Some phrases are incomplete and don't accomplish much by themselves, while other phrases can stand on their own. These rules are collectively called the <em>grammar</em> of the English language.</p>
<p>And so it goes with JavaScript grammar. Statements are sentences, expressions are phrases, and operators are conjunctions/punctuation.</p>
<p>Every expression in JS can be evaluated down to a single, specific value result. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">6</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> a<span class="op">;</span>
b<span class="op">;</span></code></pre></div>
<p>In this snippet, <code>3 * 6</code> is an expression (evaluates to the value <code>18</code>). But <code>a</code> on the second line is also an expression, as is <code>b</code> on the third line. The <code>a</code> and <code>b</code> expressions both evaluate to the values stored in those variables at that moment, which also happens to be <code>18</code>.</p>
<p>Moreover, each of the three lines is a statement containing expressions. <code>var a = 3 * 6</code> and <code>var b = a</code> are called &quot;declaration statements&quot; because they each declare a variable (and optionally assign a value to it). The <code>a = 3 * 6</code> and <code>b = a</code> assignments (minus the <code>var</code>s) are called assignment expressions.</p>
<p>The third line contains just the expression <code>b</code>, but it's also a statement all by itself (though not a terribly interesting one!). This is generally referred to as an &quot;expression statement.&quot;</p>
<h3 id="statement-completion-values">Statement Completion Values</h3>
<p>It's a fairly little known fact that statements all have completion values (even if that value is just <code>undefined</code>).</p>
<p>How would you even go about seeing the completion value of a statement?</p>
<p>The most obvious answer is to type the statement into your browser's developer console, because when you execute it, the console by default reports the completion value of the most recent statement it executed.</p>
<p>Let's consider <code>var b = a</code>. What's the completion value of that statement?</p>
<p>The <code>b = a</code> assignment expression results in the value that was assigned (<code>18</code> above), but the <code>var</code> statement itself results in <code>undefined</code>. Why? Because <code>var</code> statements are defined that way in the spec. If you put <code>var a = 42;</code> into your console, you'll see <code>undefined</code> reported back instead of <code>42</code>.</p>
<p><strong>Note:</strong> Technically, it's a little more complex than that. In the ES5 spec, section 12.2 &quot;Variable Statement,&quot; the <code>VariableDeclaration</code> algorithm actually <em>does</em> return a value (a <code>string</code> containing the name of the variable declared -- weird, huh!?), but that value is basically swallowed up (except for use by the <code>for..in</code> loop) by the <code>VariableStatement</code> algorithm, which forces an empty (aka <code>undefined</code>) completion value.</p>
<p>In fact, if you've done much code experimenting in your console (or in a JavaScript environment REPL -- read/evaluate/print/loop tool), you've probably seen <code>undefined</code> reported after many different statements, and perhaps never realized why or what that was. Put simply, the console is just reporting the statement's completion value.</p>
<p>But what the console prints out for the completion value isn't something we can use inside our program. So how can we capture the completion value?</p>
<p>That's a much more complicated task. Before we explain <em>how</em>, let's explore <em>why</em> you would want to do that.</p>
<p>We need to consider other types of statement completion values. For example, any regular <code>{ .. }</code> block has a completion value of the completion value of its last contained statement/expression.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> b<span class="op">;</span>

<span class="cf">if</span> (<span class="kw">true</span>) <span class="op">{</span>
    b <span class="op">=</span> <span class="dv">4</span> <span class="op">+</span> <span class="dv">38</span><span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>If you typed that into your console/REPL, you'd probably see <code>42</code> reported, since <code>42</code> is the completion value of the <code>if</code> block, which took on the completion value of its last assignment expression statement <code>b = 4 + 38</code>.</p>
<p>In other words, the completion value of a block is like an <em>implicit return</em> of the last statement value in the block.</p>
<p><strong>Note:</strong> This is conceptually familiar in languages like CoffeeScript, which have implicit <code>return</code> values from <code>function</code>s that are the same as the last statement value in the function.</p>
<p>But there's an obvious problem. This kind of code doesn't work:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a<span class="op">,</span> b<span class="op">;</span>

a <span class="op">=</span> <span class="cf">if</span> (<span class="kw">true</span>) <span class="op">{</span>
    b <span class="op">=</span> <span class="dv">4</span> <span class="op">+</span> <span class="dv">38</span><span class="op">;</span>
<span class="op">};</span></code></pre></div>
<p>We can't capture the completion value of a statement and assign it into another variable in any easy syntactic/grammatical way (at least not yet!).</p>
<p>So, what can we do?</p>
<p><strong>Warning</strong>: For demo purposes only -- don't actually do the following in your real code!</p>
<p>We could use the much maligned <code>eval(..)</code> (sometimes pronounced &quot;evil&quot;) function to capture this completion value.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a<span class="op">,</span> b<span class="op">;</span>

a <span class="op">=</span> <span class="at">eval</span>( <span class="st">&quot;if (true) { b = 4 + 38; }&quot;</span> )<span class="op">;</span>

a<span class="op">;</span>  <span class="co">// 42</span></code></pre></div>
<p>Yeeeaaahhhh. That's terribly ugly. But it works! And it illustrates the point that statement completion values are a real thing that can be captured not just in our console but in our programs.</p>
<p>There's a proposal for ES7 called &quot;do expression.&quot; Here's how it might work:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a<span class="op">,</span> b<span class="op">;</span>

a <span class="op">=</span> <span class="cf">do</span> <span class="op">{</span>
    <span class="cf">if</span> (<span class="kw">true</span>) <span class="op">{</span>
        b <span class="op">=</span> <span class="dv">4</span> <span class="op">+</span> <span class="dv">38</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

a<span class="op">;</span>  <span class="co">// 42</span></code></pre></div>
<p>The <code>do { .. }</code> expression executes a block (with one or many statements in it), and the final statement completion value inside the block becomes the completion value <em>of</em> the <code>do</code> expression, which can then be assigned to <code>a</code> as shown.</p>
<p>The general idea is to be able to treat statements as expressions -- they can show up inside other statements -- without needing to wrap them in an inline function expression and perform an explicit <code>return ..</code>.</p>
<p>For now, statement completion values are not much more than trivia. But they're probably going to take on more significance as JS evolves, and hopefully <code>do { .. }</code> expressions will reduce the temptation to use stuff like <code>eval(..)</code>.</p>
<p><strong>Warning:</strong> Repeating my earlier admonition: avoid <code>eval(..)</code>. Seriously. See the <em>Scope &amp; Closures</em> title of this series for more explanation.</p>
<h3 id="expression-side-effects">Expression Side Effects</h3>
<p>Most expressions don't have side effects. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> a <span class="op">+</span> <span class="dv">3</span><span class="op">;</span></code></pre></div>
<p>The expression <code>a + 3</code> did not <em>itself</em> have a side effect, like for instance changing <code>a</code>. It had a result, which is <code>5</code>, and that result was assigned to <code>b</code> in the statement <code>b = a + 3</code>.</p>
<p>The most common example of an expression with (possible) side effects is a function call expression:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    a <span class="op">=</span> a <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
<span class="at">foo</span>()<span class="op">;</span>      <span class="co">// result: `undefined`, side effect: changed `a`</span></code></pre></div>
<p>There are other side-effecting expressions, though. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> a<span class="op">++;</span></code></pre></div>
<p>The expression <code>a++</code> has two separate behaviors. <em>First</em>, it returns the current value of <code>a</code>, which is <code>42</code> (which then gets assigned to <code>b</code>). But <em>next</em>, it changes the value of <code>a</code> itself, incrementing it by one.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> a<span class="op">++;</span>

a<span class="op">;</span>  <span class="co">// 43</span>
b<span class="op">;</span>  <span class="co">// 42</span></code></pre></div>
<p>Many developers would mistakenly believe that <code>b</code> has value <code>43</code> just like <code>a</code> does. But the confusion comes from not fully considering the <em>when</em> of the side effects of the <code>++</code> operator.</p>
<p>The <code>++</code> increment operator and the <code>--</code> decrement operator are both unary operators (see Chapter 4), which can be used in either a postfix (&quot;after&quot;) position or prefix (&quot;before&quot;) position.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>

a<span class="op">++;</span>    <span class="co">// 42</span>
a<span class="op">;</span>      <span class="co">// 43</span>

<span class="op">++</span>a<span class="op">;</span>    <span class="co">// 44</span>
a<span class="op">;</span>      <span class="co">// 44</span></code></pre></div>
<p>When <code>++</code> is used in the prefix position as <code>++a</code>, its side effect (incrementing <code>a</code>) happens <em>before</em> the value is returned from the expression, rather than <em>after</em> as with <code>a++</code>.</p>
<p><strong>Note:</strong> Would you think <code>++a++</code> was legal syntax? If you try it, you'll get a <code>ReferenceError</code> error, but why? Because side-effecting operators <strong>require a variable reference</strong> to target their side effects to. For <code>++a++</code>, the <code>a++</code> part is evaluated first (because of operator precedence -- see below), which gives back the value of <code>a</code> <em>before</em> the increment. But then it tries to evaluate <code>++42</code>, which (if you try it) gives the same <code>ReferenceError</code> error, since <code>++</code> can't have a side effect directly on a value like <code>42</code>.</p>
<p>It is sometimes mistakenly thought that you can encapsulate the <em>after</em> side effect of <code>a++</code> by wrapping it in a <code>( )</code> pair, like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> (a<span class="op">++</span>)<span class="op">;</span>

a<span class="op">;</span>  <span class="co">// 43</span>
b<span class="op">;</span>  <span class="co">// 42</span></code></pre></div>
<p>Unfortunately, <code>( )</code> itself doesn't define a new wrapped expression that would be evaluated <em>after</em> the <em>after side effect</em> of the <code>a++</code> expression, as we might have hoped. In fact, even if it did, <code>a++</code> returns <code>42</code> first, and unless you have another expression that reevaluates <code>a</code> after the side effect of <code>++</code>, you're not going to get <code>43</code> from that expression, so <code>b</code> will not be assigned <code>43</code>.</p>
<p>There's an option, though: the <code>,</code> statement-series comma operator. This operator allows you to string together multiple standalone expression statements into a single statement:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">,</span> b<span class="op">;</span>
b <span class="op">=</span> ( a<span class="op">++,</span> a )<span class="op">;</span>

a<span class="op">;</span>  <span class="co">// 43</span>
b<span class="op">;</span>  <span class="co">// 43</span></code></pre></div>
<p><strong>Note:</strong> The <code>( .. )</code> around <code>a++, a</code> is required here. The reason is operator precedence, which we'll cover later in this chapter.</p>
<p>The expression <code>a++, a</code> means that the second <code>a</code> statement expression gets evaluated <em>after</em> the <em>after side effects</em> of the first <code>a++</code> statement expression, which means it returns the <code>43</code> value for assignment to <code>b</code>.</p>
<p>Another example of a side-effecting operator is <code>delete</code>. As we showed in Chapter 2, <code>delete</code> is used to remove a property from an <code>object</code> or a slot from an <code>array</code>. But it's usually just called as a standalone statement:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">42</span>
<span class="op">};</span>

<span class="va">obj</span>.<span class="at">a</span><span class="op">;</span>          <span class="co">// 42</span>
<span class="kw">delete</span> <span class="va">obj</span>.<span class="at">a</span><span class="op">;</span>   <span class="co">// true</span>
<span class="va">obj</span>.<span class="at">a</span><span class="op">;</span>          <span class="co">// undefined</span></code></pre></div>
<p>The result value of the <code>delete</code> operator is <code>true</code> if the requested operation is valid/allowable, or <code>false</code> otherwise. But the side effect of the operator is that it removes the property (or array slot).</p>
<p><strong>Note:</strong> What do we mean by valid/allowable? Nonexistent properties, or properties that exist and are configurable (see Chapter 3 of the <em>this &amp; Object Prototypes</em> title of this series) will return <code>true</code> from the <code>delete</code> operator. Otherwise, the result will be <code>false</code> or an error.</p>
<p>One last example of a side-effecting operator, which may at once be both obvious and nonobvious, is the <code>=</code> assignment operator.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a<span class="op">;</span>

a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>     <span class="co">// 42</span>
a<span class="op">;</span>          <span class="co">// 42</span></code></pre></div>
<p>It may not seem like <code>=</code> in <code>a = 42</code> is a side-effecting operator for the expression. But if we examine the result value of the <code>a = 42</code> statement, it's the value that was just assigned (<code>42</code>), so the assignment of that same value into <code>a</code> is essentially a side effect.</p>
<p><strong>Tip:</strong> The same reasoning about side effects goes for the compound-assignment operators like <code>+=</code>, <code>-=</code>, etc. For example, <code>a = b += 2</code> is processed first as <code>b += 2</code> (which is <code>b = b + 2</code>), and the result of <em>that</em> <code>=</code> assignment is then assigned to <code>a</code>.</p>
<p>This behavior that an assignment expression (or statement) results in the assigned value is primarily useful for chained assignments, such as:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span>

a <span class="op">=</span> b <span class="op">=</span> c <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></code></pre></div>
<p>Here, <code>c = 42</code> is evaluated to <code>42</code> (with the side effect of assigning <code>42</code> to <code>c</code>), then <code>b = 42</code> is evaluated to <code>42</code> (with the side effect of assigning <code>42</code> to <code>b</code>), and finally <code>a = 42</code> is evaluated (with the side effect of assigning <code>42</code> to <code>a</code>).</p>
<p><strong>Warning:</strong> A common mistake developers make with chained assignments is like <code>var a = b = 42</code>. While this looks like the same thing, it's not. If that statement were to happen without there also being a separate <code>var b</code> (somewhere in the scope) to formally declare <code>b</code>, then <code>var a = b = 42</code> would not declare <code>b</code> directly. Depending on <code>strict</code> mode, that would either throw an error or create an accidental global (see the <em>Scope &amp; Closures</em> title of this series).</p>
<p>Another scenario to consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">vowels</span>(str) <span class="op">{</span>
    <span class="kw">var</span> matches<span class="op">;</span>

    <span class="cf">if</span> (str) <span class="op">{</span>
        <span class="co">// pull out all the vowels</span>
        matches <span class="op">=</span> <span class="va">str</span>.<span class="at">match</span>( <span class="ss">/</span><span class="sc">[aeiou]</span><span class="ss">/g</span> )<span class="op">;</span>

        <span class="cf">if</span> (matches) <span class="op">{</span>
            <span class="cf">return</span> matches<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="at">vowels</span>( <span class="st">&quot;Hello World&quot;</span> )<span class="op">;</span> <span class="co">// [&quot;e&quot;,&quot;o&quot;,&quot;o&quot;]</span></code></pre></div>
<p>This works, and many developers prefer such. But using an idiom where we take advantage of the assignment side effect, we can simplify by combining the two <code>if</code> statements into one:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">vowels</span>(str) <span class="op">{</span>
    <span class="kw">var</span> matches<span class="op">;</span>

    <span class="co">// pull out all the vowels</span>
    <span class="cf">if</span> (str <span class="op">&amp;&amp;</span> (matches <span class="op">=</span> <span class="va">str</span>.<span class="at">match</span>( <span class="ss">/</span><span class="sc">[aeiou]</span><span class="ss">/g</span> ))) <span class="op">{</span>
        <span class="cf">return</span> matches<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="at">vowels</span>( <span class="st">&quot;Hello World&quot;</span> )<span class="op">;</span> <span class="co">// [&quot;e&quot;,&quot;o&quot;,&quot;o&quot;]</span></code></pre></div>
<p><strong>Note:</strong> The <code>( .. )</code> around <code>matches = str.match..</code> is required. The reason is operator precedence, which we'll cover in the &quot;Operator Precedence&quot; section later in this chapter.</p>
<p>I prefer this shorter style, as I think it makes it clearer that the two conditionals are in fact related rather than separate. But as with most stylistic choices in JS, it's purely opinion which one is <em>better</em>.</p>
<h3 id="contextual-rules">Contextual Rules</h3>
<p>There are quite a few places in the JavaScript grammar rules where the same syntax means different things depending on where/how it's used. This kind of thing can, in isolation, cause quite a bit of confusion.</p>
<p>We won't exhaustively list all such cases here, but just call out a few of the common ones.</p>
<h4 id="curly-braces"><code>{ .. }</code> Curly Braces</h4>
<p>There's two main places (and more coming as JS evolves!) that a pair of <code>{ .. }</code> curly braces will show up in your code. Let's take a look at each of them.</p>
<h5 id="object-literals">Object Literals</h5>
<p>First, as an <code>object</code> literal:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// assume there&#39;s a `bar()` function defined</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="at">bar</span>()
<span class="op">};</span></code></pre></div>
<p>How do we know this is an <code>object</code> literal? Because the <code>{ .. }</code> pair is a value that's getting assigned to <code>a</code>.</p>
<p><strong>Note:</strong> The <code>a</code> reference is called an &quot;l-value&quot; (aka left-hand value) since it's the target of an assignment. The <code>{ .. }</code> pair is an &quot;r-value&quot; (aka right-hand value) since it's used <em>just</em> as a value (in this case as the source of an assignment).</p>
<h5 id="labels">Labels</h5>
<p>What happens if we remove the <code>var a =</code> part of the above snippet?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// assume there&#39;s a `bar()` function defined</span>

<span class="op">{</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="at">bar</span>()
<span class="op">}</span></code></pre></div>
<p>A lot of developers assume that the <code>{ .. }</code> pair is just a standalone <code>object</code> literal that doesn't get assigned anywhere. But it's actually entirely different.</p>
<p>Here, <code>{ .. }</code> is just a regular code block. It's not very idiomatic in JavaScript (much more so in other languages!) to have a standalone <code>{ .. }</code> block like that, but it's perfectly valid JS grammar. It can be especially helpful when combined with <code>let</code> block-scoping declarations (see the <em>Scope &amp; Closures</em> title in this series).</p>
<p>The <code>{ .. }</code> code block here is functionally pretty much identical to the code block being attached to some statement, like a <code>for</code>/<code>while</code> loop, <code>if</code> conditional, etc.</p>
<p>But if it's a normal block of code, what's that bizarre looking <code>foo: bar()</code> syntax, and how is that legal?</p>
<p>It's because of a little known (and, frankly, discouraged) feature in JavaScript called &quot;labeled statements.&quot; <code>foo</code> is a label for the statement <code>bar()</code> (which has omitted its trailing <code>;</code> -- see &quot;Automatic Semicolons&quot; later in this chapter). But what's the point of a labeled statement?</p>
<p>If JavaScript had a <code>goto</code> statement, you'd theoretically be able to say <code>goto foo</code> and have execution jump to that location in code. <code>goto</code>s are usually considered terrible coding idioms as they make code much harder to understand (aka &quot;spaghetti code&quot;), so it's a <em>very good thing</em> that JavaScript doesn't have a general <code>goto</code>.</p>
<p>However, JS <em>does</em> support a limited, special form of <code>goto</code>: labeled jumps. Both the <code>continue</code> and <code>break</code> statements can optionally accept a specified label, in which case the program flow &quot;jumps&quot; kind of like a <code>goto</code>. Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// `foo` labeled-loop</span>
foo<span class="op">:</span> <span class="cf">for</span> (<span class="kw">var</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="dv">4</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="cf">for</span> (<span class="kw">var</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span> j<span class="op">&lt;</span><span class="dv">4</span><span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span>
        <span class="co">// whenever the loops meet, continue outer loop</span>
        <span class="cf">if</span> (j <span class="op">==</span> i) <span class="op">{</span>
            <span class="co">// jump to the next iteration of</span>
            <span class="co">// the `foo` labeled-loop</span>
            <span class="cf">continue</span> foo<span class="op">;</span>
        <span class="op">}</span>

        <span class="co">// skip odd multiples</span>
        <span class="cf">if</span> ((j <span class="op">*</span> i) <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span>) <span class="op">{</span>
            <span class="co">// normal (non-labeled) `continue` of inner loop</span>
            <span class="cf">continue</span><span class="op">;</span>
        <span class="op">}</span>

        <span class="va">console</span>.<span class="at">log</span>( i<span class="op">,</span> j )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>
<span class="co">// 1 0</span>
<span class="co">// 2 0</span>
<span class="co">// 2 1</span>
<span class="co">// 3 0</span>
<span class="co">// 3 2</span></code></pre></div>
<p><strong>Note:</strong> <code>continue foo</code> does not mean &quot;go to the 'foo' labeled position to continue&quot;, but rather, &quot;continue the loop that is labeled 'foo' with its next iteration.&quot; So, it's not <em>really</em> an arbitrary <code>goto</code>.</p>
<p>As you can see, we skipped over the odd-multiple <code>3 1</code> iteration, but the labeled-loop jump also skipped iterations <code>1 1</code> and <code>2 2</code>.</p>
<p>Perhaps a slightly more useful form of the labeled jump is with <code>break __</code> from inside an inner loop where you want to break out of the outer loop. Without a labeled <code>break</code>, this same logic could sometimes be rather awkward to write:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// `foo` labeled-loop</span>
foo<span class="op">:</span> <span class="cf">for</span> (<span class="kw">var</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="dv">4</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="cf">for</span> (<span class="kw">var</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span> j<span class="op">&lt;</span><span class="dv">4</span><span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span>
        <span class="cf">if</span> ((i <span class="op">*</span> j) <span class="op">&gt;=</span> <span class="dv">3</span>) <span class="op">{</span>
            <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;stopping!&quot;</span><span class="op">,</span> i<span class="op">,</span> j )<span class="op">;</span>
            <span class="co">// break out of the `foo` labeled loop</span>
            <span class="cf">break</span> foo<span class="op">;</span>
        <span class="op">}</span>

        <span class="va">console</span>.<span class="at">log</span>( i<span class="op">,</span> j )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>
<span class="co">// 0 0</span>
<span class="co">// 0 1</span>
<span class="co">// 0 2</span>
<span class="co">// 0 3</span>
<span class="co">// 1 0</span>
<span class="co">// 1 1</span>
<span class="co">// 1 2</span>
<span class="co">// stopping! 1 3</span></code></pre></div>
<p><strong>Note:</strong> <code>break foo</code> does not mean &quot;go to the 'foo' labeled position to continue,&quot; but rather, &quot;break out of the loop/block that is labeled 'foo' and continue <em>after</em> it.&quot; Not exactly a <code>goto</code> in the traditional sense, huh?</p>
<p>The nonlabeled <code>break</code> alternative to the above would probably need to involve one or more functions, shared scope variable access, etc. It would quite likely be more confusing than labeled <code>break</code>, so here using a labeled <code>break</code> is perhaps the better option.</p>
<p>A label can apply to a non-loop block, but only <code>break</code> can reference such a non-loop label. You can do a labeled <code>break ___</code> out of any labeled block, but you cannot <code>continue ___</code> a non-loop label, nor can you do a non-labeled <code>break</code> out of a block.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="co">// `bar` labeled-block</span>
    <span class="dt">bar</span><span class="op">:</span> <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Hello&quot;</span> )<span class="op">;</span>
        <span class="cf">break</span> bar<span class="op">;</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;never runs&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;World&quot;</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="at">foo</span>()<span class="op">;</span>
<span class="co">// Hello</span>
<span class="co">// World</span></code></pre></div>
<p>Labeled loops/blocks are extremely uncommon, and often frowned upon. It's best to avoid them if possible; for example using function calls instead of the loop jumps. But there are perhaps some limited cases where they might be useful. If you're going to use a labeled jump, make sure to document what you're doing with plenty of comments!</p>
<p>It's a very common belief that JSON is a proper subset of JS, so a string of JSON (like <code>{&quot;a&quot;:42}</code> -- notice the quotes around the property name as JSON requires!) is thought to be a valid JavaScript program. <strong>Not true!</strong> Try putting <code>{&quot;a&quot;:42}</code> into your JS console, and you'll get an error.</p>
<p>That's because statement labels cannot have quotes around them, so <code>&quot;a&quot;</code> is not a valid label, and thus <code>:</code> can't come right after it.</p>
<p>So, JSON is truly a subset of JS syntax, but JSON is not valid JS grammar by itself.</p>
<p>One extremely common misconception along these lines is that if you were to load a JS file into a <code>&lt;script src=..&gt;</code> tag that only has JSON content in it (like from an API call), the data would be read as valid JavaScript but just be inaccessible to the program. JSON-P (the practice of wrapping the JSON data in a function call, like <code>foo({&quot;a&quot;:42})</code>) is usually said to solve this inaccessibility by sending the value to one of your program's functions.</p>
<p><strong>Not true!</strong> The totally valid JSON value <code>{&quot;a&quot;:42}</code> by itself would actually throw a JS error because it'd be interpreted as a statement block with an invalid label. But <code>foo({&quot;a&quot;:42})</code> is valid JS because in it, <code>{&quot;a&quot;:42}</code> is an <code>object</code> literal value being passed to <code>foo(..)</code>. So, properly said, <strong>JSON-P makes JSON into valid JS grammar!</strong></p>
<h5 id="blocks">Blocks</h5>
<p>Another commonly cited JS gotcha (related to coercion -- see Chapter 4) is:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">[] <span class="op">+</span> <span class="op">{};</span> <span class="co">// &quot;[object Object]&quot;</span>
<span class="op">{}</span> <span class="op">+</span> []<span class="op">;</span> <span class="co">// 0</span></code></pre></div>
<p>This seems to imply the <code>+</code> operator gives different results depending on whether the first operand is the <code>[]</code> or the <code>{}</code>. But that actually has nothing to do with it!</p>
<p>On the first line, <code>{}</code> appears in the <code>+</code> operator's expression, and is therefore interpreted as an actual value (an empty <code>object</code>). Chapter 4 explained that <code>[]</code> is coerced to <code>&quot;&quot;</code> and thus <code>{}</code> is coerced to a <code>string</code> value as well: <code>&quot;[object Object]&quot;</code>.</p>
<p>But on the second line, <code>{}</code> is interpreted as a standalone <code>{}</code> empty block (which does nothing). Blocks don't need semicolons to terminate them, so the lack of one here isn't a problem. Finally, <code>+ []</code> is an expression that <em>explicitly coerces</em> (see Chapter 4) the <code>[]</code> to a <code>number</code>, which is the <code>0</code> value.</p>
<h5 id="object-destructuring">Object Destructuring</h5>
<p>Starting with ES6, another place that you'll see <code>{ .. }</code> pairs showing up is with &quot;destructuring assignments&quot; (see the <em>ES6 &amp; Beyond</em> title of this series for more info), specifically <code>object</code> destructuring. Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">getData</span>() <span class="op">{</span>
    <span class="co">// ..</span>
    <span class="cf">return</span> <span class="op">{</span>
        <span class="dt">a</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span>
        <span class="dt">b</span><span class="op">:</span> <span class="st">&quot;foo&quot;</span>
    <span class="op">};</span>
<span class="op">}</span>

<span class="kw">var</span> <span class="op">{</span> a<span class="op">,</span> b <span class="op">}</span> <span class="op">=</span> <span class="at">getData</span>()<span class="op">;</span>

<span class="va">console</span>.<span class="at">log</span>( a<span class="op">,</span> b )<span class="op">;</span> <span class="co">// 42 &quot;foo&quot;</span></code></pre></div>
<p>As you can probably tell, <code>var { a , b } = ..</code> is a form of ES6 destructuring assignment, which is roughly equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> res <span class="op">=</span> <span class="at">getData</span>()<span class="op">;</span>
<span class="kw">var</span> a <span class="op">=</span> <span class="va">res</span>.<span class="at">a</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="va">res</span>.<span class="at">b</span><span class="op">;</span></code></pre></div>
<p><strong>Note:</strong> <code>{ a, b }</code> is actually ES6 destructuring shorthand for <code>{ a: a, b: b }</code>, so either will work, but it's expected that the shorter <code>{ a, b }</code> will be become the preferred form.</p>
<p>Object destructuring with a <code>{ .. }</code> pair can also be used for named function arguments, which is sugar for this same sort of implicit object property assignment:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(<span class="op">{</span> a<span class="op">,</span> b<span class="op">,</span> c <span class="op">}</span>) <span class="op">{</span>
    <span class="co">// no need for:</span>
    <span class="co">// var a = obj.a, b = obj.b, c = obj.c</span>
    <span class="va">console</span>.<span class="at">log</span>( a<span class="op">,</span> b<span class="op">,</span> c )<span class="op">;</span>
<span class="op">}</span>

<span class="at">foo</span>( <span class="op">{</span>
    <span class="dt">c</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">,</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span>
    <span class="dt">b</span><span class="op">:</span> <span class="st">&quot;foo&quot;</span>
<span class="op">}</span> )<span class="op">;</span>    <span class="co">// 42 &quot;foo&quot; [1, 2, 3]</span></code></pre></div>
<p>So, the context we use <code>{ .. }</code> pairs in entirely determines what they mean, which illustrates the difference between syntax and grammar. It's very important to understand these nuances to avoid unexpected interpretations by the JS engine.</p>
<h4 id="else-if-and-optional-blocks"><code>else if</code> And Optional Blocks</h4>
<p>It's a common misconception that JavaScript has an <code>else if</code> clause, because you can do:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (a) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span>
<span class="cf">else</span> <span class="cf">if</span> (b) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span>
<span class="cf">else</span> <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>But there's a hidden characteristic of the JS grammar here: there is no <code>else if</code>. But <code>if</code> and <code>else</code> statements are allowed to omit the <code>{ }</code> around their attached block if they only contain a single statement. You've seen this many times before, undoubtedly:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (a) <span class="at">doSomething</span>( a )<span class="op">;</span></code></pre></div>
<p>Many JS style guides will insist that you always use <code>{ }</code> around a single statement block, like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (a) <span class="op">{</span> <span class="at">doSomething</span>( a )<span class="op">;</span> <span class="op">}</span></code></pre></div>
<p>However, the exact same grammar rule applies to the <code>else</code> clause, so the <code>else if</code> form you've likely always coded is <em>actually</em> parsed as:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (a) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span>
<span class="cf">else</span> <span class="op">{</span>
    <span class="cf">if</span> (b) <span class="op">{</span>
        <span class="co">// ..</span>
    <span class="op">}</span>
    <span class="cf">else</span> <span class="op">{</span>
        <span class="co">// ..</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>The <code>if (b) { .. } else { .. }</code> is a single statement that follows the <code>else</code>, so you can either put the surrounding <code>{ }</code> in or not. In other words, when you use <code>else if</code>, you're technically breaking that common style guide rule and just defining your <code>else</code> with a single <code>if</code> statement.</p>
<p>Of course, the <code>else if</code> idiom is extremely common and results in one less level of indentation, so it's attractive. Whichever way you do it, just call out explicitly in your own style guide/rules and don't assume things like <code>else if</code> are direct grammar rules.</p>
<h2 id="operator-precedence">Operator Precedence</h2>
<p>As we covered in Chapter 4, JavaScript's version of <code>&amp;&amp;</code> and <code>||</code> are interesting in that they select and return one of their operands, rather than just resulting in <code>true</code> or <code>false</code>. That's easy to reason about if there are only two operands and one operator.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>

a <span class="op">&amp;&amp;</span> b<span class="op">;</span> <span class="co">// &quot;foo&quot;</span>
a <span class="op">||</span> b<span class="op">;</span> <span class="co">// 42</span></code></pre></div>
<p>But what about when there's two operators involved, and three operands?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span>

a <span class="op">&amp;&amp;</span> b <span class="op">||</span> c<span class="op">;</span> <span class="co">// ???</span>
a <span class="op">||</span> b <span class="op">&amp;&amp;</span> c<span class="op">;</span> <span class="co">// ???</span></code></pre></div>
<p>To understand what those expressions result in, we're going to need to understand what rules govern how the operators are processed when there's more than one present in an expression.</p>
<p>These rules are called &quot;operator precedence.&quot;</p>
<p>I bet most readers feel they have a decent grasp on operator precedence. But as with everything else we've covered in this book series, we're going to poke and prod at that understanding to see just how solid it really is, and hopefully learn a few new things along the way.</p>
<p>Recall the example from above:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">,</span> b<span class="op">;</span>
b <span class="op">=</span> ( a<span class="op">++,</span> a )<span class="op">;</span>

a<span class="op">;</span>  <span class="co">// 43</span>
b<span class="op">;</span>  <span class="co">// 43</span></code></pre></div>
<p>But what would happen if we remove the <code>( )</code>?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">,</span> b<span class="op">;</span>
b <span class="op">=</span> a<span class="op">++,</span> a<span class="op">;</span>

a<span class="op">;</span>  <span class="co">// 43</span>
b<span class="op">;</span>  <span class="co">// 42</span></code></pre></div>
<p>Wait! Why did that change the value assigned to <code>b</code>?</p>
<p>Because the <code>,</code> operator has a lower precedence than the <code>=</code> operator. So, <code>b = a++, a</code> is interpreted as <code>(b = a++), a</code>. Because (as we explained earlier) <code>a++</code> has <em>after side effects</em>, the assigned value to <code>b</code> is the value <code>42</code> before the <code>++</code> changes <code>a</code>.</p>
<p>This is just a simple matter of needing to understand operator precedence. If you're going to use <code>,</code> as a statement-series operator, it's important to know that it actually has the lowest precedence. Every other operator will more tightly bind than <code>,</code> will.</p>
<p>Now, recall this example from above:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (str <span class="op">&amp;&amp;</span> (matches <span class="op">=</span> <span class="va">str</span>.<span class="at">match</span>( <span class="ss">/</span><span class="sc">[aeiou]</span><span class="ss">/g</span> ))) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>We said the <code>( )</code> around the assignment is required, but why? Because <code>&amp;&amp;</code> has higher precedence than <code>=</code>, so without the <code>( )</code> to force the binding, the expression would instead be treated as <code>(str &amp;&amp; matches) = str.match..</code>. But this would be an error, because the result of <code>(str &amp;&amp; matches)</code> isn't going to be a variable, but instead a value (in this case <code>undefined</code>), and so it can't be the left-hand side of an <code>=</code> assignment!</p>
<p>OK, so you probably think you've got this operator precedence thing down.</p>
<p>Let's move on to a more complex example (which we'll carry throughout the next several sections of this chapter) to <em>really</em> test your understanding:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>

<span class="kw">var</span> d <span class="op">=</span> a <span class="op">&amp;&amp;</span> b <span class="op">||</span> c <span class="op">?</span> c <span class="op">||</span> b <span class="op">?</span> a : c <span class="op">&amp;&amp;</span> b : a<span class="op">;</span>

d<span class="op">;</span>      <span class="co">// ??</span></code></pre></div>
<p>OK, evil, I admit it. No one would write a string of expressions like that, right? <em>Probably</em> not, but we're going to use it to examine various issues around chaining multiple operators together, which <em>is</em> a very common task.</p>
<p>The result above is <code>42</code>. But that's not nearly as interesting as how we can figure out that answer without just plugging it into a JS program to let JavaScript sort it out.</p>
<p>Let's dig in.</p>
<p>The first question -- it may not have even occurred to you to ask -- is, does the first part (<code>a &amp;&amp; b || c</code>) behave like <code>(a &amp;&amp; b) || c</code> or like <code>a &amp;&amp; (b || c)</code>? Do you know for certain? Can you even convince yourself they are actually different?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">(<span class="kw">false</span> <span class="op">&amp;&amp;</span> <span class="kw">true</span>) <span class="op">||</span> <span class="kw">true</span><span class="op">;</span>    <span class="co">// true</span>
<span class="kw">false</span> <span class="op">&amp;&amp;</span> (<span class="kw">true</span> <span class="op">||</span> <span class="kw">true</span>)<span class="op">;</span>    <span class="co">// false</span></code></pre></div>
<p>So, there's proof they're different. But still, how does <code>false &amp;&amp; true || true</code> behave? The answer:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">false</span> <span class="op">&amp;&amp;</span> <span class="kw">true</span> <span class="op">||</span> <span class="kw">true</span><span class="op">;</span>      <span class="co">// true</span>
(<span class="kw">false</span> <span class="op">&amp;&amp;</span> <span class="kw">true</span>) <span class="op">||</span> <span class="kw">true</span><span class="op">;</span>    <span class="co">// true</span></code></pre></div>
<p>So we have our answer. The <code>&amp;&amp;</code> operator is evaluated first and the <code>||</code> operator is evaluated second.</p>
<p>But is that just because of left-to-right processing? Let's reverse the order of operators:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">true</span> <span class="op">||</span> <span class="kw">false</span> <span class="op">&amp;&amp;</span> <span class="kw">false</span><span class="op">;</span>     <span class="co">// true</span>

(<span class="kw">true</span> <span class="op">||</span> <span class="kw">false</span>) <span class="op">&amp;&amp;</span> <span class="kw">false</span><span class="op">;</span>   <span class="co">// false -- nope</span>
<span class="kw">true</span> <span class="op">||</span> (<span class="kw">false</span> <span class="op">&amp;&amp;</span> <span class="kw">false</span>)<span class="op">;</span>   <span class="co">// true -- winner, winner!</span></code></pre></div>
<p>Now we've proved that <code>&amp;&amp;</code> is evaluated first and then <code>||</code>, and in this case that was actually counter to generally expected left-to-right processing.</p>
<p>So what caused the behavior? <strong>Operator precedence</strong>.</p>
<p>Every language defines its own operator precedence list. It's dismaying, though, just how uncommon it is that JS developers have read JS's list.</p>
<p>If you knew it well, the above examples wouldn't have tripped you up in the slightest, because you'd already know that <code>&amp;&amp;</code> is more precedent than <code>||</code>. But I bet a fair amount of readers had to think about it a little bit.</p>
<p><strong>Note:</strong> Unfortunately, the JS spec doesn't really have its operator precedence list in a convenient, single location. You have to parse through and understand all the grammar rules. So we'll try to lay out the more common and useful bits here in a more convenient format. For a complete list of operator precedence, see &quot;Operator Precedence&quot; on the MDN site (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence).</p>
<h3 id="short-circuited">Short Circuited</h3>
<p>In Chapter 4, we mentioned in a side note the &quot;short circuiting&quot; nature of operators like <code>&amp;&amp;</code> and <code>||</code>. Let's revisit that in more detail now.</p>
<p>For both <code>&amp;&amp;</code> and <code>||</code> operators, the right-hand operand will <strong>not be evaluated</strong> if the left-hand operand is sufficient to determine the outcome of the operation. Hence, the name &quot;short circuited&quot; (in that if possible, it will take an early shortcut out).</p>
<p>For example, with <code>a &amp;&amp; b</code>, <code>b</code> is not evaluated if <code>a</code> is falsy, because the result of the <code>&amp;&amp;</code> operand is already certain, so there's no point in bothering to check <code>b</code>. Likewise, with <code>a || b</code>, if <code>a</code> is truthy, the result of the operand is already certain, so there's no reason to check <code>b</code>.</p>
<p>This short circuiting can be very helpful and is commonly used:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">doSomething</span>(opts) <span class="op">{</span>
    <span class="cf">if</span> (opts <span class="op">&amp;&amp;</span> <span class="va">opts</span>.<span class="at">cool</span>) <span class="op">{</span>
        <span class="co">// ..</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>The <code>opts</code> part of the <code>opts &amp;&amp; opts.cool</code> test acts as sort of a guard, because if <code>opts</code> is unset (or is not an <code>object</code>), the expression <code>opts.cool</code> would throw an error. The <code>opts</code> test failing plus the short circuiting means that <code>opts.cool</code> won't even be evaluated, thus no error!</p>
<p>Similarly, you can use <code>||</code> short circuiting:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">doSomething</span>(opts) <span class="op">{</span>
    <span class="cf">if</span> (<span class="va">opts</span>.<span class="at">cache</span> <span class="op">||</span> <span class="at">primeCache</span>()) <span class="op">{</span>
        <span class="co">// ..</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Here, we're checking for <code>opts.cache</code> first, and if it's present, we don't call the <code>primeCache()</code> function, thus avoiding potentially unnecessary work.</p>
<h3 id="tighter-binding">Tighter Binding</h3>
<p>But let's turn our attention back to that earlier complex statement example with all the chained operators, specifically the <code>? :</code> ternary operator parts. Does the <code>? :</code> operator have more or less precedence than the <code>&amp;&amp;</code> and <code>||</code> operators?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">a <span class="op">&amp;&amp;</span> b <span class="op">||</span> c <span class="op">?</span> c <span class="op">||</span> b <span class="op">?</span> a : c <span class="op">&amp;&amp;</span> b : a</code></pre></div>
<p>Is that more like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">a <span class="op">&amp;&amp;</span> b <span class="op">||</span> (c <span class="op">?</span> c <span class="op">||</span> (b <span class="op">?</span> a : c) <span class="op">&amp;&amp;</span> b : a)</code></pre></div>
<p>or this?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">(a <span class="op">&amp;&amp;</span> b <span class="op">||</span> c) <span class="op">?</span> (c <span class="op">||</span> b) <span class="op">?</span> a : (c <span class="op">&amp;&amp;</span> b) : a</code></pre></div>
<p>The answer is the second one. But why?</p>
<p>Because <code>&amp;&amp;</code> is more precedent than <code>||</code>, and <code>||</code> is more precedent than <code>? :</code>.</p>
<p>So, the expression <code>(a &amp;&amp; b || c)</code> is evaluated <em>first</em> before the <code>? :</code> it participates in. Another way this is commonly explained is that <code>&amp;&amp;</code> and <code>||</code> &quot;bind more tightly&quot; than <code>? :</code>. If the reverse was true, then <code>c ? c...</code> would bind more tightly, and it would behave (as the first choice) like <code>a &amp;&amp; b || (c ? c..)</code>.</p>
<h3 id="associativity">Associativity</h3>
<p>So, the <code>&amp;&amp;</code> and <code>||</code> operators bind first, then the <code>? :</code> operator. But what about multiple operators of the same precedence? Do they always process left-to-right or right-to-left?</p>
<p>In general, operators are either left-associative or right-associative, referring to whether <strong>grouping happens from the left or from the right</strong>.</p>
<p>It's important to note that associativity is <em>not</em> the same thing as left-to-right or right-to-left processing.</p>
<p>But why does it matter whether processing is left-to-right or right-to-left? Because expressions can have side effects, like for instance with function calls:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="at">foo</span>() <span class="op">&amp;&amp;</span> <span class="at">bar</span>()<span class="op">;</span></code></pre></div>
<p>Here, <code>foo()</code> is evaluated first, and then possibly <code>bar()</code> depending on the result of the <code>foo()</code> expression. That definitely could result in different program behavior than if <code>bar()</code> was called before <code>foo()</code>.</p>
<p>But this behavior is <em>just</em> left-to-right processing (the default behavior in JavaScript!) -- it has nothing to do with the associativity of <code>&amp;&amp;</code>. In that example, since there's only one <code>&amp;&amp;</code> and thus no relevant grouping here, associativity doesn't even come into play.</p>
<p>But with an expression like <code>a &amp;&amp; b &amp;&amp; c</code>, grouping <em>will</em> happen implicitly, meaning that either <code>a &amp;&amp; b</code> or <code>b &amp;&amp; c</code> will be evaluated first.</p>
<p>Technically, <code>a &amp;&amp; b &amp;&amp; c</code> will be handled as <code>(a &amp;&amp; b) &amp;&amp; c</code>, because <code>&amp;&amp;</code> is left-associative (so is <code>||</code>, by the way). However, the right-associative alternative <code>a &amp;&amp; (b &amp;&amp; c)</code> behaves observably the same way. For the same values, the same expressions are evaluated in the same order.</p>
<p><strong>Note:</strong> If hypothetically <code>&amp;&amp;</code> was right-associative, it would be processed the same as if you manually used <code>( )</code> to create grouping like <code>a &amp;&amp; (b &amp;&amp; c)</code>. But that still <strong>doesn't mean</strong> that <code>c</code> would be processed before <code>b</code>. Right-associativity does <strong>not</strong> mean right-to-left evaluation, it means right-to-left <strong>grouping</strong>. Either way, regardless of the grouping/associativity, the strict ordering of evaluation will be <code>a</code>, then <code>b</code>, then <code>c</code> (aka left-to-right).</p>
<p>So it doesn't really matter that much that <code>&amp;&amp;</code> and <code>||</code> are left-associative, other than to be accurate in how we discuss their definitions.</p>
<p>But that's not always the case. Some operators would behave very differently depending on left-associativity vs. right-associativity.</p>
<p>Consider the <code>? :</code> (&quot;ternary&quot; or &quot;conditional&quot;) operator:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">a <span class="op">?</span> b : c <span class="op">?</span> d : e<span class="op">;</span></code></pre></div>
<p><code>? :</code> is right-associative, so which grouping represents how it will be processed?</p>
<ul>
<li><code>a ? b : (c ? d : e)</code></li>
<li><code>(a ? b : c) ? d : e</code></li>
</ul>
<p>The answer is <code>a ? b : (c ? d : e)</code>. Unlike with <code>&amp;&amp;</code> and <code>||</code> above, the right-associativity here actually matters, as <code>(a ? b : c) ? d : e</code> <em>will</em> behave differently for some (but not all!) combinations of values.</p>
<p>One such example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">true</span> <span class="op">?</span> <span class="kw">false</span> : <span class="kw">true</span> <span class="op">?</span> <span class="kw">true</span> : <span class="kw">true</span><span class="op">;</span>      <span class="co">// false</span>

<span class="kw">true</span> <span class="op">?</span> <span class="kw">false</span> : (<span class="kw">true</span> <span class="op">?</span> <span class="kw">true</span> : <span class="kw">true</span>)<span class="op">;</span>    <span class="co">// false</span>
(<span class="kw">true</span> <span class="op">?</span> <span class="kw">false</span> : <span class="kw">true</span>) <span class="op">?</span> <span class="kw">true</span> : <span class="kw">true</span><span class="op">;</span>    <span class="co">// true</span></code></pre></div>
<p>Even more nuanced differences lurk with other value combinations, even if the end result is the same. Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">true</span> <span class="op">?</span> <span class="kw">false</span> : <span class="kw">true</span> <span class="op">?</span> <span class="kw">true</span> : <span class="kw">false</span><span class="op">;</span>     <span class="co">// false</span>

<span class="kw">true</span> <span class="op">?</span> <span class="kw">false</span> : (<span class="kw">true</span> <span class="op">?</span> <span class="kw">true</span> : <span class="kw">false</span>)<span class="op">;</span>   <span class="co">// false</span>
(<span class="kw">true</span> <span class="op">?</span> <span class="kw">false</span> : <span class="kw">true</span>) <span class="op">?</span> <span class="kw">true</span> : <span class="kw">false</span><span class="op">;</span>   <span class="co">// false</span></code></pre></div>
<p>From that scenario, the same end result implies that the grouping is moot. However:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">true</span><span class="op">,</span> b <span class="op">=</span> <span class="kw">false</span><span class="op">,</span> c <span class="op">=</span> <span class="kw">true</span><span class="op">,</span> d <span class="op">=</span> <span class="kw">true</span><span class="op">,</span> e <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>

a <span class="op">?</span> b : (c <span class="op">?</span> d : e)<span class="op">;</span> <span class="co">// false, evaluates only `a` and `b`</span>
(a <span class="op">?</span> b : c) <span class="op">?</span> d : e<span class="op">;</span> <span class="co">// false, evaluates `a`, `b` AND `e`</span></code></pre></div>
<p>So, we've clearly proved that <code>? :</code> is right-associative, and that it actually matters with respect to how the operator behaves if chained with itself.</p>
<p>Another example of right-associativity (grouping) is the <code>=</code> operator. Recall the chained assignment example from earlier in the chapter:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span>

a <span class="op">=</span> b <span class="op">=</span> c <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></code></pre></div>
<p>We asserted earlier that <code>a = b = c = 42</code> is processed by first evaluating the <code>c = 42</code> assignment, then <code>b = ..</code>, and finally <code>a = ..</code>. Why? Because of the right-associativity, which actually treats the statement like this: <code>a = (b = (c = 42))</code>.</p>
<p>Remember our running complex assignment expression example from earlier in the chapter?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>

<span class="kw">var</span> d <span class="op">=</span> a <span class="op">&amp;&amp;</span> b <span class="op">||</span> c <span class="op">?</span> c <span class="op">||</span> b <span class="op">?</span> a : c <span class="op">&amp;&amp;</span> b : a<span class="op">;</span>

d<span class="op">;</span>      <span class="co">// 42</span></code></pre></div>
<p>Armed with our knowledge of precedence and associativity, we should now be able to break down the code into its grouping behavior like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">((a <span class="op">&amp;&amp;</span> b) <span class="op">||</span> c) <span class="op">?</span> ((c <span class="op">||</span> b) <span class="op">?</span> a : (c <span class="op">&amp;&amp;</span> b)) : a</code></pre></div>
<p>Or, to present it indented if that's easier to understand:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">(
  (a <span class="op">&amp;&amp;</span> b)
    <span class="op">||</span>
  c
)
  <span class="op">?</span>
(
  (c <span class="op">||</span> b)
    <span class="op">?</span>
  a
    :
  (c <span class="op">&amp;&amp;</span> b)
)
  :
a</code></pre></div>
<p>Let's solve it now:</p>
<ol type="1">
<li><code>(a &amp;&amp; b)</code> is <code>&quot;foo&quot;</code>.</li>
<li><code>&quot;foo&quot; || c</code> is <code>&quot;foo&quot;</code>.</li>
<li>For the first <code>?</code> test, <code>&quot;foo&quot;</code> is truthy.</li>
<li><code>(c || b)</code> is <code>&quot;foo&quot;</code>.</li>
<li>For the second <code>?</code> test, <code>&quot;foo&quot;</code> is truthy.</li>
<li><code>a</code> is <code>42</code>.</li>
</ol>
<p>That's it, we're done! The answer is <code>42</code>, just as we saw earlier. That actually wasn't so hard, was it?</p>
<h3 id="disambiguation">Disambiguation</h3>
<p>You should now have a much better grasp on operator precedence (and associativity) and feel much more comfortable understanding how code with multiple chained operators will behave.</p>
<p>But an important question remains: should we all write code understanding and perfectly relying on all the rules of operator precedence/associativity? Should we only use <code>( )</code> manual grouping when it's necessary to force a different processing binding/order?</p>
<p>Or, on the other hand, should we recognize that even though such rules <em>are in fact</em> learnable, there's enough gotchas to warrant ignoring automatic precedence/associativity? If so, should we thus always use <code>( )</code> manual grouping and remove all reliance on these automatic behaviors?</p>
<p>This debate is highly subjective, and heavily symmetrical to the debate in Chapter 4 over <em>implicit</em> coercion. Most developers feel the same way about both debates: either they accept both behaviors and code expecting them, or they discard both behaviors and stick to manual/explicit idioms.</p>
<p>Of course, I cannot answer this question definitively for the reader here anymore than I could in Chapter 4. But I've presented you the pros and cons, and hopefully encouraged enough deeper understanding that you can make informed rather than hype-driven decisions.</p>
<p>In my opinion, there's an important middle ground. We should mix both operator precedence/associativity <em>and</em> <code>( )</code> manual grouping into our programs -- I argue the same way in Chapter 4 for healthy/safe usage of <em>implicit</em> coercion, but certainly don't endorse it exclusively without bounds.</p>
<p>For example, <code>if (a &amp;&amp; b &amp;&amp; c) ..</code> is perfectly OK to me, and I wouldn't do <code>if ((a &amp;&amp; b) &amp;&amp; c) ..</code> just to explicitly call out the associativity, because I think it's overly verbose.</p>
<p>On the other hand, if I needed to chain two <code>? :</code> conditional operators together, I'd certainly use <code>( )</code> manual grouping to make it absolutely clear what my intended logic is.</p>
<p>Thus, my advice here is similar to that of Chapter 4: <strong>use operator precedence/associativity where it leads to shorter and cleaner code, but use <code>( )</code> manual grouping in places where it helps create clarity and reduce confusion.</strong></p>
<h2 id="automatic-semicolons">Automatic Semicolons</h2>
<p>ASI (Automatic Semicolon Insertion) is when JavaScript assumes a <code>;</code> in certain places in your JS program even if you didn't put one there.</p>
<p>Why would it do that? Because if you omit even a single required <code>;</code> your program would fail. Not very forgiving. ASI allows JS to be tolerant of certain places where <code>;</code> aren't commonly thought to be necessary.</p>
<p>It's important to note that ASI will only take effect in the presence of a newline (aka line break). Semicolons are not inserted in the middle of a line.</p>
<p>Basically, if the JS parser parses a line where a parser error would occur (a missing expected <code>;</code>), and it can reasonably insert one, it does so. What's reasonable for insertion? Only if there's nothing but whitespace and/or comments between the end of some statement and that line's newline/line break.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">,</span> b
c<span class="op">;</span></code></pre></div>
<p>Should JS treat the <code>c</code> on the next line as part of the <code>var</code> statement? It certainly would if a <code>,</code> had come anywhere (even another line) between <code>b</code> and <code>c</code>. But since there isn't one, JS assumes instead that there's an implied <code>;</code> (at the newline) after <code>b</code>. Thus, <code>c;</code> is left as a standalone expression statement.</p>
<p>Similarly:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">,</span> b <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>

a
b   <span class="co">// &quot;foo&quot;</span></code></pre></div>
<p>That's still a valid program without error, because expression statements also accept ASI.</p>
<p>There's certain places where ASI is helpful, like for instance:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>

<span class="cf">do</span> <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span> <span class="cf">while</span> (a) <span class="co">// &lt;-- ; expected here!</span>
a<span class="op">;</span></code></pre></div>
<p>The grammar requires a <code>;</code> after a <code>do..while</code> loop, but not after <code>while</code> or <code>for</code> loops. But most developers don't remember that! So, ASI helpfully steps in and inserts one.</p>
<p>As we said earlier in the chapter, statement blocks do not require <code>;</code> termination, so ASI isn't necessary:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>

<span class="cf">while</span> (a) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span> <span class="co">// &lt;-- no ; expected here</span>
a<span class="op">;</span></code></pre></div>
<p>The other major case where ASI kicks in is with the <code>break</code>, <code>continue</code>, <code>return</code>, and (ES6) <code>yield</code> keywords:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a) <span class="op">{</span>
    <span class="cf">if</span> (<span class="op">!</span>a) <span class="cf">return</span>
    a <span class="op">*=</span> <span class="dv">2</span><span class="op">;</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>The <code>return</code> statement doesn't carry across the newline to the <code>a *= 2</code> expression, as ASI assumes the <code>;</code> terminating the <code>return</code> statement. Of course, <code>return</code> statements <em>can</em> easily break across multiple lines, just not when there's nothing after <code>return</code> but the newline/line break.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a) <span class="op">{</span>
    <span class="cf">return</span> (
        a <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span> / <span class="dv">12</span>
    )<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Identical reasoning applies to <code>break</code>, <code>continue</code>, and <code>yield</code>.</p>
<h3 id="error-correction">Error Correction</h3>
<p>One of the most hotly contested <em>religious wars</em> in the JS community (besides tabs vs. spaces) is whether to rely heavily/exclusively on ASI or not.</p>
<p>Most, but not all, semicolons are optional, but the two <code>;</code>s in the <code>for ( .. ) ..</code> loop header are required.</p>
<p>On the pro side of this debate, many developers believe that ASI is a useful mechanism that allows them to write more terse (and more &quot;beautiful&quot;) code by omitting all but the strictly required <code>;</code>s (which are very few). It is often asserted that ASI makes many <code>;</code>s optional, so a correctly written program <em>without them</em> is no different than a correctly written program <em>with them</em>.</p>
<p>On the con side of the debate, many other developers will assert that there are <em>too many</em> places that can be accidental gotchas, especially for newer, less experienced developers, where unintended <code>;</code>s being magically inserted change the meaning. Similarly, some developers will argue that if they omit a semicolon, it's a flat-out mistake, and they want their tools (linters, etc.) to catch it before the JS engine <em>corrects</em> the mistake under the covers.</p>
<p>Let me just share my perspective. A strict reading of the spec implies that ASI is an &quot;error correction&quot; routine. What kind of error, you may ask? Specifically, a <strong>parser error</strong>. In other words, in an attempt to have the parser fail less, ASI lets it be more tolerant.</p>
<p>But tolerant of what? In my view, the only way a <strong>parser error</strong> occurs is if it's given an incorrect/errored program to parse. So, while ASI is strictly correcting parser errors, the only way it can get such errors is if there were first program authoring errors -- omitting semicolons where the grammar rules require them.</p>
<p>So, to put it more bluntly, when I hear someone claim that they want to omit &quot;optional semicolons,&quot; my brain translates that claim to &quot;I want to write the most parser-broken program I can that will still work.&quot;</p>
<p>I find that to be a ludicrous position to take and the arguments of saving keystrokes and having more &quot;beautiful code&quot; to be weak at best.</p>
<p>Furthermore, I don't agree that this is the same thing as the spaces vs tabs debate -- that it's purely cosmetic -- but rather I believe it's a fundamental question of writing code that adheres to grammar requirements vs. code that relies on grammar exceptions to just barely skate through.</p>
<p>Another way of looking at it is that relying on ASI is essentially considering newlines to be significant &quot;whitespace.&quot; Other languages like Python have true significant whitespace. But is it really appropriate to think of JavaScript as having significant newlines as it stands today?</p>
<p>My take: <strong>use semicolons wherever you know they are &quot;required,&quot; and limit your assumptions about ASI to a minimum.</strong></p>
<p>But don't just take my word for it. Back in 2012, creator of JavaScript Brendan Eich said (http://brendaneich.com/2012/04/the-infernal-semicolon/) the following:</p>
<blockquote>
<p>The moral of this story: ASI is (formally speaking) a syntactic error correction procedure. If you start to code as if it were a universal significant-newline rule, you will get into trouble. .. I wish I had made newlines more significant in JS back in those ten days in May, 1995. .. Be careful not to use ASI as if it gave JS significant newlines.</p>
</blockquote>
<h2 id="errors">Errors</h2>
<p>Not only does JavaScript have different <em>subtypes</em> of errors (<code>TypeError</code>, <code>ReferenceError</code>, <code>SyntaxError</code>, etc.), but also the grammar defines certain errors to be enforced at compile time, as compared to all other errors that happen during runtime.</p>
<p>In particular, there have long been a number of specific conditions that should be caught and reported as &quot;early errors&quot; (during compilation). Any straight-up syntax error is an early error (e.g., <code>a = ,</code>), but also the grammar defines things that are syntactically valid but disallowed nonetheless.</p>
<p>Since execution of your code has not begun yet, these errors are not catchable with <code>try..catch</code>; they will just fail the parsing/compilation of your program.</p>
<p><strong>Tip:</strong> There's no requirement in the spec about exactly how browsers (and developer tools) should report errors. So you may see variations across browsers in the following error examples, in what specific subtype of error is reported or what the included error message text will be.</p>
<p>One simple example is with syntax inside a regular expression literal. There's nothing wrong with the JS syntax here, but the invalid regex will throw an early error:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="ss">/</span><span class="sc">+</span><span class="ss">foo/</span><span class="op">;</span>     <span class="co">// Error!</span></code></pre></div>
<p>The target of an assignment must be an identifier (or an ES6 destructuring expression that produces one or more identifiers), so a value like <code>42</code> in that position is illegal and can be reported right away:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a<span class="op">;</span>
<span class="dv">42</span> <span class="op">=</span> a<span class="op">;</span>     <span class="co">// Error!</span></code></pre></div>
<p>ES5's <code>strict</code> mode defines even more early errors. For example, in <code>strict</code> mode, function parameter names cannot be duplicated:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a<span class="op">,</span>b<span class="op">,</span>a) <span class="op">{</span> <span class="op">}</span>                 <span class="co">// just fine</span>

<span class="kw">function</span> <span class="at">bar</span>(a<span class="op">,</span>b<span class="op">,</span>a) <span class="op">{</span> <span class="st">&quot;use strict&quot;</span><span class="op">;</span> <span class="op">}</span>   <span class="co">// Error!</span></code></pre></div>
<p>Another <code>strict</code> mode early error is an object literal having more than one property of the same name:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">(<span class="kw">function</span>()<span class="op">{</span>
    <span class="st">&quot;use strict&quot;</span><span class="op">;</span>

    <span class="kw">var</span> a <span class="op">=</span> <span class="op">{</span>
        <span class="dt">b</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span>
        <span class="dt">b</span><span class="op">:</span> <span class="dv">43</span>
    <span class="op">};</span>          <span class="co">// Error!</span>
<span class="op">}</span>)()<span class="op">;</span></code></pre></div>
<p><strong>Note:</strong> Semantically speaking, such errors aren't technically <em>syntax</em> errors but more <em>grammar</em> errors -- the above snippets are syntactically valid. But since there is no <code>GrammarError</code> type, some browsers use <code>SyntaxError</code> instead.</p>
<h3 id="using-variables-too-early">Using Variables Too Early</h3>
<p>ES6 defines a (frankly confusingly named) new concept called the TDZ (&quot;Temporal Dead Zone&quot;).</p>
<p>The TDZ refers to places in code where a variable reference cannot yet be made, because it hasn't reached its required initialization.</p>
<p>The most clear example of this is with ES6 <code>let</code> block-scoping:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">{</span>
    a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>      <span class="co">// ReferenceError!</span>
    <span class="kw">let</span> a<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>The assignment <code>a = 2</code> is accessing the <code>a</code> variable (which is indeed block-scoped to the <code>{ .. }</code> block) before it's been initialized by the <code>let a</code> declaration, so it's in the TDZ for <code>a</code> and throws an error.</p>
<p>Interestingly, while <code>typeof</code> has an exception to be safe for undeclared variables (see Chapter 1), no such safety exception is made for TDZ references:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">{</span>
    <span class="kw">typeof</span> a<span class="op">;</span>   <span class="co">// undefined</span>
    <span class="kw">typeof</span> b<span class="op">;</span>   <span class="co">// ReferenceError! (TDZ)</span>
    <span class="kw">let</span> b<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<h2 id="function-arguments">Function Arguments</h2>
<p>Another example of a TDZ violation can be seen with ES6 default parameter values (see the <em>ES6 &amp; Beyond</em> title of this series):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> b <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>

<span class="kw">function</span> <span class="at">foo</span>( a <span class="op">=</span> <span class="dv">42</span><span class="op">,</span> b <span class="op">=</span> a <span class="op">+</span> b <span class="op">+</span> <span class="dv">5</span> ) <span class="op">{</span>
    <span class="co">// ..</span>
<span class="op">}</span></code></pre></div>
<p>The <code>b</code> reference in the assignment would happen in the TDZ for the parameter <code>b</code> (not pull in the outer <code>b</code> reference), so it will throw an error. However, the <code>a</code> in the assignment is fine since by that time it's past the TDZ for parameter <code>a</code>.</p>
<p>When using ES6's default parameter values, the default value is applied to the parameter if you either omit an argument, or you pass an <code>undefined</code> value in its place:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>( a <span class="op">=</span> <span class="dv">42</span><span class="op">,</span> b <span class="op">=</span> a <span class="op">+</span> <span class="dv">1</span> ) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( a<span class="op">,</span> b )<span class="op">;</span>
<span class="op">}</span>

<span class="at">foo</span>()<span class="op">;</span>                  <span class="co">// 42 43</span>
<span class="at">foo</span>( <span class="kw">undefined</span> )<span class="op">;</span>       <span class="co">// 42 43</span>
<span class="at">foo</span>( <span class="dv">5</span> )<span class="op">;</span>               <span class="co">// 5 6</span>
<span class="at">foo</span>( <span class="kw">void</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">7</span> )<span class="op">;</span>       <span class="co">// 42 7</span>
<span class="at">foo</span>( <span class="kw">null</span> )<span class="op">;</span>            <span class="co">// null 1</span></code></pre></div>
<p><strong>Note:</strong> <code>null</code> is coerced to a <code>0</code> value in the <code>a + 1</code> expression. See Chapter 4 for more info.</p>
<p>From the ES6 default parameter values perspective, there's no difference between omitting an argument and passing an <code>undefined</code> value. However, there is a way to detect the difference in some cases:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>( a <span class="op">=</span> <span class="dv">42</span><span class="op">,</span> b <span class="op">=</span> a <span class="op">+</span> <span class="dv">1</span> ) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>(
        <span class="va">arguments</span>.<span class="at">length</span><span class="op">,</span> a<span class="op">,</span> b<span class="op">,</span>
        arguments[<span class="dv">0</span>]<span class="op">,</span> arguments[<span class="dv">1</span>]
    )<span class="op">;</span>
<span class="op">}</span>

<span class="at">foo</span>()<span class="op">;</span>                  <span class="co">// 0 42 43 undefined undefined</span>
<span class="at">foo</span>( <span class="dv">10</span> )<span class="op">;</span>              <span class="co">// 1 10 11 10 undefined</span>
<span class="at">foo</span>( <span class="dv">10</span><span class="op">,</span> <span class="kw">undefined</span> )<span class="op">;</span>   <span class="co">// 2 10 11 10 undefined</span>
<span class="at">foo</span>( <span class="dv">10</span><span class="op">,</span> <span class="kw">null</span> )<span class="op">;</span>        <span class="co">// 2 10 null 10 null</span></code></pre></div>
<p>Even though the default parameter values are applied to the <code>a</code> and <code>b</code> parameters, if no arguments were passed in those slots, the <code>arguments</code> array will not have entries.</p>
<p>Conversely, if you pass an <code>undefined</code> argument explicitly, an entry will exist in the <code>arguments</code> array for that argument, but it will be <code>undefined</code> and not (necessarily) the same as the default value that was applied to the named parameter for that same slot.</p>
<p>While ES6 default parameter values can create divergence between the <code>arguments</code> array slot and the corresponding named parameter variable, this same disjointedness can also occur in tricky ways in ES5:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a) <span class="op">{</span>
    a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
    <span class="va">console</span>.<span class="at">log</span>( arguments[<span class="dv">0</span>] )<span class="op">;</span>
<span class="op">}</span>

<span class="at">foo</span>( <span class="dv">2</span> )<span class="op">;</span>   <span class="co">// 42 (linked)</span>
<span class="at">foo</span>()<span class="op">;</span>      <span class="co">// undefined (not linked)</span></code></pre></div>
<p>If you pass an argument, the <code>arguments</code> slot and the named parameter are linked to always have the same value. If you omit the argument, no such linkage occurs.</p>
<p>But in <code>strict</code> mode, the linkage doesn't exist regardless:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a) <span class="op">{</span>
    <span class="st">&quot;use strict&quot;</span><span class="op">;</span>
    a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>
    <span class="va">console</span>.<span class="at">log</span>( arguments[<span class="dv">0</span>] )<span class="op">;</span>
<span class="op">}</span>

<span class="at">foo</span>( <span class="dv">2</span> )<span class="op">;</span>   <span class="co">// 2 (not linked)</span>
<span class="at">foo</span>()<span class="op">;</span>      <span class="co">// undefined (not linked)</span></code></pre></div>
<p>It's almost certainly a bad idea to ever rely on any such linkage, and in fact the linkage itself is a leaky abstraction that's exposing an underlying implementation detail of the engine, rather than a properly designed feature.</p>
<p>Use of the <code>arguments</code> array has been deprecated (especially in favor of ES6 <code>...</code> rest parameters -- see the <em>ES6 &amp; Beyond</em> title of this series), but that doesn't mean that it's all bad.</p>
<p>Prior to ES6, <code>arguments</code> is the only way to get an array of all passed arguments to pass along to other functions, which turns out to be quite useful. You can also mix named parameters with the <code>arguments</code> array and be safe, as long as you follow one simple rule: <strong>never refer to a named parameter <em>and</em> its corresponding <code>arguments</code> slot at the same time.</strong> If you avoid that bad practice, you'll never expose the leaky linkage behavior.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>( a <span class="op">+</span> arguments[<span class="dv">1</span>] )<span class="op">;</span> <span class="co">// safe!</span>
<span class="op">}</span>

<span class="at">foo</span>( <span class="dv">10</span><span class="op">,</span> <span class="dv">32</span> )<span class="op">;</span>  <span class="co">// 42</span></code></pre></div>
<h2 id="try..finally"><code>try..finally</code></h2>
<p>You're probably familiar with how the <code>try..catch</code> block works. But have you ever stopped to consider the <code>finally</code> clause that can be paired with it? In fact, were you aware that <code>try</code> only requires either <code>catch</code> or <code>finally</code>, though both can be present if needed.</p>
<p>The code in the <code>finally</code> clause <em>always</em> runs (no matter what), and it always runs right after the <code>try</code> (and <code>catch</code> if present) finish, before any other code runs. In one sense, you can kind of think of the code in a <code>finally</code> clause as being in a callback function that will always be called regardless of how the rest of the block behaves.</p>
<p>So what happens if there's a <code>return</code> statement inside a <code>try</code> clause? It obviously will return a value, right? But does the calling code that receives that value run before or after the <code>finally</code>?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="cf">try</span> <span class="op">{</span>
        <span class="cf">return</span> <span class="dv">42</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">finally</span> <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Hello&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>

    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;never runs&quot;</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="va">console</span>.<span class="at">log</span>( <span class="at">foo</span>() )<span class="op">;</span>
<span class="co">// Hello</span>
<span class="co">// 42</span></code></pre></div>
<p>The <code>return 42</code> runs right away, which sets up the completion value from the <code>foo()</code> call. This action completes the <code>try</code> clause and the <code>finally</code> clause immediately runs next. Only then is the <code>foo()</code> function complete, so that its completion value is returned back for the <code>console.log(..)</code> statement to use.</p>
<p>The exact same behavior is true of a <code>throw</code> inside <code>try</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"> <span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="cf">try</span> <span class="op">{</span>
        <span class="cf">throw</span> <span class="dv">42</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">finally</span> <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Hello&quot;</span> )<span class="op">;</span>
    <span class="op">}</span>

    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;never runs&quot;</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="va">console</span>.<span class="at">log</span>( <span class="at">foo</span>() )<span class="op">;</span>
<span class="co">// Hello</span>
<span class="co">// Uncaught Exception: 42</span></code></pre></div>
<p>Now, if an exception is thrown (accidentally or intentionally) inside a <code>finally</code> clause, it will override as the primary completion of that function. If a previous <code>return</code> in the <code>try</code> block had set a completion value for the function, that value will be abandoned.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="cf">try</span> <span class="op">{</span>
        <span class="cf">return</span> <span class="dv">42</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">finally</span> <span class="op">{</span>
        <span class="cf">throw</span> <span class="st">&quot;Oops!&quot;</span><span class="op">;</span>
    <span class="op">}</span>

    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;never runs&quot;</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="va">console</span>.<span class="at">log</span>( <span class="at">foo</span>() )<span class="op">;</span>
<span class="co">// Uncaught Exception: Oops!</span></code></pre></div>
<p>It shouldn't be surprising that other nonlinear control statements like <code>continue</code> and <code>break</code> exhibit similar behavior to <code>return</code> and <code>throw</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">for</span> (<span class="kw">var</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="dv">10</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="cf">try</span> <span class="op">{</span>
        <span class="cf">continue</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">finally</span> <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>( i )<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>
<span class="co">// 0 1 2 3 4 5 6 7 8 9</span></code></pre></div>
<p>The <code>console.log(i)</code> statement runs at the end of the loop iteration, which is caused by the <code>continue</code> statement. However, it still runs before the <code>i++</code> iteration update statement, which is why the values printed are <code>0..9</code> instead of <code>1..10</code>.</p>
<p><strong>Note:</strong> ES6 adds a <code>yield</code> statement, in generators (see the <em>Async &amp; Performance</em> title of this series) which in some ways can be seen as an intermediate <code>return</code> statement. However, unlike a <code>return</code>, a <code>yield</code> isn't complete until the generator is resumed, which means a <code>try { .. yield .. }</code> has not completed. So an attached <code>finally</code> clause will not run right after the <code>yield</code> like it does with <code>return</code>.</p>
<p>A <code>return</code> inside a <code>finally</code> has the special ability to override a previous <code>return</code> from the <code>try</code> or <code>catch</code> clause, but only if <code>return</code> is explicitly called:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="cf">try</span> <span class="op">{</span>
        <span class="cf">return</span> <span class="dv">42</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">finally</span> <span class="op">{</span>
        <span class="co">// no `return ..` here, so no override</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">bar</span>() <span class="op">{</span>
    <span class="cf">try</span> <span class="op">{</span>
        <span class="cf">return</span> <span class="dv">42</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">finally</span> <span class="op">{</span>
        <span class="co">// override previous `return 42`</span>
        <span class="cf">return</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">baz</span>() <span class="op">{</span>
    <span class="cf">try</span> <span class="op">{</span>
        <span class="cf">return</span> <span class="dv">42</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">finally</span> <span class="op">{</span>
        <span class="co">// override previous `return 42`</span>
        <span class="cf">return</span> <span class="st">&quot;Hello&quot;</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="at">foo</span>()<span class="op">;</span>  <span class="co">// 42</span>
<span class="at">bar</span>()<span class="op">;</span>  <span class="co">// undefined</span>
<span class="at">baz</span>()<span class="op">;</span>  <span class="co">// &quot;Hello&quot;</span></code></pre></div>
<p>Normally, the omission of <code>return</code> in a function is the same as <code>return;</code> or even <code>return undefined;</code>, but inside a <code>finally</code> block the omission of <code>return</code> does not act like an overriding <code>return undefined</code>; it just lets the previous <code>return</code> stand.</p>
<p>In fact, we can really up the craziness if we combine <code>finally</code> with labeled <code>break</code> (discussed earlier in the chapter):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span>
    <span class="dt">bar</span><span class="op">:</span> <span class="op">{</span>
        <span class="cf">try</span> <span class="op">{</span>
            <span class="cf">return</span> <span class="dv">42</span><span class="op">;</span>
        <span class="op">}</span>
        <span class="cf">finally</span> <span class="op">{</span>
            <span class="co">// break out of `bar` labeled block</span>
            <span class="cf">break</span> bar<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Crazy&quot;</span> )<span class="op">;</span>

    <span class="cf">return</span> <span class="st">&quot;Hello&quot;</span><span class="op">;</span>
<span class="op">}</span>

<span class="va">console</span>.<span class="at">log</span>( <span class="at">foo</span>() )<span class="op">;</span>
<span class="co">// Crazy</span>
<span class="co">// Hello</span></code></pre></div>
<p>But... don't do this. Seriously. Using a <code>finally</code> + labeled <code>break</code> to effectively cancel a <code>return</code> is doing your best to create the most confusing code possible. I'd wager no amount of comments will redeem this code.</p>
<h2 id="switch"><code>switch</code></h2>
<p>Let's briefly explore the <code>switch</code> statement, a sort-of syntactic shorthand for an <code>if..else if..else..</code> statement chain.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">switch</span> (a) <span class="op">{</span>
    <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span>
        <span class="co">// do something</span>
        <span class="cf">break</span><span class="op">;</span>
    <span class="cf">case</span> <span class="dv">42</span><span class="op">:</span>
        <span class="co">// do another thing</span>
        <span class="cf">break</span><span class="op">;</span>
    <span class="dt">default</span><span class="op">:</span>
        <span class="co">// fallback to here</span>
<span class="op">}</span></code></pre></div>
<p>As you can see, it evaluates <code>a</code> once, then matches the resulting value to each <code>case</code> expression (just simple value expressions here). If a match is found, execution will begin in that matched <code>case</code>, and will either go until a <code>break</code> is encountered or until the end of the <code>switch</code> block is found.</p>
<p>That much may not surprise you, but there are several quirks about <code>switch</code> you may not have noticed before.</p>
<p>First, the matching that occurs between the <code>a</code> expression and each <code>case</code> expression is identical to the <code>===</code> algorithm (see Chapter 4). Often times <code>switch</code>es are used with absolute values in <code>case</code> statements, as shown above, so strict matching is appropriate.</p>
<p>However, you may wish to allow coercive equality (aka <code>==</code>, see Chapter 4), and to do so you'll need to sort of &quot;hack&quot; the <code>switch</code> statement a bit:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">;</span>

<span class="cf">switch</span> (<span class="kw">true</span>) <span class="op">{</span>
    <span class="cf">case</span> a <span class="op">==</span> <span class="dv">10</span><span class="op">:</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;10 or &#39;10&#39;&quot;</span> )<span class="op">;</span>
        <span class="cf">break</span><span class="op">;</span>
    <span class="cf">case</span> a <span class="op">==</span> <span class="dv">42</span><span class="op">:</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;42 or &#39;42&#39;&quot;</span> )<span class="op">;</span>
        <span class="cf">break</span><span class="op">;</span>
    <span class="dt">default</span><span class="op">:</span>
        <span class="co">// never gets here</span>
<span class="op">}</span>
<span class="co">// 42 or &#39;42&#39;</span></code></pre></div>
<p>This works because the <code>case</code> clause can have any expression (not just simple values), which means it will strictly match that expression's result to the test expression (<code>true</code>). Since <code>a == 42</code> results in <code>true</code> here, the match is made.</p>
<p>Despite <code>==</code>, the <code>switch</code> matching itself is still strict, between <code>true</code> and <code>true</code> here. If the <code>case</code> expression resulted in something that was truthy but not strictly <code>true</code> (see Chapter 4), it wouldn't work. This can bite you if you're for instance using a &quot;logical operator&quot; like <code>||</code> or <code>&amp;&amp;</code> in your expression:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="st">&quot;hello world&quot;</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>

<span class="cf">switch</span> (<span class="kw">true</span>) <span class="op">{</span>
    <span class="cf">case</span> (a <span class="op">||</span> b <span class="op">==</span> <span class="dv">10</span>)<span class="op">:</span>
        <span class="co">// never gets here</span>
        <span class="cf">break</span><span class="op">;</span>
    <span class="dt">default</span><span class="op">:</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;Oops&quot;</span> )<span class="op">;</span>
<span class="op">}</span>
<span class="co">// Oops</span></code></pre></div>
<p>Since the result of <code>(a || b == 10)</code> is <code>&quot;hello world&quot;</code> and not <code>true</code>, the strict match fails. In this case, the fix is to force the expression explicitly to be a <code>true</code> or <code>false</code>, such as <code>case !!(a || b == 10):</code> (see Chapter 4).</p>
<p>Lastly, the <code>default</code> clause is optional, and it doesn't necessarily have to come at the end (although that's the strong convention). Even in the <code>default</code> clause, the same rules apply about encountering a <code>break</code> or not:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>

<span class="cf">switch</span> (a) <span class="op">{</span>
    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span>
    <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span>
        <span class="co">// never gets here</span>
    <span class="dt">default</span><span class="op">:</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;default&quot;</span> )<span class="op">;</span>
    <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;3&quot;</span> )<span class="op">;</span>
        <span class="cf">break</span><span class="op">;</span>
    <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;4&quot;</span> )<span class="op">;</span>
<span class="op">}</span>
<span class="co">// default</span>
<span class="co">// 3</span></code></pre></div>
<p><strong>Note:</strong> As discussed previously about labeled <code>break</code>s, the <code>break</code> inside a <code>case</code> clause can also be labeled.</p>
<p>The way this snippet processes is that it passes through all the <code>case</code> clause matching first, finds no match, then goes back up to the <code>default</code> clause and starts executing. Since there's no <code>break</code> there, it continues executing in the already skipped over <code>case 3</code> block, before stopping once it hits that <code>break</code>.</p>
<p>While this sort of round-about logic is clearly possible in JavaScript, there's almost no chance that it's going to make for reasonable or understandable code. Be very skeptical if you find yourself wanting to create such circular logic flow, and if you really do, make sure you include plenty of code comments to explain what you're up to!</p>
<h2 id="review-4">Review</h2>
<p>JavaScript grammar has plenty of nuance that we as developers should spend a little more time paying closer attention to than we typically do. A little bit of effort goes a long way to solidifying your deeper knowledge of the language.</p>
<p>Statements and expressions have analogs in English language -- statements are like sentences and expressions are like phrases. Expressions can be pure/self-contained, or they can have side effects.</p>
<p>The JavaScript grammar layers semantic usage rules (aka context) on top of the pure syntax. For example, <code>{ }</code> pairs used in various places in your program can mean statement blocks, <code>object</code> literals, (ES6) destructuring assignments, or (ES6) named function arguments.</p>
<p>JavaScript operators all have well-defined rules for precedence (which ones bind first before others) and associativity (how multiple operator expressions are implicitly grouped). Once you learn these rules, it's up to you to decide if precedence/associativity are <em>too implicit</em> for their own good, or if they will aid in writing shorter, clearer code.</p>
<p>ASI (Automatic Semicolon Insertion) is a parser-error-correction mechanism built into the JS engine, which allows it under certain circumstances to insert an assumed <code>;</code> in places where it is required, was omitted, <em>and</em> where insertion fixes the parser error. The debate rages over whether this behavior implies that most <code>;</code> are optional (and can/should be omitted for cleaner code) or whether it means that omitting them is making mistakes that the JS engine merely cleans up for you.</p>
<p>JavaScript has several types of errors, but it's less known that it has two classifications for errors: &quot;early&quot; (compiler thrown, uncatchable) and &quot;runtime&quot; (<code>try..catch</code>able). All syntax errors are obviously early errors that stop the program before it runs, but there are others, too.</p>
<p>Function arguments have an interesting relationship to their formal declared named parameters. Specifically, the <code>arguments</code> array has a number of gotchas of leaky abstraction behavior if you're not careful. Avoid <code>arguments</code> if you can, but if you must use it, by all means avoid using the positional slot in <code>arguments</code> at the same time as using a named parameter for that same argument.</p>
<p>The <code>finally</code> clause attached to a <code>try</code> (or <code>try..catch</code>) offers some very interesting quirks in terms of execution processing order. Some of these quirks can be helpful, but it's possible to create lots of confusion, especially if combined with labeled blocks. As always, use <code>finally</code> to make code better and clearer, not more clever or confusing.</p>
<p>The <code>switch</code> offers some nice shorthand for <code>if..else if..</code> statements, but beware of many common simplifying assumptions about its behavior. There are several quirks that can trip you up if you're not careful, but there's also some neat hidden tricks that <code>switch</code> has up its sleeve!</p>
<h1 id="you-dont-know-js-types-grammar-6">You Don't Know JS: Types &amp; Grammar</h1>
<h1 id="appendix-a-mixed-environment-javascript">Appendix A: Mixed Environment JavaScript</h1>
<p>Beyond the core language mechanics we've fully explored in this book, there are several ways that your JS code can behave differently when it runs in the real world. If JS was executing purely inside an engine, it'd be entirely predictable based on nothing but the black-and-white of the spec. But JS pretty much always runs in the context of a hosting environment, which exposes your code to some degree of unpredictability.</p>
<p>For example, when your code runs alongside code from other sources, or when your code runs in different types of JS engines (not just browsers), there are some things that may behave differently.</p>
<p>We'll briefly explore some of these concerns.</p>
<h2 id="annex-b-ecmascript">Annex B (ECMAScript)</h2>
<p>It's a little known fact that the official name of the language is ECMAScript (referring to the ECMA standards body that manages it). What then is &quot;JavaScript&quot;? JavaScript is the common tradename of the language, of course, but more appropriately, JavaScript is basically the browser implementation of the spec.</p>
<p>The official ECMAScript specification includes &quot;Annex B,&quot; which discusses specific deviations from the official spec for the purposes of JS compatibility in browsers.</p>
<p>The proper way to consider these deviations is that they are only reliably present/valid if your code is running in a browser. If your code always runs in browsers, you won't see any observable difference. If not (like if it can run in node.js, Rhino, etc.), or you're not sure, tread carefully.</p>
<p>The main compatibility differences:</p>
<ul>
<li>Octal number literals are allowed, such as <code>0123</code> (decimal <code>83</code>) in non-<code>strict mode</code>.</li>
<li><code>window.escape(..)</code> and <code>window.unescape(..)</code> allow you to escape or unescape strings with <code>%</code>-delimited hexadecimal escape sequences. For example: <code>window.escape( &quot;?foo=97%&amp;bar=3%&quot; )</code> produces <code>&quot;%3Ffoo%3D97%25%26bar%3D3%25&quot;</code>.</li>
<li><code>String.prototype.substr</code> is quite similar to <code>String.prototype.substring</code>, except that instead of the second parameter being the ending index (noninclusive), the second parameter is the <code>length</code> (number of characters to include).</li>
</ul>
<h3 id="web-ecmascript">Web ECMAScript</h3>
<p>The Web ECMAScript specification (http://javascript.spec.whatwg.org/) covers the differences between the official ECMAScript specification and the current JavaScript implementations in browsers.</p>
<p>In other words, these items are &quot;required&quot; of browsers (to be compatible with each other) but are not (as of the time of writing) listed in the &quot;Annex B&quot; section of the official spec:</p>
<ul>
<li><code>&lt;!--</code> and <code>--&gt;</code> are valid single-line comment delimiters.</li>
<li><code>String.prototype</code> additions for returning HTML-formatted strings: <code>anchor(..)</code>, <code>big(..)</code>, <code>blink(..)</code>, <code>bold(..)</code>, <code>fixed(..)</code>, <code>fontcolor(..)</code>, <code>fontsize(..)</code>, <code>italics(..)</code>, <code>link(..)</code>, <code>small(..)</code>, <code>strike(..)</code>, and <code>sub(..)</code>. <strong>Note:</strong> These are very rarely used in practice, and are generally discouraged in favor of other built-in DOM APIs or user-defined utilities.</li>
<li><code>RegExp</code> extensions: <code>RegExp.$1</code> .. <code>RegExp.$9</code> (match-groups) and <code>RegExp.lastMatch</code>/<code>RegExp[&quot;$&amp;&quot;]</code> (most recent match).</li>
<li><code>Function.prototype</code> additions: <code>Function.prototype.arguments</code> (aliases internal <code>arguments</code> object) and <code>Function.caller</code> (aliases internal <code>arguments.caller</code>). <strong>Note:</strong> <code>arguments</code> and thus <code>arguments.caller</code> are deprecated, so you should avoid using them if possible. That goes doubly so for these aliases -- don't use them!</li>
</ul>
<p><strong>Note:</strong> Some other minor and rarely used deviations are not included in our list here. See the external &quot;Annex B&quot; and &quot;Web ECMAScript&quot; documents for more detailed information as needed.</p>
<p>Generally speaking, all these differences are rarely used, so the deviations from the specification are not significant concerns. <strong>Just be careful</strong> if you rely on any of them.</p>
<h2 id="host-objects">Host Objects</h2>
<p>The well-covered rules for how variables behave in JS have exceptions to them when it comes to variables that are auto-defined, or otherwise created and provided to JS by the environment that hosts your code (browser, etc.) -- so called, &quot;host objects&quot; (which include both built-in <code>object</code>s and <code>function</code>s).</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="va">document</span>.<span class="at">createElement</span>( <span class="st">&quot;div&quot;</span> )<span class="op">;</span>

<span class="kw">typeof</span> a<span class="op">;</span>                               <span class="co">// &quot;object&quot; -- as expected</span>
<span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>( a )<span class="op">;</span>    <span class="co">// &quot;[object HTMLDivElement]&quot;</span>

<span class="va">a</span>.<span class="at">tagName</span><span class="op">;</span>                              <span class="co">// &quot;DIV&quot;</span></code></pre></div>
<p><code>a</code> is not just an <code>object</code>, but a special host object because it's a DOM element. It has a different internal <code>[[Class]]</code> value (<code>&quot;HTMLDivElement&quot;</code>) and comes with predefined (and often unchangeable) properties.</p>
<p>Another such quirk has already been covered, in the &quot;Falsy Objects&quot; section in Chapter 4: some objects can exist but when coerced to <code>boolean</code> they (confoundingly) will coerce to <code>false</code> instead of the expected <code>true</code>.</p>
<p>Other behavior variations with host objects to be aware of can include:</p>
<ul>
<li>not having access to normal <code>object</code> built-ins like <code>toString()</code></li>
<li>not being overwritable</li>
<li>having certain predefined read-only properties</li>
<li>having methods that cannot be <code>this</code>-overriden to other objects</li>
<li>and more...</li>
</ul>
<p>Host objects are critical to making our JS code work with its surrounding environment. But it's important to note when you're interacting with a host object and be careful assuming its behaviors, as they will quite often not conform to regular JS <code>object</code>s.</p>
<p>One notable example of a host object that you probably interact with regularly is the <code>console</code> object and its various functions (<code>log(..)</code>, <code>error(..)</code>, etc.). The <code>console</code> object is provided by the <em>hosting environment</em> specifically so your code can interact with it for various development-related output tasks.</p>
<p>In browsers, <code>console</code> hooks up to the developer tools' console display, whereas in node.js and other server-side JS environments, <code>console</code> is generally connected to the standard-output (<code>stdout</code>) and standard-error (<code>stderr</code>) streams of the JavaScript environment system process.</p>
<h2 id="global-dom-variables">Global DOM Variables</h2>
<p>You're probably aware that declaring a variable in the global scope (with or without <code>var</code>) creates not only a global variable, but also its mirror: a property of the same name on the <code>global</code> object (<code>window</code> in the browser).</p>
<p>But what may be less common knowledge is that (because of legacy browser behavior) creating DOM elements with <code>id</code> attributes creates global variables of those same names. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;foo&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>And:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="kw">typeof</span> foo <span class="op">==</span> <span class="st">&quot;undefined&quot;</span>) <span class="op">{</span>
    foo <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>       <span class="co">// will never run</span>
<span class="op">}</span>

<span class="va">console</span>.<span class="at">log</span>( foo )<span class="op">;</span> <span class="co">// HTML element</span></code></pre></div>
<p>You're perhaps used to managing global variable tests (using <code>typeof</code> or <code>.. in window</code> checks) under the assumption that only JS code creates such variables, but as you can see, the contents of your hosting HTML page can also create them, which can easily throw off your existence check logic if you're not careful.</p>
<p>This is yet one more reason why you should, if at all possible, avoid using global variables, and if you have to, use variables with unique names that won't likely collide. But you also need to make sure not to collide with the HTML content as well as any other code.</p>
<h2 id="native-prototypes-1">Native Prototypes</h2>
<p>One of the most widely known and classic pieces of JavaScript <em>best practice</em> wisdom is: <strong>never extend native prototypes</strong>.</p>
<p>Whatever method or property name you come up with to add to <code>Array.prototype</code> that doesn't (yet) exist, if it's a useful addition and well-designed, and properly named, there's a strong chance it <em>could</em> eventually end up being added to the spec -- in which case your extension is now in conflict.</p>
<p>Here's a real example that actually happened to me that illustrates this point well.</p>
<p>I was building an embeddable widget for other websites, and my widget relied on jQuery (though pretty much any framework would have suffered this gotcha). It worked on almost every site, but we ran across one where it was totally broken.</p>
<p>After almost a week of analysis/debugging, I found that the site in question had, buried deep in one of its legacy files, code that looked like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Netscape 4 doesn&#39;t have Array.push</span>
<span class="va">Array</span>.<span class="va">prototype</span>.<span class="at">push</span> <span class="op">=</span> <span class="kw">function</span>(item) <span class="op">{</span>
    <span class="kw">this</span>[<span class="kw">this</span>.<span class="at">length</span>] <span class="op">=</span> item<span class="op">;</span>
<span class="op">};</span></code></pre></div>
<p>Aside from the crazy comment (who cares about Netscape 4 anymore!?), this looks reasonable, right?</p>
<p>The problem is, <code>Array.prototype.push</code> was added to the spec sometime subsequent to this Netscape 4 era coding, but what was added is not compatible with this code. The standard <code>push(..)</code> allows multiple items to be pushed at once. This hacked one ignores the subsequent items.</p>
<p>Basically all JS frameworks have code that relies on <code>push(..)</code> with multiple elements. In my case, it was code around the CSS selector engine that was completely busted. But there could conceivably be dozens of other places susceptible.</p>
<p>The developer who originally wrote that <code>push(..)</code> hack had the right instinct to call it <code>push</code>, but didn't foresee pushing multiple elements. They were certainly acting in good faith, but they created a landmine that didn't go off until almost 10 years later when I unwittingly came along.</p>
<p>There's multiple lessons to take away on all sides.</p>
<p>First, don't extend the natives unless you're absolutely sure your code is the only code that will ever run in that environment. If you can't say that 100%, then extending the natives is dangerous. You must weigh the risks.</p>
<p>Next, don't unconditionally define extensions (because you can overwrite natives accidentally). In this particular example, had the code said this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Array</span>.<span class="va">prototype</span>.<span class="at">push</span>) <span class="op">{</span>
    <span class="co">// Netscape 4 doesn&#39;t have Array.push</span>
    <span class="va">Array</span>.<span class="va">prototype</span>.<span class="at">push</span> <span class="op">=</span> <span class="kw">function</span>(item) <span class="op">{</span>
        <span class="kw">this</span>[<span class="kw">this</span>.<span class="at">length</span>] <span class="op">=</span> item<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p>The <code>if</code> statement guard would have only defined this hacked <code>push()</code> for JS environments where it didn't exist. In my case, that probably would have been OK. But even this approach is not without risk:</p>
<ol type="1">
<li>If the site's code (for some crazy reason!) was relying on a <code>push(..)</code> that ignored multiple items, that code would have been broken years ago when the standard <code>push(..)</code> was rolled out.</li>
<li>If any other library had come in and hacked in a <code>push(..)</code> ahead of this <code>if</code> guard, and it did so in an incompatible way, that would have broken the site at that time.</li>
</ol>
<p>What that highlights is an interesting question that, frankly, doesn't get enough attention from JS developers: <strong>Should you EVER rely on native built-in behavior</strong> if your code is running in any environment where it's not the only code present?</p>
<p>The strict answer is <strong>no</strong>, but that's awfully impractical. Your code usually can't redefine its own private untouchable versions of all built-in behavior relied on. Even if you <em>could</em>, that's pretty wasteful.</p>
<p>So, should you feature-test for the built-in behavior as well as compliance-testing that it does what you expect? And what if that test fails -- should your code just refuse to run?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// don&#39;t trust Array.prototype.push</span>
(<span class="kw">function</span>()<span class="op">{</span>
    <span class="cf">if</span> (<span class="va">Array</span>.<span class="va">prototype</span>.<span class="at">push</span>) <span class="op">{</span>
        <span class="kw">var</span> a <span class="op">=</span> []<span class="op">;</span>
        <span class="va">a</span>.<span class="at">push</span>(<span class="dv">1</span><span class="op">,</span><span class="dv">2</span>)<span class="op">;</span>
        <span class="cf">if</span> (a[<span class="dv">0</span>] <span class="op">===</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> a[<span class="dv">1</span>] <span class="op">===</span> <span class="dv">2</span>) <span class="op">{</span>
            <span class="co">// tests passed, safe to use!</span>
            <span class="cf">return</span><span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="cf">throw</span> <span class="at">Error</span>(
        <span class="st">&quot;Array#push() is missing/broken!&quot;</span>
    )<span class="op">;</span>
<span class="op">}</span>)()<span class="op">;</span></code></pre></div>
<p>In theory, that sounds plausible, but it's also pretty impractical to design tests for every single built-in method.</p>
<p>So, what should we do? Should we <em>trust but verify</em> (feature- and compliance-test) <strong>everything</strong>? Should we just assume existence is compliance and let breakage (caused by others) bubble up as it will?</p>
<p>There's no great answer. The only fact that can be observed is that extending native prototypes is the only way these things bite you.</p>
<p>If you don't do it, and no one else does in the code in your application, you're safe. Otherwise, you should build in at least a little bit of skepticism, pessimism, and expectation of possible breakage.</p>
<p>Having a full set of unit/regression tests of your code that runs in all known environments is one way to surface some of these issues earlier, but it doesn't do anything to actually protect you from these conflicts.</p>
<h3 id="shimspolyfills">Shims/Polyfills</h3>
<p>It's usually said that the only safe place to extend a native is in an older (non-spec-compliant) environment, since that's unlikely to ever change -- new browsers with new spec features replace older browsers rather than amending them.</p>
<p>If you could see into the future, and know for sure what a future standard was going to be, like for <code>Array.prototype.foobar</code>, it'd be totally safe to make your own compatible version of it to use now, right?</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="op">!</span><span class="va">Array</span>.<span class="va">prototype</span>.<span class="at">foobar</span>) <span class="op">{</span>
    <span class="co">// silly, silly</span>
    <span class="va">Array</span>.<span class="va">prototype</span>.<span class="at">foobar</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">push</span>( <span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="st">&quot;bar&quot;</span> )<span class="op">;</span>
    <span class="op">};</span>
<span class="op">}</span></code></pre></div>
<p>If there's already a spec for <code>Array.prototype.foobar</code>, and the specified behavior is equal to this logic, you're pretty safe in defining such a snippet, and in that case it's generally called a &quot;polyfill&quot; (or &quot;shim&quot;).</p>
<p>Such code is <strong>very</strong> useful to include in your code base to &quot;patch&quot; older browser environments that aren't updated to the newest specs. Using polyfills is a great way to create predictable code across all your supported environments.</p>
<p><strong>Tip:</strong> ES5-Shim (https://github.com/es-shims/es5-shim) is a comprehensive collection of shims/polyfills for bringing a project up to ES5 baseline, and similarly, ES6-Shim (https://github.com/es-shims/es6-shim) provides shims for new APIs added as of ES6. While APIs can be shimmed/polyfilled, new syntax generally cannot. To bridge the syntactic divide, you'll want to also use an ES6-to-ES5 transpiler like Traceur (https://github.com/google/traceur-compiler/wiki/Getting-Started).</p>
<p>If there's likely a coming standard, and most discussions agree what it's going to be called and how it will operate, creating the ahead-of-time polyfill for future-facing standards compliance is called &quot;prollyfill&quot; (probably-fill).</p>
<p>The real catch is if some new standard behavior can't be (fully) polyfilled/prollyfilled.</p>
<p>There's debate in the community if a partial-polyfill for the common cases is acceptable (documenting the parts that cannot be polyfilled), or if a polyfill should be avoided if it purely can't be 100% compliant to the spec.</p>
<p>Many developers at least accept some common partial polyfills (like for instance <code>Object.create(..)</code>), because the parts that aren't covered are not parts they intend to use anyway.</p>
<p>Some developers believe that the <code>if</code> guard around a polyfill/shim should include some form of conformance test, replacing the existing method either if it's absent or fails the tests. This extra layer of compliance testing is sometimes used to distinguish &quot;shim&quot; (compliance tested) from &quot;polyfill&quot; (existence checked).</p>
<p>The only absolute take-away is that there is no absolute <em>right</em> answer here. Extending natives, even when done &quot;safely&quot; in older environments, is not 100% safe. The same goes for relying upon (possibly extended) natives in the presence of others' code.</p>
<p>Either should always be done with caution, defensive code, and lots of obvious documentation about the risks.</p>
<h2 id="scripts"><code>&lt;script&gt;</code>s</h2>
<p>Most browser-viewed websites/applications have more than one file that contains their code, and it's common to have a few or several <code>&lt;script src=..&gt;&lt;/script&gt;</code> elements in the page that load these files separately, and even a few inline-code <code>&lt;script&gt; .. &lt;/script&gt;</code> elements as well.</p>
<p>But do these separate files/code snippets constitute separate programs or are they collectively one JS program?</p>
<p>The (perhaps surprising) reality is they act more like independent JS programs in most, but not all, respects.</p>
<p>The one thing they <em>share</em> is the single <code>global</code> object (<code>window</code> in the browser), which means multiple files can append their code to that shared namespace and they can all interact.</p>
<p>So, if one <code>script</code> element defines a global function <code>foo()</code>, when a second <code>script</code> later runs, it can access and call <code>foo()</code> just as if it had defined the function itself.</p>
<p>But global variable scope <em>hoisting</em> (see the <em>Scope &amp; Closures</em> title of this series) does not occur across these boundaries, so the following code would not work (because <code>foo()</code>'s declaration isn't yet declared), regardless of if they are (as shown) inline <code>&lt;script&gt; .. &lt;/script&gt;</code> elements or externally loaded <code>&lt;script src=..&gt;&lt;/script&gt;</code> files:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script&gt;</span><span class="at">foo</span>()<span class="op">;</span><span class="kw">&lt;/script&gt;</span>

<span class="kw">&lt;script&gt;</span>
  <span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span> .. <span class="op">}</span>
<span class="kw">&lt;/script&gt;</span></code></pre></div>
<p>But either of these <em>would</em> work instead:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script&gt;</span>
  <span class="at">foo</span>()<span class="op">;</span>
  <span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span> .. <span class="op">}</span>
<span class="kw">&lt;/script&gt;</span></code></pre></div>
<p>Or:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script&gt;</span>
  <span class="kw">function</span> <span class="at">foo</span>() <span class="op">{</span> .. <span class="op">}</span>
<span class="kw">&lt;/script&gt;</span>

<span class="kw">&lt;script&gt;</span><span class="at">foo</span>()<span class="op">;</span><span class="kw">&lt;/script&gt;</span></code></pre></div>
<p>Also, if an error occurs in a <code>script</code> element (inline or external), as a separate standalone JS program it will fail and stop, but any subsequent <code>script</code>s will run (still with the shared <code>global</code>) unimpeded.</p>
<p>You can create <code>script</code> elements dynamically from your code, and inject them into the DOM of the page, and the code in them will behave basically as if loaded normally in a separate file:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> greeting <span class="op">=</span> <span class="st">&quot;Hello World&quot;</span><span class="op">;</span>

<span class="kw">var</span> el <span class="op">=</span> <span class="va">document</span>.<span class="at">createElement</span>( <span class="st">&quot;script&quot;</span> )<span class="op">;</span>

<span class="va">el</span>.<span class="at">text</span> <span class="op">=</span> <span class="st">&quot;function foo(){ alert( greeting );\</span>
<span class="st"> } setTimeout( foo, 1000 );&quot;</span><span class="op">;</span>

<span class="va">document</span>.<span class="va">body</span>.<span class="at">appendChild</span>( el )<span class="op">;</span></code></pre></div>
<p><strong>Note:</strong> Of course, if you tried the above snippet but set <code>el.src</code> to some file URL instead of setting <code>el.text</code> to the code contents, you'd be dynamically creating an externally loaded <code>&lt;script src=..&gt;&lt;/script&gt;</code> element.</p>
<p>One difference between code in an inline code block and that same code in an external file is that in the inline code block, the sequence of characters <code>&lt;/script&gt;</code> cannot appear together, as (regardless of where it appears) it would be interpreted as the end of the code block. So, beware of code like:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script&gt;</span>
  <span class="kw">var</span> code <span class="op">=</span> <span class="st">&quot;&lt;script&gt;alert( &#39;Hello World&#39; )&lt;/script&gt;&quot;</span><span class="op">;</span>
<span class="kw">&lt;/script&gt;</span></code></pre></div>
<p>It looks harmless, but the <code>&lt;/script&gt;</code> appearing inside the <code>string</code> literal will terminate the script block abnormally, causing an error. The most common workaround is:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&quot;&lt;/sc&quot;</span> <span class="op">+</span> <span class="st">&quot;ript&gt;&quot;</span><span class="op">;</span></code></pre></div>
<p>Also, beware that code inside an external file will be interpreted in the character set (UTF-8, ISO-8859-8, etc.) the file is served with (or the default), but that same code in an inline <code>script</code> element in your HTML page will be interpreted by the character set of the page (or its default).</p>
<p><strong>Warning:</strong> The <code>charset</code> attribute will not work on inline script elements.</p>
<p>Another deprecated practice with inline <code>script</code> elements is including HTML-style or X(HT)ML-style comments around inline code, like:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script&gt;</span>
<span class="op">&lt;!--</span>
<span class="at">alert</span>( <span class="st">&quot;Hello&quot;</span> )<span class="op">;</span>
<span class="co">//--&gt;</span>
<span class="kw">&lt;/script&gt;</span>

<span class="kw">&lt;script&gt;</span>
<span class="op">&lt;!--</span><span class="co">//--&gt;&lt;![CDATA[//&gt;&lt;!--</span>
<span class="at">alert</span>( <span class="st">&quot;World&quot;</span> )<span class="op">;</span>
<span class="co">//--&gt;&lt;!]]&gt;</span>
<span class="kw">&lt;/script&gt;</span></code></pre></div>
<p>Both of these are totally unnecessary now, so if you're still doing that, stop it!</p>
<p><strong>Note:</strong> Both <code>&lt;!--</code> and <code>--&gt;</code> (HTML-style comments) are actually specified as valid single-line comment delimiters (<code>var x = 2; &lt;!-- valid comment</code> and <code>--&gt; another valid line comment</code>) in JavaScript (see the &quot;Web ECMAScript&quot; section earlier), purely because of this old technique. But never use them.</p>
<h2 id="reserved-words">Reserved Words</h2>
<p>The ES5 spec defines a set of &quot;reserved words&quot; in Section 7.6.1 that cannot be used as standalone variable names. Technically, there are four categories: &quot;keywords&quot;, &quot;future reserved words&quot;, the <code>null</code> literal, and the <code>true</code> / <code>false</code> boolean literals.</p>
<p>Keywords are the obvious ones like <code>function</code> and <code>switch</code>. Future reserved words include things like <code>enum</code>, though many of the rest of them (<code>class</code>, <code>extends</code>, etc.) are all now actually used by ES6; there are other strict-mode only reserved words like <code>interface</code>.</p>
<p>StackOverflow user &quot;art4theSould&quot; creatively worked all these reserved words into a fun little poem (http://stackoverflow.com/questions/26255/reserved-keywords-in-javascript/12114140#12114140):</p>
<blockquote>
<p>Let this long package float, Goto private class if short. While protected with debugger case, Continue volatile interface. Instanceof super synchronized throw, Extends final export throws.</p>
<p>Try import double enum? - False, boolean, abstract function, Implements typeof transient break! Void static, default do, Switch int native new. Else, delete null public var In return for const, true, char Finally catch byte.</p>
</blockquote>
<p><strong>Note:</strong> This poem includes words that were reserved in ES3 (<code>byte</code>, <code>long</code>, etc.) that are no longer reserved as of ES5.</p>
<p>Prior to ES5, the reserved words also could not be property names or keys in object literals, but that restriction no longer exists.</p>
<p>So, this is not allowed:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> <span class="im">import</span> <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">;</span></code></pre></div>
<p>But this is allowed:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span> <span class="dt">import</span><span class="op">:</span> <span class="st">&quot;42&quot;</span> <span class="op">};</span>
<span class="va">console</span>.<span class="at">log</span>( <span class="va">obj</span>.<span class="at">import</span> )<span class="op">;</span></code></pre></div>
<p>You should be aware though that some older browser versions (mainly older IE) weren't completely consistent on applying these rules, so there are places where using reserved words in object property name locations can still cause issues. Carefully test all supported browser environments.</p>
<h2 id="implementation-limits">Implementation Limits</h2>
<p>The JavaScript spec does not place arbitrary limits on things such as the number of arguments to a function or the length of a string literal, but these limits exist nonetheless, because of implementation details in different engines.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">addAll</span>() <span class="op">{</span>
    <span class="kw">var</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
    <span class="cf">for</span> (<span class="kw">var</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">arguments</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
        sum <span class="op">+=</span> arguments[i]<span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">return</span> sum<span class="op">;</span>
<span class="op">}</span>

<span class="kw">var</span> nums <span class="op">=</span> []<span class="op">;</span>
<span class="cf">for</span> (<span class="kw">var</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">100000</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
    <span class="va">nums</span>.<span class="at">push</span>(i)<span class="op">;</span>
<span class="op">}</span>

<span class="at">addAll</span>( <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">6</span> )<span class="op">;</span>              <span class="co">// 12</span>
<span class="va">addAll</span>.<span class="at">apply</span>( <span class="kw">null</span><span class="op">,</span> nums )<span class="op">;</span>     <span class="co">// should be: 499950000</span></code></pre></div>
<p>In some JS engines, you'll get the correct <code>499950000</code> answer, but in others (like Safari 6.x), you'll get the error: &quot;RangeError: Maximum call stack size exceeded.&quot;</p>
<p>Examples of other limits known to exist:</p>
<ul>
<li>maximum number of characters allowed in a string literal (not just a string value)</li>
<li>size (bytes) of data that can be sent in arguments to a function call (aka stack size)</li>
<li>number of parameters in a function declaration</li>
<li>maximum depth of non-optimized call stack (i.e., with recursion): how long a chain of function calls from one to the other can be</li>
<li>number of seconds a JS program can run continuously blocking the browser</li>
<li>maximum length allowed for a variable name</li>
<li>...</li>
</ul>
<p>It's not very common at all to run into these limits, but you should be aware that limits can and do exist, and importantly that they vary between engines.</p>
<h2 id="review-5">Review</h2>
<p>We know and can rely upon the fact that the JS language itself has one standard and is predictably implemented by all the modern browsers/engines. This is a very good thing!</p>
<p>But JavaScript rarely runs in isolation. It runs in an environment mixed in with code from third-party libraries, and sometimes it even runs in engines/environments that differ from those found in browsers.</p>
<p>Paying close attention to these issues improves the reliability and robustness of your code.</p>
<h1 id="you-dont-know-js-types-grammar-7">You Don't Know JS: Types &amp; Grammar</h1>
<h1 id="appendix-b-acknowledgments">Appendix B: Acknowledgments</h1>
<p>I have many people to thank for making this book title and the overall series happen.</p>
<p>First, I must thank my wife Christen Simpson, and my two kids Ethan and Emily, for putting up with Dad always pecking away at the computer. Even when not writing books, my obsession with JavaScript glues my eyes to the screen far more than it should. That time I borrow from my family is the reason these books can so deeply and completely explain JavaScript to you, the reader. I owe my family everything.</p>
<p>I'd like to thank my editors at O'Reilly, namely Simon St.Laurent and Brian MacDonald, as well as the rest of the editorial and marketing staff. They are fantastic to work with, and have been especially accommodating during this experiment into &quot;open source&quot; book writing, editing, and production.</p>
<p>Thank you to the many folks who have participated in making this book series better by providing editorial suggestions and corrections, including Shelley Powers, Tim Ferro, Evan Borden, Forrest L. Norvell, Jennifer Davis, Jesse Harlin, and many others. A big thank you to David Walsh for writing the Foreword for this title.</p>
<p>Thank you to the countless folks in the community, including members of the TC39 committee, who have shared so much knowledge with the rest of us, and especially tolerated my incessant questions and explorations with patience and detail. John-David Dalton, Juriy &quot;kangax&quot; Zaytsev, Mathias Bynens, Axel Rauschmayer, Nicholas Zakas, Angus Croll, Reginald Braithwaite, Dave Herman, Brendan Eich, Allen Wirfs-Brock, Bradley Meck, Domenic Denicola, David Walsh, Tim Disney, Peter van der Zee, Andrea Giammarchi, Kit Cambridge, Eric Elliott, and so many others, I can't even scratch the surface.</p>
<p>The <em>You Don't Know JS</em> book series was born on Kickstarter, so I also wish to thank all my (nearly) 500 generous backers, without whom this book series could not have happened:</p>
<blockquote>
<p>Jan Szpila, nokiko, Murali Krishnamoorthy, Ryan Joy, Craig Patchett, pdqtrader, Dale Fukami, ray hatfield, R0drigo Perez [Mx], Dan Petitt, Jack Franklin, Andrew Berry, Brian Grinstead, Rob Sutherland, Sergi Meseguer, Phillip Gourley, Mark Watson, Jeff Carouth, Alfredo Sumaran, Martin Sachse, Marcio Barrios, Dan, AimelyneM, Matt Sullivan, Delnatte Pierre-Antoine, Jake Smith, Eugen Tudorancea, Iris, David Trinh, simonstl, Ray Daly, Uros Gruber, Justin Myers, Shai Zonis, Mom &amp; Dad, Devin Clark, Dennis Palmer, Brian Panahi Johnson, Josh Marshall, Marshall, Dennis Kerr, Matt Steele, Erik Slagter, Sacah, Justin Rainbow, Christian Nilsson, Delapouite, D.Pereira, Nicolas Hoizey, George V. Reilly, Dan Reeves, Bruno Laturner, Chad Jennings, Shane King, Jeremiah Lee Cohick, od3n, Stan Yamane, Marko Vucinic, Jim B, Stephen Collins, gir orsteinsson, Eric Pederson, Owain, Nathan Smith, Jeanetteurphy, Alexandre ELIS, Chris Peterson, Rik Watson, Luke Matthews, Justin Lowery, Morten Nielsen, Vernon Kesner, Chetan Shenoy, Paul Tregoing, Marc Grabanski, Dion Almaer, Andrew Sullivan, Keith Elsass, Tom Burke, Brian Ashenfelter, David Stuart, Karl Swedberg, Graeme, Brandon Hays, John Christopher, Gior, manoj reddy, Chad Smith, Jared Harbour, Minoru TODA, Chris Wigley, Daniel Mee, Mike, Handyface, Alex Jahraus, Carl Furrow, Rob Foulkrod, Max Shishkin, Leigh Penny Jr., Robert Ferguson, Mike van Hoenselaar, Hasse Schougaard, rajan venkataguru, Jeff Adams, Trae Robbins, Rolf Langenhuijzen, Jorge Antunes, Alex Koloskov, Hugh Greenish, Tim Jones, Jose Ochoa, Michael Brennan-White, Naga Harish Muvva, Barkczi Dvid, Kitt Hodsden, Paul McGraw, Sascha Goldhofer, Andrew Metcalf, Markus Krogh, Michael Mathews, Matt Jared, Juanfran, Georgie Kirschner, Kenny Lee, Ted Zhang, Amit Pahwa, Inbal Sinai, Dan Raine, Schabse Laks, Michael Tervoort, Alexandre Abreu, Alan Joseph Williams, NicolasD, Cindy Wong, Reg Braithwaite, LocalPCGuy, Jon Friskics, Chris Merriman, John Pena, Jacob Katz, Sue Lockwood, Magnus Johansson, Jeremy Crapsey, Grzegorz Pawowski, nico nuzzaci, Christine Wilks, Hans Bergren, charles montgomery, Ariel - Fogel, Ivan Kolev, Daniel Campos, Hugh Wood, Christian Bradford, Frdric Harper, Ionu Dan Popa, Jeff Trimble, Rupert Wood, Trey Carrico, Pancho Lopez, Jol kuijten, Tom A Marra, Jeff Jewiss, Jacob Rios, Paolo Di Stefano, Soledad Penades, Chris Gerber, Andrey Dolganov, Wil Moore III, Thomas Martineau, Kareem, Ben Thouret, Udi Nir, Morgan Laupies, jory carson-burson, Nathan L Smith, Eric Damon Walters, Derry Lozano-Hoyland, Geoffrey Wiseman, mkeehner, KatieK, Scott MacFarlane, Brian LaShomb, Adrien Mas, christopher ross, Ian Littman, Dan Atkinson, Elliot Jobe, Nick Dozier, Peter Wooley, John Hoover, dan, Martin A. Jackson, Hctor Fernando Hurtado, andy ennamorato, Paul Seltmann, Melissa Gore, Dave Pollard, Jack Smith, Philip Da Silva, Guy Israeli, <span class="citation" data-cites="megalithic">@megalithic</span>, Damian Crawford, Felix Gliesche, April Carter Grant, Heidi, jim tierney, Andrea Giammarchi, Nico Vignola, Don Jones, Chris Hartjes, Alex Howes, john gibbon, David J. Groom, BBox, Yu 'Dilys' Sun, Nate Steiner, Brandon Satrom, Brian Wyant, Wesley Hales, Ian Pouncey, Timothy Kevin Oxley, George Terezakis, sanjay raj, Jordan Harband, Marko McLion, Wolfgang Kaufmann, Pascal Peuckert, Dave Nugent, Markus Liebelt, Welling Guzman, Nick Cooley, Daniel Mesquita, Robert Syvarth, Chris Coyier, Rmy Bach, Adam Dougal, Alistair Duggin, David Loidolt, Ed Richer, Brian Chenault, GoldFire Studios, Carles Andrs, Carlos Cabo, Yuya Saito, roberto ricardo, Barnett Klane, Mike Moore, Kevin Marx, Justin Love, Joe Taylor, Paul Dijou, Michael Kohler, Rob Cassie, Mike Tierney, Cody Leroy Lindley, tofuji, Shimon Schwartz, Raymond, Luc De Brouwer, David Hayes, Rhys Brett-Bowen, Dmitry, Aziz Khoury, Dean, Scott Tolinski - Level Up, Clement Boirie, Djordje Lukic, Anton Kotenko, Rafael Corral, Philip Hurwitz, Jonathan Pidgeon, Jason Campbell, Joseph C., SwiftOne, Jan Hohner, Derick Bailey, getify, Daniel Cousineau, Chris Charlton, Eric Turner, David Turner, Jol Galeran, Dharma Vagabond, adam, Dirk van Bergen, dave  furf, Vedran Zakanj, Ryan McAllen, Natalie Patrice Tucker, Eric J. Bivona, Adam Spooner, Aaron Cavano, Kelly Packer, Eric J, Martin Drenovac, Emilis, Michael Pelikan, Scott F. Walter, Josh Freeman, Brandon Hudgeons, vijay chennupati, Bill Glennon, Robin R., Troy Forster, otaku_coder, Brad, Scott, Frederick Ostrander, Adam Brill, Seb Flippence, Michael Anderson, Jacob, Adam Randlett, Standard, Joshua Clanton, Sebastian Kouba, Chris Deck, SwordFire, Hannes Papenberg, Richard Woeber, hnzz, Rob Crowther, Jedidiah Broadbent, Sergey Chernyshev, Jay-Ar Jamon, Ben Combee, luciano bonachela, Mark Tomlinson, Kit Cambridge, Michael Melgares, Jacob Adams, Adrian Bruinhout, Bev Wieber, Scott Puleo, Thomas Herzog, April Leone, Daniel Mizieliski, Kees van Ginkel, Jon Abrams, Erwin Heiser, Avi Laviad, David newell, Jean-Francois Turcot, Niko Roberts, Erik Dana, Charles Neill, Aaron Holmes, Grzegorz Zikowski, Nathan Youngman, Timothy, Jacob Mather, Michael Allan, Mohit Seth, Ryan Ewing, Benjamin Van Treese, Marcelo Santos, Denis Wolf, Phil Keys, Chris Yung, Timo Tijhof, Martin Lekvall, Agendine, Greg Whitworth, Helen Humphrey, Dougal Campbell, Johannes Harth, Bruno Girin, Brian Hough, Darren Newton, Craig McPheat, Olivier Tille, Dennis Roethig, Mathias Bynens, Brendan Stromberger, sundeep, John Meyer, Ron Male, John F Croston III, gigante, Carl Bergenhem, B.J. May, Rebekah Tyler, Ted Foxberry, Jordan Reese, Terry Suitor, afeliz, Tom Kiefer, Darragh Duffy, Kevin Vanderbeken, Andy Pearson, Simon Mac Donald, Abid Din, Chris Joel, Tomas Theunissen, David Dick, Paul Grock, Brandon Wood, John Weis, dgrebb, Nick Jenkins, Chuck Lane, Johnny Megahan, marzsman, Tatu Tamminen, Geoffrey Knauth, Alexander Tarmolov, Jeremy Tymes, Chad Auld, Sean Parmelee, Rob Staenke, Dan Bender, Yannick derwa, Joshua Jones, Geert Plaisier, Tom LeZotte, Christen Simpson, Stefan Bruvik, Justin Falcone, Carlos Santana, Michael Weiss, Pablo Villoslada, Peter deHaan, Dimitris Iliopoulos, seyDoggy, Adam Jordens, Noah Kantrowitz, Amol M, Matthew Winnard, Dirk Ginader, Phinam Bui, David Rapson, Andrew Baxter, Florian Bougel, Michael George, Alban Escalier, Daniel Sellers, Sasha Rudan, John Green, Robert Kowalski, David I. Teixeira (<span class="citation" data-cites="ditma">@ditma</span>, Charles Carpenter, Justin Yost, Sam S, Denis Ciccale, Kevin Sheurs, Yannick Croissant, Pau Fracs, Stephen McGowan, Shawn Searcy, Chris Ruppel, Kevin Lamping, Jessica Campbell, Christopher Schmitt, Sablons, Jonathan Reisdorf, Bunni Gek, Teddy Huff, Michael Mullany, Michael Frstenberg, Carl Henderson, Rick Yoesting, Scott Nichols, Hernn Ciudad, Andrew Maier, Mike Stapp, Jesse Shawl, Srgio Lopes, jsulak, Shawn Price, Joel Clermont, Chris Ridmann, Sean Timm, Jason Finch, Aiden Montgomery, Elijah Manor, Derek Gathright, Jesse Harlin, Dillon Curry, Courtney Myers, Diego Cadenas, Arne de Bree, Joo Paulo Dubas, James Taylor, Philipp Kraeutli, Mihai Pun, Sam Gharegozlou, joshjs, Matt Murchison, Eric Windham, Timo Behrmann, Andrew Hall, joshua price, Thophile Villard</p>
</blockquote>
<p>This book series is being produced in an open source fashion, including editing and production. We owe GitHub a debt of gratitude for making that sort of thing possible for the community!</p>
<p>Thank you again to all the countless folks I didn't name but who I nonetheless owe thanks. May this book series be &quot;owned&quot; by all of us and serve to contribute to increasing awareness and understanding of the JavaScript language, to the benefit of all current and future community contributors.</p>
</body>
</html>
